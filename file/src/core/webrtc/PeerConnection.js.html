<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/core/webrtc/PeerConnection.js | Reach</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Webcom-reach"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Reach"><meta property="twitter:description" content="Webcom-reach"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/webcom-components/reach"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reach.js~Reach.html">Reach</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core">core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Config.js~Config.html">Config</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Invite.js~Invite.html">Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Message.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Participant.js~Participant.html">Participant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Room.js~Room.html">Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/User.js~User.html">User</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-stream">core/stream</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Local.js~Local.html">Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Remote.js~Remote.html">Remote</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-util">core/util</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/util/Media.js~Media.html">Media</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-webrtc">core/webrtc</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/webrtc/PeerConnection.js~PeerConnection.html">PeerConnection</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#definitions">definitions</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Browser">Browser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/audio">Codec/audio</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/video">Codec/video</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CommunicationQuality/bitrate">CommunicationQuality/bitrate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Invite">Events/Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Local">Events/Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Reach">Events/Reach</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Room">Events/Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Stream">Events/Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ICEServer">ICEServer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StreamTypes">StreamTypes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-datasync">external/datasync</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/Webcom.html">Webcom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/api.Query.html#~cancelCallback">Webcom/api.Query~cancelCallback</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-dom">external/dom</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element">Element</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-webrtc">external/webrtc</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://w3c.github.io/mediacapture-main/#idl-def-MediaDeviceInfo">MediaDeviceInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#stream-api">MediaStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints">MediaStreamConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints">MediaTrackConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#interface-definition">RTCPeerConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcrtpsender-interface">RTCRtpSender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcsessiondescription-class">RTCSessionDescription</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/core/webrtc/PeerConnection.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* global RTCPeerConnection */
/* global RTCRtpSender */
import SocketIO from &apos;socket.io-client&apos;;
import GetStats from &apos;getstats&apos;;
import cache from &apos;../util/cache&apos;;
import * as Log from &apos;../util/Log&apos;;
import Media from &apos;../util/Media&apos;;
import Device from &apos;../Device&apos;;
import * as DataSync from &apos;../util/DataSync&apos;;
import { CLOSED, CLOSING, OPENED } from &apos;../util/constants&apos;;
import &apos;core-js/fn/array/find&apos;;

const DtlsSrtpKeyAgreement = { DtlsSrtpKeyAgreement: true };
const sdpConstraints = receive =&gt; ({ OfferToReceiveAudio: receive, OfferToReceiveVideo: receive });
/**
 * ICE connection status : disconnected
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_DISCONNECTED = &apos;disconnected&apos;;
/**
 * ICE connection status : connected
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_CONNECTED = &apos;connected&apos;;
/**
 * ICE connection status : completed
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_COMPLETED = &apos;completed&apos;;
/**
 * ICE connection status : checking
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_CHECKING = &apos;checking&apos;;
/**
 * ICE connection status : closed
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_CLOSED = &apos;closed&apos;;
/**
 * ICE connection status : failed
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_FAILED = &apos;failed&apos;;
/**
 * ICE connection status : another status
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_OTHER = &apos;other&apos;;
/**
 * @ignore
 */
const _toJSON = o =&gt; (o.toJSON &amp;&amp; typeof o.toJSON === &apos;function&apos; ? o.toJSON() : o);
/**
 * The PeerConnection. A PeerConnection will only concern one MediaStream.
 * @class PeerConnection
 */
export default class PeerConnection {
  /**
   * @access protected
   * @param {string} stackId The WebRTC stack ID
   * @param {string} streamId The Stream UID
   * @param {Remote|{to: string|from: string, device:string}} remote The remote information
   * @param {boolean} publish Publish or Subscribe ?
   */
  constructor(stackId, streamId, remote, publish) {
    /**
     * The stack identifier. Used to identify exchanges between 2 devices
     * @type {string}
     */
    this.stackId = stackId;
    /**
     * The stream id. (One stream per RTCPeerConnection)
     * @type {string}
     */
    this.streamId = streamId;
    /**
     * The remote device
     * @type {string}
     */
    this.remote = remote;
    /**
     * publish : a created peer connection or a remote one
     * @type {boolean}
     */
    this.publish = publish;
    /**
     * Path for local signalization
     * @access private
     * @type {string}
     */
    this._localPath = `_/webrtc/${this.stackId}/${this.streamId}/${cache.device}`;
    /**
     * Path for local signalization
     * @access private
     * @type {string}
     */
    this._remotePath = `_/webrtc/${this.stackId}/${this.streamId}/${this.remote.device}`;
    /**
     * Indicates if the PeerConnection has been established. (Useful for renegotiation).
     * @type {boolean}
     */
    this.negotiated = false;
    /**
     * The DOM element where the remote MediaStream will be displayed
     * @type {Element}
     * @protected
     */
    this.node = null;
    /**
     * The DOM element containg the media element
     * @type {Element}
     * @protected
     */
    this.container = null;
    /**
     * The callback called when there is an error
     * @type {Element}
     * @access private
     */
    this._errorCallbacks = [];
    /**
     * The actual RTCPeerConnection
     * @type {RTCPeerConnection}
     */
    this.pc = new RTCPeerConnection(
      {
        iceServers: cache.config.iceServers
      },
      {
        optional: [DtlsSrtpKeyAgreement],
        mandatory: sdpConstraints(!publish)
      }
    );
    // Handle ICE candidates
    this.pc.onicecandidate = (e) =&gt; {
      if (!this.negotiated &amp;&amp; e.candidate) {
        Log.d(&apos;PeerConnection~onicecandidate&apos;, e.candidate);
        DataSync.push(`${this._localPath}/ice`, _toJSON(e.candidate));
      }
    };
    this.pc.oniceconnectionstatechange = () =&gt; {
      Log.d(&apos;PeerConnection~oniceconnectionstatechange&apos;, this.pc);
      const { iceConnectionState } = this.pc;
      switch (iceConnectionState) {
        case ICE_CONNECTION_STATE_CHECKING:
          // Nothing to do yet
          break;
        case ICE_CONNECTION_STATE_CONNECTED:
          Log.e(&apos;PeerConnection~stateConnected&apos;, this._errorCallbacks);
          this._attachStream();
          this._remoteICECandidates(false);
          this._getStats();
          break;
        case ICE_CONNECTION_STATE_COMPLETED:
          this._remoteICECandidates(false);
          break;
        case ICE_CONNECTION_STATE_FAILED:
          Log.e(&apos;PeerConnection~stateFailed&apos;, &apos;Failed PeerConnection&apos;);
          this._errorCallbacks.forEach(cb =&gt; cb(&apos;ICE_CONNECTION_STATE_FAILED&apos;));
          break;
        case ICE_CONNECTION_STATE_DISCONNECTED:
          Log.e(&apos;PeerConnection~stateDisconnected&apos;, &apos;Disconnect PeerConnection&apos;);
          break;
        case ICE_CONNECTION_STATE_CLOSED:
          Log.d(&apos;PeerConnection~stateclosed&apos;, &apos;Close PeerConnection&apos;);
          this.close();
          break;
        default:
          break;
      }
      this.negotiated = this.negotiated || this.isConnected;
    };

    this.pc.onicegatheringstatechange = () =&gt; {
      Log.d(&apos;PeerConnection~onicegatheringstatechange&apos;, this.pc.iceGatheringState);
    };

    /**
     * PeerConnection status
     * @type {string}
     * @private
     */
    this._status = OPENED;
  }

  _getStats() {
    Log.d(&apos;PeerConnection~getStats&apos;,
      `enable : ${cache.config.stats.server &amp;&amp; cache.config.stats.interval
        ? `to ${cache.config.stats.server}`
        : &apos;false&apos;}`);
    if (cache.config.stats.server &amp;&amp; cache.config.stats.interval) {
      // this._socket = SocketIO(cache.config.stats.server);
      GetStats(this.pc, (result) =&gt; {
        this.socket.emit(&apos;stats&apos;, Object.assign({
          id: this.streamId,
          publish: this.publish,
          room: cache.room.name,
          ts: new Date(),
          local: cache.device,
          remote: this.remote.device
        }, result));
      }, cache.config.stats.interval);
    }
  }

  get socket() {
    if (!this._socket) {
      this._socket = SocketIO(cache.config.stats.server);
    }
    return this._socket;
  }

  /**
   * Toggle ICE Candidates discovery
   * @access private
   * @param {boolean} listen Indicates if we should listen to new ICE candidates
   */
  _remoteICECandidates(listen) {
    const
      path = `${this._remotePath}/ice`;


    const event = &apos;child_added&apos;;
    if (listen) {
      // don&apos;t listen to ice candidates if pc is already up (renegotiation)
      DataSync.on(path, event, (snap) =&gt; {
        const candidate = snap.val();
        Log.d(&apos;PeerConnection~addIceCandidate&apos;, candidate);
        this.pc.addIceCandidate(new RTCIceCandidate(candidate));
      });
    } else {
      DataSync.off(path, event);
    }
  }

  /**
   * Attach the remote MediaStream to a node
   * @access private
   */
  _attachStream() {
    if (this.remoteStream &amp;&amp; this.isConnected) {
      this.node = Media.attachStream(this.remoteStream, this.container, this.node);
      this.node.muted = false;
    }
  }

  /**
   * The remote MediaStream
   * @access protected
   * @type {MediaStream}
   */
  set remoteStream(stream) {
    /**
     * @ignore
     */
    this._remoteStream = stream;
    this._attachStream();
  }

  /**
   * The remote MediaStream
   * @type {MediaStream}
   */
  get remoteStream() {
    return this._remoteStream;
  }

  /**
   * Indicates if the PeerConnection is established based on ICE connection state
   * @returns {boolean}
   */
  get isConnected() {
    return this.pc
      &amp;&amp; !!~[ // eslint-disable-line no-bitwise
        ICE_CONNECTION_STATE_CONNECTED,
        ICE_CONNECTION_STATE_COMPLETED,
        ICE_CONNECTION_STATE_OTHER
      ].indexOf(this.pc.iceConnectionState);
  }

  /**
   * Init RTCPeerConnection for subscribers
   * @access protected
   * @param htmlElement
   * @param errorCallbacks
   * @returns {Promise.&lt;PeerConnection&gt;}
   */
  answer(htmlElement, errorCallbacks = []) {
    Log.i(&apos;PeerConnection~answer&apos;, { htmlElement, peerConnection: this });
    this.container = htmlElement;
    this._errorCallbacks = errorCallbacks;
    if (Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, &apos;ontrack&apos;)) {
      this.pc.ontrack = (e) =&gt; {
        Log.d(&apos;PeerConnection~ontrack&apos;, e.streams[0]);
        this.remoteStream = e.streams[0]; // eslint-disable-line prefer-destructuring
      };
    } else {
      this.pc.onaddstream = (e) =&gt; {
        Log.d(&apos;PeerConnection~onaddstream&apos;, e.stream);
        this.remoteStream = e.stream;
      };
    }

    // Listen to SDP offer
    DataSync.on(`${this._remotePath}/sdp`, &apos;value&apos;, (snap) =&gt; {
      const sdpOffer = snap.val();
      // Log.d(&apos;Offer&apos;, sdpOffer.sdp);
      if (sdpOffer != null) {
        Log.d(&apos;PeerConnection~offered&apos;, sdpOffer.sdp);
        this.pc.setRemoteDescription(sdpOffer)
          .catch((e) =&gt; {
            Log.e(&apos;PeerConnection~answer#remoteDescription Error&apos;, e);
            errorCallbacks.forEach((cb) =&gt; {
              Log.d(&apos;PeerConnection~answer#remoteDescription Error callback&apos;, e);
              cb(e);
            });
            return e;
            // cache.peerConnections.close(this.streamId, this.remote.device);
          })
          .then(() =&gt; Log.d(&apos;PeerConnection~answer#remoteDescription&apos;, this.pc.remoteDescription.sdp))
          .then(() =&gt; {
            if (/^offer$/.test(this.pc.remoteDescription.type)) {
              return this.pc.createAnswer()
                .catch(e =&gt; Log.d.bind(Log, &apos;PeerConnections~answer#createAnswer&apos;, e));
            }
            return Promise.reject(new Error(&apos;SDP is not an offer&apos;));
          })
          .then(description =&gt; this._setPreferredCodecs(description))
          .then((description) =&gt; {
            this.pc.setLocalDescription(description);
            return this.setLowerMediaBitrates(description, this.pc.remoteDescription);
          })
          .catch(e =&gt; Log.d.bind(Log, &apos;PeerConnections~answer#setLocalDescription&apos;, e))
          .then((newDescription) =&gt; {
            Log.d(&apos;PeerConnection~answer#localSDP&apos;, newDescription.sdp);
            this._remoteICECandidates(true);
            return newDescription;
          })
          .then(newDescription =&gt; this._sendSdpToRemote(newDescription))
          // .catch(Log.r(&apos;PeerConnection~answser#error&apos;));
          .catch(() =&gt; {
            // this.close();
            cache.peerConnections.close(this.streamId, this.remote.device);
          });
      }
    });

    return Promise.resolve(this);
  }

  /**
   * Init RTCPeerConnection for publishers
   * @access protected
   * @param stream
   * @param errorCallbacks
   * @returns {Promise.&lt;PeerConnection&gt;}
   */
  offer(stream, errorCallbacks = []) {
    Log.i(&apos;PeerConnection~offer&apos;, { stream, peerConnection: this });
    let sendTimeout;
    return new Promise((resolve, reject) =&gt; {
      this.pc.onnegotiationneeded = () =&gt; {
        Log.d(&apos;PeerConnection~onnegotiationneeded&apos;);
        // Debounce send (renegotiation triggers multiple negotiationneeded events)
        if (sendTimeout) {
          clearTimeout(sendTimeout);
          sendTimeout = null;
        }
        sendTimeout = setTimeout(() =&gt; {
          sendTimeout = null;
          this._sendOffer()
            .catch((e) =&gt; {
              Log.d(&apos;PeerConnection~offer&apos;, e);
              errorCallbacks.forEach(cb =&gt; cb(e));
              reject(e);
            })
            .then(() =&gt; {
              resolve(this);
            });
        }, 20);
      };
      DataSync.on(`${this._remotePath}/sdp`, &apos;value&apos;, (snap) =&gt; {
        const sdpAnswer = snap.val();
        if (sdpAnswer != null) {
          Log.d(`PeerConnection~offer#answered ${sdpAnswer.sdp}`);
          this.pc.setRemoteDescription(sdpAnswer)
            .catch((e) =&gt; {
              errorCallbacks.forEach(cb =&gt; cb(e));
              cache.peerConnections.close(this.streamId, this.remote.device);
              Log.e.bind(Log, &apos;PeerConnection~offer#remoteDescription&apos;);
            })
            .then(() =&gt; {
              Log.d(&apos;PeerConnection~offer#remoteDescription&apos;, this.pc.remoteDescription.sdp);
              this._remoteICECandidates(true);
            });
        }
      });
      this._alterStream(stream, &apos;add&apos;);
    });
  }

  /**
   * Send SDP offer to the remote via DataSync
   * @private
   * @param newDesc
   */
  _sendSdpToRemote(newDesc) {
    // Log.d(&apos;PeerConnection~_sendSdpToRemote#localSDP&apos;, this.pc.localDescription.sdp);
    const remoteUserId = this.remote.to ? this.remote.to : this.remote.from;
    Device.get(remoteUserId, this.remote.device)
      .then((remoteDevice) =&gt; {
        const sdpOffer = newDesc.sdp; // 1109 - Didn&apos;t use pc.localDescription to set bitrate on SDP
        let newSdp = sdpOffer;
        const local = /Chrome\/([0-9]+)/.exec(navigator.userAgent);
        const remote = /Chrome\/([0-9]+)/.exec(remoteDevice.userAgent);
        if (navigator.userAgent.indexOf(&apos;Chrome&apos;) !== -1
          &amp;&amp; navigator.userAgent.indexOf(&apos;Android&apos;) !== -1
          &amp;&amp; remoteDevice.userAgent.indexOf(&apos;Safari&apos;) !== -1
          &amp;&amp; local[1] &lt;= 64) {
          if (local[1] &lt;= 60) {
            newSdp = newSdp.replace(/;profile-level-id=([a-z0-9]+)/, &apos;&apos;);
          } else {
            newSdp = newSdp.replace(&apos;42001f&apos;, &apos;42e01f&apos;);
          }
        }
        if (navigator.userAgent.indexOf(&apos;Safari&apos;) !== -1
          &amp;&amp; remoteDevice.userAgent.indexOf(&apos;Chrome&apos;) !== -1
          &amp;&amp; remoteDevice.userAgent.indexOf(&apos;Android&apos;) !== -1
          &amp;&amp; remote[1] &lt;= 64) {
          if (remote[1] &lt;= 60) {
            newSdp = newSdp.replace(/;profile-level-id=([a-z0-9]+)/, &apos;&apos;);
          } else {
            newSdp = newSdp.replace(&apos;42e01f&apos;, &apos;42001f&apos;);
          }
        }
        Log.d(`PeerConnection~_sendSdpToRemote#SDP sent to remote ${newSdp}`);
        const descriptionChanged = {
          sdp: newSdp,
          type: newDesc.type
        };
        DataSync.update(`${this._localPath}/sdp`, _toJSON(descriptionChanged));
      });
  }

  /**
   * Create SDP offer and push it
   * @returns {Promise}
   * @private
   */
  _sendOffer() {
    Log.d(&apos;PeerConnection~_sendOffer&apos;);
    return this.pc.createOffer()
      .then(description =&gt; this._setPreferredCodecs(description))
      .then((description) =&gt; {
        this.pc.setLocalDescription(description);
        return this.setMediaBitrates(description);
      })
      .then((newDesc) =&gt; {
        Log.d(&apos;PeerConnection~_sendOffer#localDescription&apos;, newDesc.sdp);
        return newDesc;
      })
      .then(newDesc =&gt; this._sendSdpToRemote(newDesc));
  }

  /**
   * Add/Remove tracks to the PeerConnection stream
   * @param {MediaStream} stream
   * @param {string} method
   * @private
   */
  _alterStream(stream, method) {
    if (Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, `${method}Track`)) {
      if (method === &apos;add&apos;) {
        stream.getTracks().forEach(track =&gt; this.pc[`${method}Track`](track, stream), this);
      } else {
        this.pc.getSenders().forEach(sender =&gt; this.pc[`${method}Track`](sender), this);
      }
    } else {
      this.pc[`${method}Stream`](stream);
    }
  }

  /**
   * Restart SDP negotiation following a MediaStream change
   * @access protected
   * @param {MediaStream} oldStream
   * @param {MediaStream} newStream
   */
  renegotiate(oldStream, newStream) {
    Log.d(&apos;PeerConnection~renegotiate&apos;);
    if ((Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, &apos;getSenders&apos;))
      &amp;&amp; (&apos;RTCRtpSender&apos; in window)
      &amp;&amp; Object.getOwnPropertyDescriptor(RTCRtpSender.prototype, &apos;replaceTrack&apos;)) {
      // mozRTCPeerConnection implementation
      this.pc.getSenders().forEach((sender) =&gt; {
        let newTracks;
        switch (sender.track.kind) {
          case &apos;audio&apos;:
            newTracks = newStream.getAudioTracks();
            break;
          case &apos;video&apos;:
            newTracks = newStream.getVideoTracks();
            break;
          default:
            newTracks = [];
        }
        if (newTracks.length) {
          sender.replaceTrack(newTracks[0]);
        }
      });
      this._sendOffer()
        .catch((e) =&gt; {
          Log.d(&apos;PeerConnection~renegotiate&apos;, e);
        });
    } else {
      this._alterStream(oldStream, &apos;remove&apos;);
      this._alterStream(newStream, &apos;add&apos;);
    }
  }

  /**
   * Close the PeerConnection and stop listening to SDP messages
   * @access protected
   */
  close() {
    if (this._status === OPENED) {
      this._status = CLOSING;
      // Stop display
      if (this.node) {
        if (this.node.stop) {
          this.node.stop();
        }
        this.node.srcObject = null;
        this.container.removeChild(this.node);
        this.node = null;
      }
      // Stop listening to remote ICE candidates
      this._remoteICECandidates(false);
      // Stop listening to SDP messages
      DataSync.off(`${this._remotePath}/sdp`, &apos;value&apos;);
      // Remove data
      DataSync.remove(this._localPath);
      // Close PeerConnection
      if (this.pc &amp;&amp; this.pc.signalingState !== &apos;closed&apos;) {
        this.pc.onsignalingstatechange = () =&gt; {
          if (this.pc.signalingState !== &apos;closed&apos;) {
            this._status = CLOSED;
          }
        };
        this.pc.close();
      } else {
        this._status = CLOSED;
      }
    }
  }

  /**
   * Edits the SDP to set the preferred audio/video codec
   * @access private
   * @param {RTCSessionDescription} description
   * The description retrieved by createOffer/createAnswer
   * @returns {RTCSessionDescription|{sdp: string, type: string}}
   */
  _setPreferredCodecs(description) {
    if (cache.config.preferredVideoCodec || cache.config.preferredAudioCodec) {
      Log.d(&apos;PeerConnection~_setPreferredCodecs&apos;, { description, config: cache.config });
      const sdpLines = description.sdp.split(/\r?\n/);
      const medias = { audio: [], video: [] };
      let current = null;
      // Parse SDP
      sdpLines.forEach((sdpLine, i) =&gt; {
        if (/^m=/.test(sdpLine)) {
          // eslint-disable-next-line no-useless-escape
          const d = /^m=(\w+)\s[0-9\/]+\s[A-Za-z0-9\/]+\s([0-9\s]+)/.exec(sdpLine);
          current = {
            fmt: d[2].split(/\s/),
            index: i,
            codecs: []
          };
          medias[d[1]].push(current);
        } else if (current &amp;&amp; /^a=rtpmap:/.test(sdpLine)) {
          // eslint-disable-next-line no-useless-escape
          const c = /^a=rtpmap:(\d+)\s([a-zA-Z0-9\-\/]+)/.exec(sdpLine);
          if (c) {
            current.codecs.push({
              id: c[1],
              name: c[2],
              index: i
            });
          }
        }
      });
      Log.d(&apos;PeerConnection~_setPreferredCodecs&apos;, medias);
      let update = false;
      const prefer = (mediaList, preferedCodec) =&gt; {
        mediaList.forEach((media) =&gt; {
          const selected = media.codecs.find(codec =&gt; preferedCodec.test(codec.name));
          if (selected) {
            const fmt = [selected.id].concat(media.fmt.filter(ids =&gt; ids !== selected.id));
            sdpLines[media.index] = sdpLines[media.index].replace(media.fmt.join(&apos; &apos;),
              fmt.join(&apos; &apos;));
            update = true;
          }
        });
      };
      if (cache.config.preferredVideoCodec) {
        prefer(medias.video, cache.config.preferredVideoCodec);
      }
      if (cache.config.preferredAudioCodec) {
        prefer(medias.audio, cache.config.preferredAudioCodec);
      }
      if (update) {
        Log.d(&apos;PeerConnection~_setPreferredCodecs&apos;, sdpLines.join(&apos;\r\n&apos;));
        return {
          sdp: sdpLines.join(&apos;\r\n&apos;),
          type: description.type
        };
      }
    }
    return description;
  }

  setLowerMediaBitrates(description, remoteDescription) {
    let videoBitrate = null;
    let audioBitrate = null;
    if (cache.config.communicationQuality) {
      videoBitrate = cache.config.communicationQuality.video;
      audioBitrate = cache.config.communicationQuality.audio;
    }
    if (cache.config.audioBitrateMax) {
      if (((audioBitrate &amp;&amp; parseInt(audioBitrate, 10) &gt; parseInt(cache.config.audioBitrateMax, 10))
       || !audioBitrate)) {
        audioBitrate = cache.config.audioBitrateMax;
      }
    }
    if (cache.config.videoBitrateMax) {
      if (((videoBitrate &amp;&amp; parseInt(videoBitrate, 10) &gt; parseInt(cache.config.videoBitrateMax, 10))
       || !videoBitrate)) {
        videoBitrate = cache.config.videoBitrateMax;
      }
    }
    const audioRemoteBitrate = this.getMediaBitrateFromDesc(remoteDescription, &apos;audio&apos;);
    const videoRemoteBitrate = this.getMediaBitrateFromDesc(remoteDescription, &apos;video&apos;);
    if (audioRemoteBitrate) {
      if (((audioBitrate &amp;&amp; parseInt(audioBitrate, 10) &gt; parseInt(audioRemoteBitrate, 10))
        || !audioBitrate)) {
        audioBitrate = audioRemoteBitrate;
      }
    }
    if (videoRemoteBitrate) {
      if (((videoBitrate &amp;&amp; parseInt(videoBitrate, 10) &gt; parseInt(videoRemoteBitrate, 10))
        || !videoBitrate)) {
        videoBitrate = videoRemoteBitrate;
      }
    }
    return this._setMediaBitrate(this._setMediaBitrate(description, &apos;video&apos;, videoBitrate), &apos;audio&apos;, audioBitrate);
  }

  getMediaBitrateFromDesc(description, mediaType) {
    let bitrateResult = null;
    if (description) {
      const sdpLines = description.sdp.split(/\r?\n/);
      let mediaLineIndex = -1;
      const mediaLine = `m=${mediaType}`;
      let bitrateLineIndex = -1;
      mediaLineIndex = sdpLines.findIndex(line =&gt; line.startsWith(mediaLine));

      // If we find a line matching &#x201C;m={mediaType}&#x201D;
      if (mediaLineIndex &amp;&amp; mediaLineIndex &lt; sdpLines.length) {
        // Skip the media line
        bitrateLineIndex = mediaLineIndex + 1;

        // Skip both i=* and c=* lines (bandwidths limiters have to come afterwards)
        while (sdpLines[bitrateLineIndex].startsWith(&apos;i=&apos;) || sdpLines[bitrateLineIndex].startsWith(&apos;c=&apos;)) {
          bitrateLineIndex += 1;
        }
        if (sdpLines[bitrateLineIndex].startsWith(&apos;b=&apos;)) {
          // If the next line is a b=* line, get the bandwidth
          bitrateResult = sdpLines[bitrateLineIndex].substring(5);
        }
      }
    }
    return bitrateResult;
  }

  setMediaBitrates(description) {
    let videoBitrate = null;
    let audioBitrate = null;
    if (cache.config.communicationQuality) {
      videoBitrate = cache.config.communicationQuality.video;
      audioBitrate = cache.config.communicationQuality.audio;
    }
    if (cache.config.audioBitrateMax) {
      if (((audioBitrate &amp;&amp; parseInt(audioBitrate, 10) &gt; parseInt(cache.config.audioBitrateMax, 10))
        || !audioBitrate)) {
        audioBitrate = cache.config.audioBitrateMax;
      }
    }
    if (cache.config.videoBitrateMax) {
      if (((videoBitrate &amp;&amp; parseInt(videoBitrate, 10) &gt; parseInt(cache.config.videoBitrateMax, 10))
        || !videoBitrate)) {
        videoBitrate = cache.config.videoBitrateMax;
      }
    }
    return this._setMediaBitrate(this._setMediaBitrate(description, &apos;video&apos;, videoBitrate), &apos;audio&apos;, audioBitrate);
  }

  _setMediaBitrate(description, mediaType, bitrate) {
    const sdpLines = description.sdp.split(/\r?\n/);
    let mediaLineIndex = -1;
    const mediaLine = `m=${mediaType}`;
    let bitrateLineIndex = -1;
    const bitrateLine = `b=AS:${bitrate}`;
    mediaLineIndex = sdpLines.findIndex(line =&gt; line.startsWith(mediaLine));

    // If we find a line matching &#x201C;m={mediaType}&#x201D;
    if (mediaLineIndex &amp;&amp; mediaLineIndex &lt; sdpLines.length) {
      // Skip the media line
      bitrateLineIndex = mediaLineIndex + 1;

      // Skip both i=* and c=* lines (bandwidths limiters have to come afterwards)
      while (sdpLines[bitrateLineIndex].startsWith(&apos;i=&apos;) || sdpLines[bitrateLineIndex].startsWith(&apos;c=&apos;)) {
        bitrateLineIndex += 1;
      }
      if (bitrate) { // If bitrate not null =&gt; set the value, else defaults value are setted
        if (sdpLines[bitrateLineIndex].startsWith(&apos;b=&apos;)) {
          // If the next line is a b=* line, replace it with our new bandwidth
          // AND the new bitrate is smaller
          if (parseInt(sdpLines[bitrateLineIndex].substring(5), 10) &gt; parseInt(bitrate, 10)) {
            sdpLines[bitrateLineIndex] = bitrateLine;
          }
        } else {
          // Otherwise insert a new bitrate line.
          sdpLines.splice(bitrateLineIndex, 0, bitrateLine);
        }
      } else if (sdpLines[bitrateLineIndex].startsWith(&apos;b=&apos;)) {
        // If the next line is a b=* line, remove it to have the default bandwidth
        sdpLines.splice(bitrateLineIndex, 1);
      }
    }

    // Then return the description with the updated sdp content as a string
    return {
      sdp: sdpLines.join(&apos;\r\n&apos;),
      type: description.type
    };
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
