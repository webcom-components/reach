<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/core/stream/Local.js | Reach</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Webcom-reach"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Reach"><meta property="twitter:description" content="Webcom-reach"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/webcom-components/reach"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reach.js~Reach.html">Reach</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core">core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Config.js~Config.html">Config</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Invite.js~Invite.html">Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Message.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Participant.js~Participant.html">Participant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Room.js~Room.html">Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/User.js~User.html">User</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-stream">core/stream</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Local.js~Local.html">Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Remote.js~Remote.html">Remote</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-util">core/util</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/util/Media.js~Media.html">Media</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-webrtc">core/webrtc</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/webrtc/PeerConnection.js~PeerConnection.html">PeerConnection</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#definitions">definitions</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Browser">Browser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/audio">Codec/audio</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/video">Codec/video</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CommunicationQuality/bitrate">CommunicationQuality/bitrate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Invite">Events/Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Local">Events/Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Reach">Events/Reach</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Room">Events/Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Stream">Events/Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ICEServer">ICEServer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StreamTypes">StreamTypes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-datasync">external/datasync</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/Webcom.html">Webcom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/api.Query.html#~cancelCallback">Webcom/api.Query~cancelCallback</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-dom">external/dom</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element">Element</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-webrtc">external/webrtc</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://w3c.github.io/mediacapture-main/#idl-def-MediaDeviceInfo">MediaDeviceInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#stream-api">MediaStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints">MediaStreamConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints">MediaTrackConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#interface-definition">RTCPeerConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcrtpsender-interface">RTCRtpSender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcsessiondescription-class">RTCSessionDescription</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/core/stream/Local.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import * as StreamTypes from &apos;../../definitions/StreamTypes&apos;;
import * as Log from &apos;../util/Log&apos;;
import cache from &apos;../util/cache&apos;;
import * as DataSync from &apos;../util/DataSync&apos;;
import Media from &apos;../util/Media&apos;;
import {
  CLOSED,
  CLOSING,
  CONNECTED,
  NONE
} from &apos;../util/constants&apos;;
import * as Events from &apos;../../definitions/Events&apos;;

const _facingModes = [Media.facingMode.USER, Media.facingMode.ENVIRONMENT];

const _getConstraintValue = (constraints, prop) =&gt; (
  constraints[prop].exact || constraints[prop].ideal || constraints[prop]
);

/* eslint-disable no-param-reassign */
const _setConstrainValue = (constraints, prop, other, value) =&gt; {
  constraints[prop] = { exact: value };
  delete constraints[other];
};
/* eslint-enable no-param-reassign */

/**
 * The local stream
 */
export default class Local {
  /**
   * @access protected
   * @param {object} values
   */
  constructor(values) {
    /**
     * The uid of the room the stream is published in
     * @type {string}
     */
    this.roomId = values.roomId;
    /**
     * The uid of this stream
     * @type {string}
     */
    this.uid = values.uid;
    /**
     * The type of the stream
     * @type {string}
     */
    this.type = values.type;
    /**
     * Indicates if a track is muted
     * @type {{audio: boolean, video: boolean}}
     */
    this.muted = Object.assign({ audio: false, video: false }, values.muted);
    /**
     * The local DOM container element where the {@link Local~media} is displayed
     * @type {Element}
     */
    this.container = values.container || cache.config.localStreamContainer;
    /**
     * The local DOM media element where the {@link Local~media} is displayed
     * @type {Element}
     */
    this.node = null;
    /**
     * List of the PeerConnections associated to this local stream
     * @type {PeerConnection[]}
     */
    this.peerConnections = [];
    /**
     * Local stream status
     * @type {string}
     */
    this.status = NONE;
    /**
     * is the video is loaded int the local DOM media element
     * @type {boolean}
     */
    this.isVideoLoaded = false;
    /**
     * @access private
     * @type {{audio: string, video: string}}
     */
    this._inputs = {};

    // Set constraints
    this.constraints = values.constraints;

    /**
     * List of callbacks for Local
     * @type object
     * @private
     */
    this._callbacks = {};
  }


  /**
   * Register a callback for a specific event
   * @param {string} event The event name ({@link Events/Stream})
   * @param {function} callback The callback for the event
   */
  on(event, callback) {
    if (Events.local.supports(event)) {
      if (!this._callbacks[event]) {
        this._callbacks[event] = [];
      }
      this._callbacks[event].push(callback);
    }
  }

  /**
   * Register a callback for a specific event
   * @param {string} [event] The event name ({@link Events/Stream})
   * @param {function} [callback] The callback for the event
   */
  off(event, callback) {
    if (!event) {
      this._callbacks = {};
    } else if (Events.local.supports(event)) {
      if (!callback) {
        this._callbacks[event] = [];
      } else {
        this._callbacks[event] = this._callbacks[event].filter(cb =&gt; cb !== callback);
      }
    }
  }

  /**
   * The Media Constraints. (defaults to global config)
   * @param {MediaConstraints} constraints
   */
  set constraints(constraints) {
    const
      values = constraints || cache.config.constraints;


    const defaultConstraints = Media.constraints();
    [&apos;audio&apos;, &apos;video&apos;].forEach((type) =&gt; {
      if (!~this.type.indexOf(type)) { // eslint-disable-line no-bitwise
        values[type] = false;
      } else if (!values[type]) {
        values[type] = defaultConstraints[type];
      }
      if (values[type].deviceId || values[type].facingMode) {
        this._inputs[type] = _getConstraintValue(
          values[type],
          values[type].facingMode ? &apos;facingMode&apos; : &apos;deviceId&apos;
        );
      }
    });
    Log.d(&apos;Local~set#contraints&apos;, values);
    /**
     * @ignore
     */
    this._constraints = values;
  }

  /**
   * The Media Constraints. (defaults to global config)
   * @type {MediaConstraints}
   */
  get constraints() {
    return this._constraints;
  }

  /**
   * Updates the stream constraints and retrieve the new MediaStream
   * @param constraints
   * @returns {*|Promise.&lt;TResult&gt;}
   */
  updateConstraints(constraints) {
    Log.d(&apos;Local~updateConstraints&apos;, constraints);
    this.constraints = constraints;
    return navigator.mediaDevices.getUserMedia(this.constraints)
      .catch((e) =&gt; {
        (this._callbacks[Events.local.WEBRTC_ERROR] || [])
          .forEach(cb =&gt; cb(e));
        return e;
      })
      .then((media) =&gt; {
        [&apos;audio&apos;, &apos;video&apos;].forEach((kind) =&gt; {
          const constraintsValue = this.constraints[kind];
          if (constraintsValue) {
            if (constraintsValue.deviceId || constraintsValue.facingMode) {
              this._inputs[kind] = _getConstraintValue(
                constraintsValue,
                constraintsValue.facingMode ? &apos;facingMode&apos; : &apos;deviceId&apos;
              );
            }
          }
        });
        this.media = media;
      });
  }

  /**
   * The associated MediaStream
   * @type {MediaStream}
   */
  set media(mediaStream) {
    if (mediaStream) {
      if (!(mediaStream instanceof MediaStream)) {
        throw new Error(&apos;The media MUST be a MediaStream&apos;);
      }

      const checkDevices = {};
      mediaStream.getTracks().forEach((track) =&gt; {
        // Reset mute
        track.enabled = !this.muted[track.kind]; // eslint-disable-line no-param-reassign
        // Get device label
        if (!this._inputs[track.kind]) {
          checkDevices[track.kind] = track.label;
        }
      });
      // Try to get deviceId from label
      if (Object.keys(checkDevices).length) {
        Media.devices().then((devices) =&gt; {
          Object.keys(checkDevices).forEach((kind) =&gt; {
            if (devices[`${kind}input`]) {
              const deviceIds = devices[`${kind}input`]
                .filter(device =&gt; device.label.length &amp;&amp; device.label === checkDevices[kind]);
              if (deviceIds.length === 1 &amp;&amp; !this._inputs[kind]) {
                this._inputs[kind] = deviceIds[0].deviceId;
              }
              if (deviceIds.length === 0
                &amp;&amp; devices[`${kind}input`][0].label === &apos;&apos;
                &amp;&amp; !this._inputs[kind]) {
                // from a webview, the label is not delivered
                this._inputs[kind] = devices[`${kind}input`][0].deviceId;
              }
            }
          });
        });
      }
      // Display
      this.node = Media.attachStream(mediaStream, this.container, this.node, 0);
      this.node.onloadeddata = () =&gt; {
        this.isVideoLoaded = true;
      };
      this.status = CONNECTED;
      Log.d(&apos;Local~set media&apos;, { mediaStream }, this.node);
      // Renegotiate
      this.peerConnections.forEach(peerConnection =&gt; peerConnection.renegotiate(this._media,
        mediaStream));
    } else if (this.media &amp;&amp; !mediaStream) {
      // Remove node
      this.node.srcObject = null;
      this.container.removeChild(this.node);
      this.node = null;
      // Stop stream
      this.media.getTracks().forEach(track =&gt; track.stop());
      // Close PeerConnections
      this.peerConnections.forEach(peerConnection =&gt; peerConnection.close());
    }
    // Save
    /**
     * @ignore
     */
    this._media = mediaStream;
  }

  /**
   * The associated MediaStream
   * @type {MediaStream}
   */
  get media() {
    return this._media;
  }

  /**
   * Mute a track of a Stream
   * @param {string} [track=AUDIO] The track to mute. (AUDIO, VIDEO, AUDIO_VIDEO)
   * @param {boolean} [state=true] true for mute &amp; false for un-mute
   * @example &lt;caption&gt;mute video&lt;/caption&gt;
   * stream.mute(Reach.t.VIDEO)
   * @example &lt;caption&gt;mute audio&lt;/caption&gt;
   * stream.mute(Reach.t.AUDIO)
   * // or
   * stream.mute()
   */
  mute(track = StreamTypes.AUDIO, state = true) {
    Log.d(&apos;mute&apos;, track, state);
    let { audio, video } = this.muted;
    let
      tracks;
    switch (track) {
      case StreamTypes.AUDIO:
        audio = state;
        tracks = this.media.getAudioTracks();
        break;
      case StreamTypes.VIDEO:
      case StreamTypes.SCREEN_SHARING:
        video = state;
        tracks = this.media.getVideoTracks();
        break;
      case StreamTypes.AUDIO_VIDEO:
        audio = state;
        video = state;
        tracks = this.media.getTracks();
        break;
      default:
        break;
    }
    // Mute media tracks
    tracks.forEach((track) =&gt; { // eslint-disable-line no-shadow
      track.enabled = !state; // eslint-disable-line no-param-reassign
    });
    // Signal subscribers
    this.muted = { audio, video };
    DataSync.set(`_/rooms/${this.roomId}/streams/${this.uid}/muted`, this.muted);
  }

  /**
   * Un-mute a track of a Stream
   * @param {string} [track=AUDIO] The track to mute. (AUDIO, VIDEO, AUDIO_VIDEO)
   * @example &lt;caption&gt;Un-mute video&lt;/caption&gt;
   * stream.unMute(Reach.t.VIDEO)
   * @example &lt;caption&gt;Un-mute audio&lt;/caption&gt;
   * stream.unMute(Reach.t.AUDIO)
   * // or
   * stream.unMute()
   */
  unMute(track) {
    this.mute(track, false);
  }

  /**
   * Removes stream for published list, closes associated
   * PeerConnections and stops current MediaStream
   * @returns {Promise}
   */
  close() {
    if (!~[CLOSED, CLOSING].indexOf(this.status)) { // eslint-disable-line no-bitwise
      this.status = CLOSING;
      // Stop listening to Subscribers
      const path = `_/rooms/${this.roomId}/subscribers/${this.uid}`;
      DataSync.off(path, &apos;child_added&apos;);
      DataSync.off(path, &apos;child_removed&apos;);
      // Cancel onDisconnects
      DataSync.onDisconnect(`_/rooms/${this.roomId}/streams/${this.uid}`).cancel();
      DataSync.onDisconnect(`_/rooms/${this.roomId}/subscribers/${this.uid}`).cancel();
      // Remove subscribers
      DataSync.remove(path);
      // Remove stream
      DataSync.remove(`_/rooms/${this.roomId}/streams/${this.uid}`);
      this.media = null;
      // Close
      this.status = CLOSED;
    }
    return Promise.resolve(this.status);
  }

  /**
   * Switch video input device
   * @param {string} [deviceId] A video input device Id or the `facingMode` value
   * @returns {Promise&lt;Local, Error&gt;}
   */
  switchCamera(deviceId) {
    return this._switchDevice(StreamTypes.VIDEO, deviceId);
  }

  /**
   * Switch audio input device
   * @param {string} [deviceId] A audio input device Id
   * @returns {Promise&lt;Local, Error&gt;}
   */
  switchMicrophone(deviceId) {
    return this._switchDevice(StreamTypes.AUDIO, deviceId);
  }

  /**
   * Switch input device
   * @access private
   * @param {string} kind The kind of device to switch
   * @param {string} [deviceId] An input device id
   * @returns {Promise&lt;Local, Error&gt;}
   */
  _switchDevice(kind, deviceId) {
    Log.d(&apos;Local~_switchDevice&apos;, kind, deviceId);
    if (this.media.getTracks().some(track =&gt; track.kind === kind)) {
      let next = Promise.resolve(deviceId);
      const currentModeIdx = _facingModes.indexOf(this._inputs[kind]);
      if (!deviceId &amp;&amp; !!~currentModeIdx) { // eslint-disable-line no-bitwise
        // Loop facingModes
        next = Promise.resolve(_facingModes[(currentModeIdx + 1) % _facingModes.length]);
      } else if (!~_facingModes.indexOf(deviceId)) { // eslint-disable-line no-bitwise
        // Loop deviceIds
        next = Media.devices()
          .then((d) =&gt; {
            // devices IDs
            const devices = d[`${kind}input`].map(mediaDevice =&gt; mediaDevice.deviceId);
            // Sort to ensure same order
            devices.sort();
            // New device
            let nextDevice = deviceId;
            if (deviceId &amp;&amp; !devices.some(device =&gt; device === deviceId)) {
              return Promise.reject(new Error(`Unknown ${kind} device`));
            }
            if (!deviceId &amp;&amp; devices.length &gt; 1) {
              let idx = this._inputs[kind]
                ? devices.findIndex(v =&gt; v === this._inputs[kind], this)
                : 0;
              nextDevice = devices[++idx % devices.length]; // eslint-disable-line no-plusplus
            }
            return nextDevice;
          });
      } else {
        next = Promise.resolve(deviceId);
      }

      return next
        .then((device) =&gt; { // eslint-disable-line consistent-return
          if (this._inputs[kind] !== device) {
            // Update video streams
            this._inputs[kind] = device;
            // Stop tracks
            this.media.getTracks().forEach(track =&gt; track.stop());
            // Update constraints
            const constraints = Object.assign({}, this.constraints);
            let props = [&apos;facingMode&apos;, &apos;deviceId&apos;];
            if (!~_facingModes.indexOf(device)) { // eslint-disable-line no-bitwise
              props = props.reverse();
            }
            _setConstrainValue(constraints[kind], props[0], props[1], device);
            Log.d(&apos;Local~_switchDevice&apos;, kind, constraints);
            return this.updateConstraints(constraints);
          }
        })
        .then(() =&gt; this);
    }
    return Promise.reject(new Error(`Current stream does not contain a ${kind} track`));
  }

  /**
   * Publish a local stream
   * @access protected
   * @param {string} roomId The room Id
   * @param {string} type The stream type, see {@link StreamTypes} for possible values
   * @param {?Element} container The element the stream is attached to.
   * @param {?MediaStreamConstraints} [constraints] The stream constraints.
   * If not defined the constraints defined in ReachConfig will be used.
   * @returns {Promise&lt;Local, Error&gt;}
   */
  /* static share(roomId, type, container, constraints) {
    if (!cache.user) {
      return Promise.reject(new Error(&apos;Only an authenticated user can share a stream.&apos;));
    }
    const streamMetaData = {
      from: cache.user.uid,
      device: cache.device,
      type
    };


    const sharedStream = new Local(Object.assign({ roomId, constraints, container },
      streamMetaData));
    Log.d(&apos;Local~share&apos;, { sharedStream });
    return navigator.mediaDevices.getUserMedia(sharedStream.constraints)
      .then((media) =&gt; {
        sharedStream.media = media;
      })
      // Got MediaStream, publish it
      .then(() =&gt; DataSync.push(`_/rooms/${roomId}/streams`, streamMetaData))
      .then((streamRef) =&gt; {
        sharedStream.uid = streamRef.name();
        if (/video/i.test(sharedStream.type)) {
          if (sharedStream.isVideoLoaded) {
            const streamSize = {
              height: sharedStream.node.videoHeight,
              width: sharedStream.node.videoWidth,
            };
            streamRef.update(streamSize);
          } else {
            sharedStream.node.onloadeddata = function () { // eslint-disable-line func-names
              const streamSize = {
                height: sharedStream.node.videoHeight,
                width: sharedStream.node.videoWidth,
              };
              streamRef.update(streamSize);
            };
          }
        }
        if (/video/i.test(sharedStream.type)) {
          window.addEventListener(&apos;resize&apos;, (() =&gt; {
            if (sharedStream.node != null) {
              const streamSize = {
                height: sharedStream.node.videoHeight,
                width: sharedStream.node.videoWidth,
              };
              streamRef.update(streamSize);
            }
          }));
        }
        // Save sharedStream
        cache.streams.shared[sharedStream.uid] = sharedStream;
        // Remove shared stream on Disconnect
        DataSync.onDisconnect(`_/rooms/${roomId}/streams/${sharedStream.uid}`).remove();
        // Remove shared stream on Disconnect
        DataSync.onDisconnect(`_/rooms/${roomId}/subscribers/${sharedStream.uid}`).remove();
        // Start listening to subscribers
        const
          path = `_/rooms/${sharedStream.roomId}/subscribers/${sharedStream.uid}`;


        const value = snapData =&gt; Object.assign({ device: snapData.name() }, snapData.val() || {});
        DataSync.on(path, &apos;child_added&apos;,
          (snapData) =&gt; {
            const subscriber = value(snapData);
            Log.d(&apos;Local~subscribed&apos;, subscriber);
            cache.peerConnections.offer(sharedStream, subscriber)
              .then((pc) =&gt; {
                (this._callbacks[Events.local.SUBSCRIBED] || [])
                  .forEach(cb =&gt; cb(sharedStream, subscriber));
                return sharedStream.peerConnections.push(pc);
              });
          },
          Log.e.bind(Log));
        DataSync.on(path, &apos;child_removed&apos;,
          (snapData) =&gt; {
            const subscriber = value(snapData);
            Log.d(&apos;Local~un-subscribed&apos;, subscriber);
            const closedPC = cache.peerConnections.close(sharedStream.uid, subscriber.device);
            sharedStream.peerConnections = sharedStream.peerConnections
              .filter(pc =&gt; pc !== closedPC);
          },
          Log.e.bind(Log));
        Log.d(&apos;Local~shared&apos;, { sharedStream });
        return sharedStream;
      });
  } */

  /**
   * Get a local stream
   * @access protected
   * @param {string} roomId The room Id
   * @param {string} type The stream type, see {@link StreamTypes} for possible values
   * @param {?Element} container The element the stream is attached to.
   * @param {?MediaStreamConstraints} [constraints] The stream constraints.
   * If not defined the constraints defined in ReachConfig will be used.
   * @returns {Promise&lt;Local, Error&gt;}
   */
  static getLocalVideo(roomId, type, container, constraints) {
    if (!cache.user) {
      return Promise.reject(new Error(&apos;Only an authenticated user can share a stream.&apos;));
    }
    const streamMetaData = {
      from: cache.user.uid,
      device: cache.device,
      userAgent: cache.userAgent,
      type
    };


    const sharedStream = new Local(Object.assign({ roomId, constraints, container },
      streamMetaData));
    sharedStream.streamMetaData = streamMetaData;
    Log.d(&apos;Local~getLocalVideo&apos;, { sharedStream });
    return navigator.mediaDevices.getUserMedia(sharedStream.constraints)
      .then((media) =&gt; {
        sharedStream.media = media;
        return sharedStream;
      });
  }

  /**
   * Publish a local stream
   * @access protected
   * @returns {Local}
   */
  publish(sharedStream) {
    Log.d(&apos;Local~publish&apos;);
    const { roomId } = sharedStream;
    return DataSync.push(`_/rooms/${roomId}/streams`, sharedStream.streamMetaData)
      .then((streamRef) =&gt; {
        sharedStream.uid = streamRef.name(); // eslint-disable-line no-param-reassign
        if (sharedStream.isVideoLoaded) {
          const streamSize = {
            height: sharedStream.node.videoHeight,
            width: sharedStream.node.videoWidth,
          };
          streamRef.update(streamSize);
        } else {
          sharedStream.node.onloadeddata = function () { // eslint-disable-line
            const streamSize = {
              height: sharedStream.node.videoHeight,
              width: sharedStream.node.videoWidth,
            };
            streamRef.update(streamSize);
          };
        }
        window.addEventListener(&apos;resize&apos;, (() =&gt; {
          if (sharedStream.node != null) {
            const streamSize = {
              height: sharedStream.node.videoHeight,
              width: sharedStream.node.videoWidth,
            };
            streamRef.update(streamSize);
          }
        }));
        // Save sharedStream
        cache.streams.shared[sharedStream.uid] = sharedStream;
        // Remove shared stream on Disconnect
        DataSync.onDisconnect(`_/rooms/${roomId}/streams/${sharedStream.uid}`).remove();
        // Remove shared stream on Disconnect
        DataSync.onDisconnect(`_/rooms/${roomId}/subscribers/${sharedStream.uid}`).remove();
        // Start listening to subscribers
        const path = `_/rooms/${sharedStream.roomId}/subscribers/${sharedStream.uid}`;
        const value = snapData =&gt; Object.assign({ device: snapData.name() }, snapData.val() || {});

        DataSync.on(path, &apos;child_added&apos;,
          (snapData) =&gt; {
            const subscriber = value(snapData);
            Log.d(&apos;Local~subscribed&apos;, subscriber);
            cache.peerConnections
              .offer(sharedStream, subscriber, this._callbacks[Events.local.WEBRTC_ERROR])
              .then((pc) =&gt; {
                (this._callbacks[Events.local.SUBSCRIBED] || [])
                  .forEach(cb =&gt; cb(sharedStream, subscriber));
                return sharedStream.peerConnections.push(pc);
              });
          },
          Log.e.bind(Log), this);
        DataSync.on(path, &apos;child_removed&apos;,
          (snapData) =&gt; {
            const subscriber = value(snapData);
            Log.d(&apos;Local~un-subscribed&apos;, subscriber);
            const closedPC = cache.peerConnections.close(sharedStream.uid, subscriber.device);
            /* eslint-disable no-param-reassign */
            sharedStream.peerConnections = sharedStream.peerConnections
              .filter(pc =&gt; pc !== closedPC);
            /* eslint-enable no-param-reassign */
          },
          Log.e.bind(Log));
        Log.d(&apos;Local~shared&apos;, { sharedStream });
        return sharedStream;
      });
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
