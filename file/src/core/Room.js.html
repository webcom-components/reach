<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/core/Room.js | Reach</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Webcom-reach"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Reach"><meta property="twitter:description" content="Webcom-reach"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/webcom-components/reach"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reach.js~Reach.html">Reach</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core">core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Config.js~Config.html">Config</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Invite.js~Invite.html">Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Message.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Participant.js~Participant.html">Participant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Room.js~Room.html">Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/User.js~User.html">User</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-stream">core/stream</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Local.js~Local.html">Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Remote.js~Remote.html">Remote</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-util">core/util</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/util/Media.js~Media.html">Media</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core-webrtc">core/webrtc</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/webrtc/PeerConnection.js~PeerConnection.html">PeerConnection</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#definitions">definitions</a><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Browser">Browser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/audio">Codec/audio</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/video">Codec/video</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CommunicationQuality/bitrate">CommunicationQuality/bitrate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Invite">Events/Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Local">Events/Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Reach">Events/Reach</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Room">Events/Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Stream">Events/Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ICEServer">ICEServer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StreamTypes">StreamTypes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-datasync">external/datasync</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/Webcom.html">Webcom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/api.Query.html#~cancelCallback">Webcom/api.Query~cancelCallback</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-dom">external/dom</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element">Element</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#external-webrtc">external/webrtc</a><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://w3c.github.io/mediacapture-main/#idl-def-MediaDeviceInfo">MediaDeviceInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#stream-api">MediaStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints">MediaStreamConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints">MediaTrackConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#interface-definition">RTCPeerConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcrtpsender-interface">RTCRtpSender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcsessiondescription-class">RTCSessionDescription</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/core/Room.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {
  CANCELED,
  CLOSED,
  CONNECTED,
  NONE,
  NOT_CONNECTED,
  OPENED,
  OWNER,
  REJECTED,
  WAS_CONNECTED
} from &apos;./util/constants&apos;;
import * as DataSync from &apos;./util/DataSync&apos;;
import cache from &apos;./util/cache&apos;;
import Participant from &apos;./Participant&apos;;
import Message from &apos;./Message&apos;;
import Local from &apos;./stream/Local&apos;;
import Invite from &apos;./Invite&apos;;
import * as Events from &apos;../definitions/Events&apos;;
import * as Log from &apos;./util/Log&apos;;

const _joinRoom = (room, role) =&gt; {
  const uid = cache.user.uid.split(&apos;/&apos;).join(&apos;:&apos;);

  if (room.status !== CLOSED) {
    const participant = {
      status: CONNECTED,
      userAgent: cache.userAgent,
      _joined: DataSync.ts()
    };
    if (role) {
      participant.role = role;
    }
    Log.w(&apos;Room#join&apos;, [participant, `_/rooms/${room.uid}/participants/${uid}`]);
    return DataSync
      .update(`_/rooms/${room.uid}/participants/${uid}`, participant)
      .then(() =&gt; {
        DataSync
          .onDisconnect(`_/rooms/${room.uid}/participants/${uid}/status`)
          .set(WAS_CONNECTED);
        return room;
      });
  }
  return Promise.reject(new Error(&apos;can\&apos;t join a close room&apos;));
};

/**
 * Room information
 * @access public
 */
export default class Room {
  /**
   * Create a room
   * @param {Webcom/api.DataSnapshot|Object} snapData The data snapshot
   * @access protected
   */
  constructor(snapData, roomUid) {
    let values = snapData;
    if (snapData &amp;&amp; snapData.val &amp;&amp; typeof snapData.val === &apos;function&apos;) {
      // values = Object.assign({}, snapData.val(), {uid: snapData.name()});
      values = Object.assign({}, snapData.val(), { uid: roomUid });
    }
    /**
     * The room unique id
     * @type {string}
     */
    this.uid = values.uid;
    /**
     * The room name
     * @type {string}
     */
    this.name = values.name;
    /**
     * The local stream of the room
     * @type {Local}
     */
    this.localStream = {};
    /**
     * The room owner uid
     * @type {string}
     */
    this.owner = values.owner;
    /**
     * The room status:
     * - OPENED
     * - CLOSED
     * @type {string}
     */
    this.status = values.status;

    /**
     * Indicates that the room is public so all users can join
     * @type {boolean}
     */
    this._public = !!values._public;

    /**
     * Additional room informations
     * @type {Object}
     */
    this.extra = values.extra;

    /**
     * List of declared callbacks
     * @type {Object}
     */
    this._callbacks = {};
  }

  /**
   * Get the list of participants.
   * This will only work if the user is either a participant or the owner of the room.
   * @returns {Promise&lt;Participant[], Error&gt;}
   */
  participants() {
    return DataSync.list(`_/rooms/${this.uid}/participants`, Participant, this.uid);
  }

  /**
   * Get the list of messages.
   * This will only work if the user is either a participant or the owner of the room.
   * @return {Promise&lt;Message[], Error&gt;}
   */
  messages() {
    return DataSync.list(`_/rooms/${this.uid}/messages`, Message, this.uid);
  }

  /**
   * Get the list of streams
   * @returns {Promise}
   * @access private
   */
  _streams(localStreams) {
    if (!cache.user) {
      return Promise.reject(new Error(&apos;Only an authenticated user can list a Room\&apos;s streams.&apos;));
    }
    return DataSync.get(`_/rooms/${this.uid}/streams`)
      .then((snapData) =&gt; {
        const values = snapData.val();
        Log.d(&apos;Rooms~_streams&apos;, values);
        if (values) {
          return Object.keys(values).map(key =&gt; Object.assign({
            uid: key,
            roomId: this.uid
          }, values[key]));
        }
        return [];
      })
      .then(streams =&gt; streams.filter(stream =&gt; (
        localStreams === (stream.device === cache.device &amp;&amp; stream.from === cache.user.uid))))
      .then(streams =&gt; streams.map(cache.streams[`get${localStreams ? &apos;Shared&apos; : &apos;Remote&apos;}`].bind(cache.streams)))
      .then(streams =&gt; streams.filter(stream =&gt; stream !== null));
  }

  /**
   * Get the list of locally published streams.
   * The streams published with another device won&apos;t be visible here
   * This will only work if the user is either a participant or the owner of the room.
   * @return {Promise&lt;Local[], Error&gt;}
   */
  localStreams() {
    return this._streams(true)
      .catch(Log.r(&apos;Room~localStreams&apos;));
  }

  /**
   * Get the list of remotely published streams.
   * This will only work if the user is either a participant or the owner of the room.
   * @return {Promise&lt;Remote[], Error&gt;}
   */
  remoteStreams() {
    return this._streams(false)
      .catch(Log.r(&apos;Room~remoteStreams&apos;));
  }

  /**
   * Invite users to the room.
   * This will only work if the current User is the owner or a moderator of this Room.
   * This will create the invitation and add the user to the participants list.
   * @param {User[]} users the users to invite
   * @param {string} [role=&apos;NONE&apos;] the role of the invitee
   * @param {string} [message] a message to add to the invite
   * @return {Promise&lt;{room: Room, invites: Invite[]}, Error&gt;}
   */
  invite(users, role = NONE, message) {
    const _path = user =&gt; `_/rooms/${this.uid}/participants/${user.uid}`;
    const _data = {
      status: NOT_CONNECTED,
      role: role || NONE
    };
    // Add users as participant so they can join the room
    return Promise.all(users.map(user =&gt; DataSync.set(_path(user), _data)))
    // Send invites
      .then(() =&gt; Promise.all(users.map(user =&gt; Invite.send(user, this, message))))
      .then((invites) =&gt; {
        const removeParticipant = invite =&gt; DataSync.remove(`_/rooms/${invite.room}/participants/${invite.to}`);
        invites.forEach((invite) =&gt; {
          invite.on(REJECTED, removeParticipant);
          invite.on(CANCELED, removeParticipant);
        });
        return { room: this, invites };
      })
      .catch((e) =&gt; {
        Log.e(&apos;Room~invite&apos;, e);
        users.forEach(user =&gt; DataSync.remove(`_/rooms/${this.uid}/participants/${user.uid}`));
        return Promise.reject(e);
      });
  }

  /**
   * Register a callback for a specific event
   * @param {string} event The event name ({@link Events/Room}):
   * - PARTICIPANT_ADDED: a participant is added to the room
   * - PARTICIPANT_CHANGED: a participant changes his status (join)
   * - PARTICIPANT_REMOVED: a participant leave the room
   * - MESSAGE_ADDED: new instant message
   * - MESSAGE_CHANGED: an existing message has been modified (moderation)
   * - MESSAGE_REMOVED: a message has been removed (moderation)
   * - STREAM_PUBLISHED: a participant published a new Stream
   * - STREAM_CHANGED: a participant changes his published Stream (moderation, type, mute...)
   * - STREAM_UNPUBLISHED: a participant stops the publication of his Stream
   * @param {function} callback
   * The callback for the event, the arguments depends on the type of event:
   * - PARTICIPANT_* : callback({@link Participant} p [, Error e])
   * - MESSAGE_* : callback({@link Message} m [, Error e])
   * - STREAM_* : callback({@link Remote} s [, Error e])
   * @param {Webcom/api.Query~cancelCallback} cancelCallback The error callback for the event,
   * takes an Error as only argument
   */
  on(event, callback, cancelCallback) {
    const
      path = Events.room.toPath(event)(this);


    const Obj = Events.room.toClass(event);
    if (path &amp;&amp; Obj) {
      const typedCallback = (snapData) =&gt; {
        if (!/^STREAM_/i.test(event) || !snapData) {
          // if(/^MESSAGE_/i.test(event) || !snapData) {
          Log.i(`Room~on(${event})`, snapData ? new Obj(snapData) : null);
          callback(snapData ? new Obj(snapData) : null);
        } else if (cache.user) {
          const streamData = Object.assign({
            uid: snapData.name(),
            roomId: this.uid
          }, snapData.val());
          if (streamData.from !== cache.user.uid || streamData.device !== cache.device) {
            const remoteStream = cache.streams.getRemote(streamData);
            Log.i(`Room~on(${event})`, remoteStream);
            callback(remoteStream);
          }
        }
      };
      DataSync.on(path, event, typedCallback, cancelCallback);
      if (!this._callbacks[event]) {
        this._callbacks[event] = [];
      }
      this._callbacks[event].push(typedCallback);
    }
  }

  /**
   * Send an instant message
   * @param {string} message The message to send
   * @return {Promise&lt;Message&gt;}
   */
  sendMessage(message) {
    return Message.send(this, message);
  }

  /**
   * Publish a local stream
   * @param {string} type The stream type, see {@link StreamTypes} for possible values
   * @param {Element} [localStreamContainer] The element the stream is attached to.
   * Can be null if already specified in {@link Config}.
   * @param {MediaStreamConstraints} [constraints] The stream constraints.
   * If not defined, the constraints defined in {@link Config} will be used.
   * @returns {Promise&lt;Local, Error&gt;}
   */
  share(type, localStreamContainer, constraints) {
    Log.i(&apos;Room~share&apos;, { type, localStreamContainer, constraints });
    // return Local.share(this.uid, type, localStreamContainer, constraints);
    return Local.getLocalVideo(this.uid, type, localStreamContainer, constraints)
      .then(stream =&gt; stream.publish(stream));
  }

  /**
   * get a local stream in video tag
   * @param {string} type The stream type, see {@link StreamTypes} for possible values
   * @param {Element} [localStreamContainer] The element the stream is attached to.
   * Can be null if already specified in {@link Config}.
   * @param {MediaStreamConstraints} [constraints] The stream constraints.
   * If not defined, the constraints defined in {@link Config} will be used.
   * @returns {Promise&lt;Local, Error&gt;}
   */
  getLocalVideo(type, localStreamContainer, constraints) {
    Log.i(&apos;Room~getLocalVideo&apos;, { type, localStreamContainer, constraints });
    return Local.getLocalVideo(this.uid, type, localStreamContainer, constraints)
      .then((localStream) =&gt; {
        this.localStream = localStream;
        return localStream;
      });
  }

  /**
   * publish a local stream
   * @returns {Local}
   */
  publish() {
    Log.i(&apos;Room~publish Local&apos;);
    return this.localStream.publish(this.localStream);
  }

  /**
   * Join the room. Sets the connected status of the current participant to CONNECTED.
   * @return {Promise}
   */
  join() {
    Log.i(&apos;Room~join&apos;, this);
    if (!cache.user) {
      return Promise.reject(new Error(&apos;Only an authenticated user can join a Room.&apos;));
    }
    return _joinRoom(this).catch(Log.r(&apos;Room~join&apos;));
  }

  /**
   * Leave the room. Sets the connected status of the current participant to WAS_CONNECTED,
   * deletes medias and callbacks, closes WebRTC stacks in use.
   * @return {Promise}
   */
  leave() {
    if (!cache.user) {
      return Promise.reject(new Error(&apos;Only an authenticated user can leave a Room.&apos;));
    }
    Log.i(&apos;Room~leave&apos;, this);
    // Cancel onDisconnect
    const uid = cache.user.uid.split(&apos;/&apos;).join(&apos;:&apos;);
    DataSync.onDisconnect(`_/rooms/${this.uid}/participants/${uid}/status`).cancel();

    // Disconnect user&apos;s callbacks
    Object.keys(this._callbacks).forEach((event) =&gt; {
      DataSync.off(Events.room.toPath(event)(this), event);
    });
    // Unpublish all published local streams
    this.localStreams()
      .then(localStreams =&gt; localStreams.forEach(localStream =&gt; localStream.close()));
    // Unsubscribe all remote streams
    this.remoteStreams()
      .then(remoteStreams =&gt; remoteStreams.forEach(remoteStream =&gt; remoteStream.unSubscribe()));
    // Update status
    return DataSync.set(`_/rooms/${this.uid}/participants/${uid}/status`, WAS_CONNECTED)
    // return DataSync.set(`_/rooms/${this.uid}/participants/${shortUserId}/status`, WAS_CONNECTED)
      .catch(Log.r(&apos;Room~leave&apos;));
  }

  /**
   * Leaves &amp; close the Room. Only the owner/moderator can close a room.
   * @return {Promise}
   */
  close() {
    Log.i(&apos;Room~close&apos;, this);
    this.status = CLOSED;
    return this.leave()
      .then(() =&gt; DataSync.update(`rooms/${this.uid}`, { status: CLOSED, _closed: DataSync.ts() }))
      .then(() =&gt; DataSync.remove(`_/rooms/${this.uid}`))
      .catch(Log.r(&apos;Room~close&apos;));
  }

  /**
   * Create a room
   * @access protected
   * @param {String} [name] The room name
   * @param {object} [extra=null] Extra informations
   * @param {boolean} [publicRoom=false] Indicates public room
   * @returns {Promise&lt;Room, Error&gt;}
   */
  static create(name, extra = null, publicRoom = false) {
    if (!cache.user) {
      return Promise.reject(new Error(&apos;Only an authenticated user can create a Room.&apos;));
    }

    const roomMetaData = {
      owner: cache.user.uid,
      _public: publicRoom,
      name: name || `${cache.user.name}-${Date.now()}`
    };
    const roomFullMetaData = Object.assign({
      status: OPENED,
      _created: DataSync.ts(),
      extra
    }, roomMetaData);

    let room = null;
    // Create public room infos
    // return DataSync.push(&apos;rooms&apos;, roomFullMetaData)
    const id1 = Math.floor(Math.random() * 1000);
    const id2 = Math.floor(Math.random() * 1000);
    return DataSync.push(`rooms/${id1}/${id2}`, roomFullMetaData)
    // Create private room infos
      .then((roomRef) =&gt; {
        room = new Room(Object.assign({ uid: `${id1}/${id2}/${roomRef.name()}` }, roomFullMetaData));
        cache.room = roomFullMetaData;
        return DataSync.update(`_/rooms/${room.uid}/meta`, roomMetaData);
      })
      // Join the room
      .then(() =&gt; _joinRoom(room, OWNER))
      .catch(Log.r(&apos;Room#create&apos;));
  }

  /**
   * Get a {@link Room} from its `uid`
   * @access protected
   * @param uid
   * @returns {Promise.&lt;Room&gt;}
   */
  static get(uid) {
    return DataSync.get(`rooms/${uid}`)
      .then((snapData) =&gt; {
        if (snapData.val()) {
          return new Room(snapData, uid);
        }
        return null;
      });
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
