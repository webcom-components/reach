[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/Reach.js",
    "content": "import Webcom from 'webcom/webcom';\nimport browser from './definitions/Browser';\nimport StreamTypes from './definitions/StreamTypes';\nimport * as Events from './definitions/Events';\nimport { audio, video } from './definitions/Codec';\nimport User from './core/User';\nimport Room from './core/Room';\nimport Invite from './core/Invite';\nimport * as DataSync from './core/util/DataSync';\nimport cache from './core/util/cache';\nimport * as Log from './core/util/Log';\nimport Media from './core/util/Media';\n\n/**\n * Entry point for Reach SDK\n * @public\n */\nexport default class Reach {\n  /**\n   * Create Reach's data structure where the url points to (might not be the root of your namespace)\n   * @public\n   * @param {string|Webcom} url The url of your namespace or an existing Webcom reference.\n   * @param {Config} [cfg] Reach configuration. You can pass constraints here\n   * @example <caption>Init with the default configuration</caption>\n   * var myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>');\n   * @example <caption>Init and set constraints for SD video and logLevel to 'info'</caption>\n   * var myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>', {\n   *  constraints: Reach.media.constraints('SD'),\n   *  logLevel: 'INFO'\n   * });\n   */\n  constructor(url, cfg = null) {\n    // Set shared reference\n    cache.base = url;\n    // Set shared configuration\n    cache.config = cfg;\n    /**\n     * List of declared callbacks\n     * @type {{}}\n     * @private\n     */\n    this._callbacks = {};\n  }\n\n  /**\n   * Get versions of SDK and DataModel.\n   * The Schema version can be used to determine compatibility with the Android & iOS SDK.\n   * @return {{sdk: string, schema: string}}\n   */\n  static get version() {\n    return { sdk: SDK_VERSION, schema: SCHEMA_VERSION }; // eslint-disable-line no-undef\n  }\n\n  /**\n   * The supported stream types\n   * @returns {StreamTypes}\n   */\n  static get types() {\n    return StreamTypes;\n  }\n\n  /**\n   * The supported events\n   * @return {{room: Events/Room, reach: Events/Reach, stream: Events/Stream}}\n   */\n  static get events() {\n    return {\n      room: Events.room, reach: Events.reach, stream: Events.stream, invite: Events.invite\n    };\n  }\n\n  /**\n   * The browser's details\n   * @return {Browser}\n   */\n  static get browser() {\n    return browser;\n  }\n\n  /**\n   * Media utility functions\n   * @return {Media}\n   */\n  static get media() {\n    return Media;\n  }\n\n  /**\n   * The codec presets to use when setting {@link Config#preferredAudioCodec}\n   * or {@link Config#preferredVideoCodec}\n   * @return {{audio: Codec/audio, video: Codec/video}}\n   */\n  static get codecs() {\n    return { audio, video };\n  }\n\n  /**\n   * DataSync reference\n   * @type {Webcom}\n   */\n  get base() {\n    return cache.base;\n  }\n\n  /**\n   * The configuration\n   * @type {Config}\n   */\n  get config() {\n    return cache.config;\n  }\n\n  /**\n   * The connected User\n   * @type {User}\n   */\n  get current() {\n    return cache.user;\n  }\n\n  /**\n   * Register & Sign-in as a new user\n   * @param {string} email The email of the user\n   * @param {string} password The password of the user\n   * @param {string} [name] The display name of the user (defaults to email)\n   * @param {boolean} [rememberMe=false] keep user connected ?\n   * @returns {Promise<User>}\n   */\n  register(email, password, name, rememberMe) {\n    return cache.base.createUser(email, password)\n      .then((auth) => {\n        if (auth) {\n          return this.login(email, password, name || email, rememberMe);\n        }\n        return null;\n      })\n      .catch(Log.r('Reach~register'));\n  }\n\n  /**\n   * Sign-in an existing user\n   * @param {string} email The email of the user\n   * @param {string} password The password of the user\n   * @param {string} [name] The name of the user. Defaults to the value in base.\n   * @param {boolean} [rememberMe=false] keep user connected ?\n   * @returns {Promise<User>}\n   */\n  login(email, password, name, rememberMe = false) {\n    // Force logout to bypass Webcom bug\n    let p = Promise.resolve();\n    if (this.current && this.current.email !== email) {\n      p = this.logout();\n    }\n    return p\n      .then(() => cache.base.authWithPassword({ email, password, rememberMe }))\n      .then(auth => User.init(auth, name))\n      .then((u) => {\n        cache.user = u;\n        return u;\n      })\n      .catch(Log.r('Reach~login'));\n  }\n\n  /**\n   * Resume previous session\n   * @returns {Promise<User>}\n   */\n  resume() {\n    return new Promise((resolve, reject) => {\n      // Resume session\n      if (Webcom.INTERNAL.PersistentStorage.get('session')) {\n        cache.base.resume((error, auth) => {\n          if (auth && !this.current) {\n            User.init(auth).then((u) => {\n              cache.user = u;\n              resolve(u);\n            }, reject);\n          }\n        });\n      } else {\n        reject(new Error('No session to resume'));\n      }\n    });\n  }\n\n  /**\n   * Sign-in an anonymous user\n   * @param {string} name The display name of the user\n   * @returns {Promise<User>}\n   */\n  anonymous(name) {\n    // Force logout to bypass Webcom bug\n    let p = Promise.resolve();\n    if (this.current && (!this.current.anonymous || this.current.name !== name)) {\n      p = this.logout();\n    }\n    return p\n      .then(() => cache.base.authAnonymously())\n      .then(auth => User.init(auth, name))\n      .then((u) => {\n        cache.user = u;\n        return u;\n      })\n      .catch(Log.r('Reach~anonymous'));\n  }\n\n  /**\n   * Logout current user\n   * @returns {Promise}\n   */\n  logout() {\n    return new Promise((resolve, reject) => {\n      let p = Promise.resolve();\n      if (this.current != null) {\n        p = User.disconnect(this.current);\n      }\n      p\n        .then(() => {\n          Object.keys(this._callbacks).forEach(\n            event => DataSync.off(Events.reach.toPath(event)(cache.user), event)\n          );\n          cache.base.logout(() => {\n            cache.user = null;\n            resolve();\n          });\n        })\n        .catch((e) => {\n          Log.e(e);\n          reject(e);\n        });\n    });\n  }\n\n  /**\n   * Get the list of registered users\n   * @ignore If your users base is pretty large, this method is impossible.\n   * @param {boolean} [include=false] Include current user in user's list\n   * @return {Promise<User[], Error>}\n   */\n  users(include) {\n    if (!this.current) {\n      return Promise.reject(new Error('Only an authenticated user can list Users.'));\n    }\n    return DataSync.list('users', User)\n      .then(users => (!include && users && this.current\n        ? users.filter(user => user.uid !== this.current.uid)\n        : users))\n      .catch(Log.r('Reach~users'));\n  }\n\n  /**\n   * Get the list of rooms\n   * @ignore If your users base is pretty large, this method is impossible.\n   * @return {Promise<Room[], Error>}\n   */\n\n  rooms() {\n    if (!this.current) {\n      return Promise.reject(new Error('Only an authenticated user can list Rooms.'));\n    }\n    return DataSync.list('rooms', Room)\n      .catch(Log.r('Reach~rooms'));\n  }\n\n  /**\n   * Get the list of invites\n   * @return {Promise<Invite[], Error>}\n   */\n  invites() {\n    if (!this.current) {\n      return Promise.reject(new Error('Cannot list invites without a User being logged in.'));\n    }\n    return DataSync.list(`_/invites/${this.current.uid}`, Invite)\n      .catch(Log.r('Reach~invites'));\n  }\n\n  /**\n   * Register a callback for a specific event\n   * @param {string} event The event name ({@link Events/Reach}). Can be:\n   * - USER_ADDED\n   * - USER_CHANGED\n   * - USER_REMOVED\n   * - ROOM_ADDED\n   * - ROOM_CHANGED\n   * - ROOM_REMOVED\n   * - INVITE_ADDED\n   * - INVITE_CHANGED\n   * @param {function} callback The callback for the event,\n   * the arguments depends on the type of event:\n   * - USER_*: callback({@link User} u)\n   * - ROOM_*: callback({@link Room} r)\n   * - INVITE_*: callback({@link Invite} i)\n   * @param {Webcom/api.Query~cancelCallback} [cancelCallback] The error callback for the event,\n   * takes an Error as only argument\n   */\n  on(event, callback, cancelCallback) {\n    const path = Events.reach.toPath(event)(cache.user);\n    if (path) {\n      const Cls = Events.reach.toClass(event);\n      const cb = (snapData) => {\n        const d = Cls ? new Cls(snapData) : null;\n        Log.i(`Reach~on(${event})`, d);\n        callback(d);\n      };\n      DataSync.on(path, event, cb, cancelCallback);\n      if (!this._callbacks[event]) {\n        this._callbacks[event] = [];\n      }\n      this._callbacks[event].push(cb);\n    }\n  }\n\n  /**\n   * Create a new room\n   * @param {string} [name] The room name\n   * @param {object} [extra] Extra informations\n   * @param {boolean} [publicRoom=false] Indicates public room\n   * @returns {Promise<Room>}\n   */\n  createRoom(name, extra, publicRoom = false) {\n    if (!this.current) {\n      return Promise.reject(new Error('Cannot create a Room without a User being logged in.'));\n    }\n    return Room.create(name, extra, publicRoom);\n  }\n\n  /**\n   * Get a list of all opened {@link PeerConnection}s\n   * @return {*}\n   */\n  get peerConnections() {\n    return cache.peerConnections.stacks;\n  }\n\n  /**\n   * Get a {@link Room} from its `uid`\n   * @param {string} uid The room's UID\n   * @returns {Promise.<Room>}\n   */\n  getRoom(uid) {\n    return Room.get(uid);\n  }\n\n  /**\n   * Get a {@link User} from its `uid`\n   * @param {string} uid The user's UID\n   * @returns {Promise.<User>}\n   */\n  getUser(uid) {\n    return User.get(uid);\n  }\n}\n\nmodule.exports = Reach;\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/Reach.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "Reach",
    "memberof": "src/Reach.js",
    "static": true,
    "longname": "src/Reach.js~Reach",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/Reach.js",
    "importStyle": "Reach",
    "description": "Entry point for Reach SDK",
    "lineNumber": 18,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#constructor",
    "access": "public",
    "description": "Create Reach's data structure where the url points to (might not be the root of your namespace)",
    "examples": [
      "<caption>Init with the default configuration</caption>\nvar myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>');",
      "<caption>Init and set constraints for SD video and logLevel to 'info'</caption>\nvar myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>', {\n constraints: Reach.media.constraints('SD'),\n logLevel: 'INFO'\n});"
    ],
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Webcom"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The url of your namespace or an existing Webcom reference."
      },
      {
        "nullable": null,
        "types": [
          "Config"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Reach configuration. You can pass constraints here"
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "_callbacks",
    "memberof": "src/Reach.js~Reach",
    "static": false,
    "longname": "src/Reach.js~Reach#_callbacks",
    "access": "private",
    "description": "List of declared callbacks",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "{}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "get",
    "name": "version",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Reach.js~Reach.version",
    "access": "public",
    "description": "Get versions of SDK and DataModel.\nThe Schema version can be used to determine compatibility with the Android & iOS SDK.",
    "lineNumber": 50,
    "return": {
      "nullable": null,
      "types": [
        "{sdk: string, schema: string}"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "{\"sdk\": *, \"schema\": *}"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "get",
    "name": "types",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Reach.js~Reach.types",
    "access": "public",
    "description": "The supported stream types",
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{StreamTypes}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "StreamTypes"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "get",
    "name": "events",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Reach.js~Reach.events",
    "access": "public",
    "description": "The supported events",
    "lineNumber": 66,
    "return": {
      "nullable": null,
      "types": [
        "{room: Events/Room, reach: Events/Reach, stream: Events/Stream}"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "{\"room\": *, \"reach\": *, \"stream\": *, \"invite\": *}"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "get",
    "name": "browser",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Reach.js~Reach.browser",
    "access": "public",
    "description": "The browser's details",
    "lineNumber": 76,
    "return": {
      "nullable": null,
      "types": [
        "Browser"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "get",
    "name": "media",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Reach.js~Reach.media",
    "access": "public",
    "description": "Media utility functions",
    "lineNumber": 84,
    "return": {
      "nullable": null,
      "types": [
        "Media"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "get",
    "name": "codecs",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Reach.js~Reach.codecs",
    "access": "public",
    "description": "The codec presets to use when setting {@link Config#preferredAudioCodec}\nor {@link Config#preferredVideoCodec}",
    "lineNumber": 93,
    "return": {
      "nullable": null,
      "types": [
        "{audio: Codec/audio, video: Codec/video}"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "{\"audio\": *, \"video\": *}"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "get",
    "name": "base",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#base",
    "access": "public",
    "description": "DataSync reference",
    "lineNumber": 101,
    "type": {
      "nullable": null,
      "types": [
        "Webcom"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 59,
    "kind": "get",
    "name": "config",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#config",
    "access": "public",
    "description": "The configuration",
    "lineNumber": 109,
    "type": {
      "nullable": null,
      "types": [
        "Config"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 60,
    "kind": "get",
    "name": "current",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#current",
    "access": "public",
    "description": "The connected User",
    "lineNumber": 117,
    "type": {
      "nullable": null,
      "types": [
        "User"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "register",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#register",
    "access": "public",
    "description": "Register & Sign-in as a new user",
    "lineNumber": 129,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<User>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": "The email of the user"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "The password of the user"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "name",
        "description": "The display name of the user (defaults to email)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "rememberMe",
        "description": "keep user connected ?"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<User>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "login",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#login",
    "access": "public",
    "description": "Sign-in an existing user",
    "lineNumber": 148,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<User>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": "The email of the user"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "The password of the user"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "name",
        "description": "The name of the user. Defaults to the value in base."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "rememberMe",
        "description": "keep user connected ?"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<User>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "resume",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#resume",
    "access": "public",
    "description": "Resume previous session",
    "lineNumber": 168,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<User>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<User>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "anonymous",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#anonymous",
    "access": "public",
    "description": "Sign-in an anonymous user",
    "lineNumber": 191,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<User>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The display name of the user"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<User>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "logout",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#logout",
    "access": "public",
    "description": "Logout current user",
    "lineNumber": 211,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "users",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#users",
    "access": "public",
    "description": "Get the list of registered users",
    "lineNumber": 240,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "include",
        "description": "Include current user in user's list"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<User[], Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "rooms",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#rooms",
    "access": "public",
    "description": "Get the list of rooms",
    "lineNumber": 257,
    "ignore": true,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Room[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "invites",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#invites",
    "access": "public",
    "description": "Get the list of invites",
    "lineNumber": 269,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Invite[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "on",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#on",
    "access": "public",
    "description": "Register a callback for a specific event",
    "lineNumber": 296,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event name ({@link Events/Reach}). Can be:\n- USER_ADDED\n- USER_CHANGED\n- USER_REMOVED\n- ROOM_ADDED\n- ROOM_CHANGED\n- ROOM_REMOVED\n- INVITE_ADDED\n- INVITE_CHANGED"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback for the event,\nthe arguments depends on the type of event:\n- USER_*: callback({@link User} u)\n- ROOM_*: callback({@link Room} r)\n- INVITE_*: callback({@link Invite} i)"
      },
      {
        "nullable": null,
        "types": [
          "Webcom/api.Query~cancelCallback"
        ],
        "spread": false,
        "optional": true,
        "name": "cancelCallback",
        "description": "The error callback for the event,\ntakes an Error as only argument"
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "createRoom",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#createRoom",
    "access": "public",
    "description": "Create a new room",
    "lineNumber": 320,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Room>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "name",
        "description": "The room name"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "extra",
        "description": "Extra informations"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "publicRoom",
        "description": "Indicates public room"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Room>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 71,
    "kind": "get",
    "name": "peerConnections",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#peerConnections",
    "access": "public",
    "description": "Get a list of all opened {@link PeerConnection}s",
    "lineNumber": 331,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "getRoom",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#getRoom",
    "access": "public",
    "description": "Get a {@link Room} from its `uid`",
    "lineNumber": 340,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Room>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uid",
        "description": "The room's UID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Room>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "getUser",
    "memberof": "src/Reach.js~Reach",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reach.js~Reach#getUser",
    "access": "public",
    "description": "Get a {@link User} from its `uid`",
    "lineNumber": 349,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uid",
        "description": "The user's UID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 74,
    "kind": "file",
    "name": "src/core/Config.js",
    "content": "import media from './util/Media';\nimport * as DataSync from './util/DataSync';\nimport * as Log from './util/Log';\nimport cache from './util/cache';\n\nconst _flattenServers = (servers) => {\n  const _expand = servers.map((server) => {\n    const {\n      username, credential, urls, url\n    } = server;\n    const uris = urls || url;\n    if (typeof uris !== 'string') {\n      return uris.map(uri => ({ username, credential, urls: uri }));\n    }\n    return [server];\n  });\n  return [].concat(..._expand);\n};\n\n/**\n * The Reach configuration object\n * @class Config\n */\nexport default class Config {\n  /**\n   * Create configuration\n   * @access protected\n   * @param obj\n   */\n  constructor(obj) {\n    /**\n     * The default media constraints. These can be overridden when subscribing to a stream.\n     * @type {MediaStreamConstraints}\n     */\n    this.constraints = null;\n\n    /**\n     * The id/element dom element that will hold the local video/audio element\n     * @type {string|Element}\n     */\n    this.localStreamContainer = null;\n    /**\n     * The id/element dom element that will hold the remote video/audio element\n     * @type {string|Element}\n     */\n    this.remoteStreamContainer = null;\n\n    /**\n     * The preferred video Codec. Takes a RegExp matching the codec name and sample rate.\n     * Predefined values can be found in {@link Codec/video}\n     * @type {RegExp}\n     * @example <caption>Prefer VP9</caption>\n     * var myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>', {\n     *  preferredVideoCodec: Reach.codecs.video.VP9\n     * });\n     */\n    this.preferredVideoCodec = null;\n\n    /**\n     * The preferred audio Codec. Takes a RegExp matching the codec name and sample rate.\n     * Predefined values can be found in {@link Codec/audio}\n     * @type {RegExp}\n     * @example <caption>Prefer opus</caption>\n     * var myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>', {\n     *  preferredAudioCodec: Reach.codecs.audio.OPUS\n     * });\n     */\n    this.preferredAudioCodec = null;\n\n    // Populate with default values\n    this.reset();\n\n    // Populate with data\n    this.assign(obj);\n\n    // Read ICE servers from server\n    DataSync.get('_/ice').then((snapData) => {\n      if (snapData) {\n        this.iceServers = snapData.val();\n        Log.i('ICEServers', this.iceServers.length > 0 ? this.iceServers : 'None');\n      }\n    }, e => Log.d('ICEServers', e));\n\n    // TODO #Feat: Add boolean prop to request permission on start,\n    // sdpEditor (for user defined SDP modifications)\n  }\n\n  /**\n   * Assign new conf values\n   * @access protected\n   * @param {object} obj the new conf values\n   */\n  assign(obj) {\n    Object.keys(obj || {}).forEach((key) => {\n      this[key] = obj[key];\n    });\n  }\n\n  /**\n   * The log level (DEBUG, INFO, WARN, ERROR)\n   * @type {string}\n   */\n  set logLevel(level) {\n    cache.logLevel = level;\n  }\n\n  /**\n   * The log level (DEBUG, INFO, WARN, ERROR)\n   * @returns {string}\n   */\n  get logLevel() {\n    return cache.logLevel;\n  }\n\n  /**\n   * List of TURN/STUN servers to use for ICE.\n   * This list will be merged with the ICE servers declared in the namespace (**_/ice**).\n   * @type {ICEServer[]}\n   */\n  set iceServers(servers) {\n    Log.d('Config~set~iceServers', servers);\n    if (servers) {\n      if (!this._iceServers) {\n        /**\n         * @ignore\n         */\n        this._iceServers = [].concat(servers || []);\n      } else {\n        // flatten existing\n        const _currentServers = _flattenServers(this._iceServers);\n        // flatten new\n        const _newServers = _flattenServers(servers);\n        // Add only the missing servers\n        _newServers.forEach((newServer) => {\n          if (!_currentServers.some(server => server.urls === newServer.urls\n            && server.username === newServer.username\n            && server.credential === newServer.credential)) {\n            _currentServers.push(newServer);\n          }\n        });\n        // Re-group by username/credential\n        this._iceServers = _currentServers.reduce((previous, current) => {\n          const { username, credential, urls } = current;\n          const idx = previous.findIndex(s => s.username === username\n            && s.credential === credential);\n          if (idx >= 0) {\n            previous[idx].urls.push(urls);\n          } else {\n            previous.push({ username, credential, urls: [urls] });\n          }\n          return previous;\n        }, []);\n      }\n    }\n  }\n\n  /**\n   * List of TURN/STUN servers to use for ICE.\n   * This list will be merged with the ICE servers declared in the namespace (**_/ice**).\n   * @type {ICEServer[]}\n   */\n  get iceServers() {\n    return this._iceServers || [\n      {\n        username: 'admin',\n        credential: 'webcom1234',\n        urls: [\n          'turns:turn1.webcom.orange.com:443',\n          'turn:turn1.webcom.orange.com:443?transport=tcp',\n          'turn:turn1.webcom.orange.com:3478?transport=tcp'\n        ]\n      }\n    ];\n  }\n\n  set stats(stats) {\n    this._stats = Object.assign({}, stats);\n  }\n\n  get stats() {\n    return this._stats || {};\n  }\n\n  /**\n   * Resets configuration to default values\n   * @protected\n   */\n  reset() {\n    this.assign({\n      constraints: media.constraints(),\n      logLevel: 'ERROR'\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/Config.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 75,
    "kind": "function",
    "name": "_flattenServers",
    "memberof": "src/core/Config.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Config.js~_flattenServers",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/Config.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "servers",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "class",
    "name": "Config",
    "memberof": "src/core/Config.js",
    "static": true,
    "longname": "src/core/Config.js~Config",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/Config.js",
    "importStyle": "Config",
    "description": "The Reach configuration object",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Config"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 77,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#constructor",
    "access": "protected",
    "description": "Create configuration",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "constraints",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#constraints",
    "access": "public",
    "description": "The default media constraints. These can be overridden when subscribing to a stream.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "MediaStreamConstraints"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "localStreamContainer",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#localStreamContainer",
    "access": "public",
    "description": "The id/element dom element that will hold the local video/audio element",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "string",
        "Element"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "remoteStreamContainer",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#remoteStreamContainer",
    "access": "public",
    "description": "The id/element dom element that will hold the remote video/audio element",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "string",
        "Element"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "preferredVideoCodec",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#preferredVideoCodec",
    "access": "public",
    "description": "The preferred video Codec. Takes a RegExp matching the codec name and sample rate.\nPredefined values can be found in {@link Codec/video}",
    "examples": [
      "<caption>Prefer VP9</caption>\nvar myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>', {\n preferredVideoCodec: Reach.codecs.video.VP9\n});"
    ],
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "preferredAudioCodec",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#preferredAudioCodec",
    "access": "public",
    "description": "The preferred audio Codec. Takes a RegExp matching the codec name and sample rate.\nPredefined values can be found in {@link Codec/audio}",
    "examples": [
      "<caption>Prefer opus</caption>\nvar myReach = new Reach('https://io.datasync.orange.com/base/<my_namespace>', {\n preferredAudioCodec: Reach.codecs.audio.OPUS\n});"
    ],
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "RegExp"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "assign",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#assign",
    "access": "protected",
    "description": "Assign new conf values",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the new conf values"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "[key]",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#[key]",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "set",
    "name": "logLevel",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#logLevel",
    "access": "public",
    "description": "The log level (DEBUG, INFO, WARN, ERROR)",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 87,
    "kind": "get",
    "name": "logLevel",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#logLevel",
    "access": "public",
    "description": "The log level (DEBUG, INFO, WARN, ERROR)",
    "lineNumber": 111,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "set",
    "name": "iceServers",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#iceServers",
    "access": "public",
    "description": "List of TURN/STUN servers to use for ICE.\nThis list will be merged with the ICE servers declared in the namespace (**_/ice**).",
    "lineNumber": 120,
    "type": {
      "nullable": null,
      "types": [
        "ICEServer[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "_iceServers",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#_iceServers",
    "access": "private",
    "description": "",
    "lineNumber": 127,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "get",
    "name": "iceServers",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#iceServers",
    "access": "public",
    "description": "List of TURN/STUN servers to use for ICE.\nThis list will be merged with the ICE servers declared in the namespace (**_/ice**).",
    "lineNumber": 162,
    "type": {
      "nullable": null,
      "types": [
        "ICEServer[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 92,
    "kind": "set",
    "name": "stats",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#stats",
    "access": "public",
    "description": null,
    "lineNumber": 176,
    "undocument": true
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "_stats",
    "memberof": "src/core/Config.js~Config",
    "static": false,
    "longname": "src/core/Config.js~Config#_stats",
    "access": "private",
    "description": null,
    "lineNumber": 177,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "get",
    "name": "stats",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#stats",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "reset",
    "memberof": "src/core/Config.js~Config",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Config.js~Config#reset",
    "access": "protected",
    "description": "Resets configuration to default values",
    "lineNumber": 188,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "src/core/Device.js",
    "content": "import * as DataSync from './util/DataSync';\nimport * as Log from './util/Log';\n\n/**\n * User device\n * @access protected\n */\nexport default class Device {\n  /**\n   * Create a device\n   * @param {Webcom/api.DataSnapshot|object} snapData The data snapshot\n   * @access protected\n   */\n  constructor(snapData) {\n    const values = Object.assign({}, snapData.val());\n    /**\n     * Device's unique id\n     * @type string\n     */\n    this.uid = snapData.name();\n    /**\n     * Device's OS\n     * @type {string}\n     */\n    this.os = values.os;\n    /**\n     * Device's userAgent\n     * @type {string}\n     */\n    this.userAgent = values.userAgent;\n    /**\n     * Device's last know status\n     * - CONNECTED\n     * - NOT_CONNECTED\n     * - SLEEPING\n     * @type {string}\n     */\n    this.status = values.status;\n    /**\n     * Device's sdk\n     * @type {{reach: string, webcom: string}}\n     */\n    this.sdk = values.sdk;\n    // TODO #Feat: Add 'extra' property for unrestricted additional information ?\n  }\n\n\n  /**\n   * Get a device by its user uid and its uid\n   * @access private\n   * @param {string} userUid The user's uid\n   * @param {string} deviceUid The device's uid\n   * @returns {Promise<Device, Error>}\n   */\n  static get(userUid, deviceUid) {\n    // due to the problem of long list, some uid (uid of participant)\n    // can have a : instead of /\n    const newUid = userUid.replace(/:/g, '/');\n    return DataSync.get(`_/devices/${newUid}/${deviceUid}`)\n      .then(snapData => (snapData ? new Device(snapData) : null))\n      .catch(Log.r('Device#get'));\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/Device.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "class",
    "name": "Device",
    "memberof": "src/core/Device.js",
    "static": true,
    "longname": "src/core/Device.js~Device",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/Device.js",
    "importStyle": "Device",
    "description": "User device",
    "lineNumber": 8,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/Device.js~Device",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Device.js~Device#constructor",
    "access": "protected",
    "description": "Create a device",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Webcom/api.DataSnapshot",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "snapData",
        "description": "The data snapshot"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/Device.js~Device",
    "static": false,
    "longname": "src/core/Device.js~Device#uid",
    "access": "public",
    "description": "Device's unique id",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "os",
    "memberof": "src/core/Device.js~Device",
    "static": false,
    "longname": "src/core/Device.js~Device#os",
    "access": "public",
    "description": "Device's OS",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "userAgent",
    "memberof": "src/core/Device.js~Device",
    "static": false,
    "longname": "src/core/Device.js~Device#userAgent",
    "access": "public",
    "description": "Device's userAgent",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "status",
    "memberof": "src/core/Device.js~Device",
    "static": false,
    "longname": "src/core/Device.js~Device#status",
    "access": "public",
    "description": "Device's last know status\n- CONNECTED\n- NOT_CONNECTED\n- SLEEPING",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "sdk",
    "memberof": "src/core/Device.js~Device",
    "static": false,
    "longname": "src/core/Device.js~Device#sdk",
    "access": "public",
    "description": "Device's sdk",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "{reach: string, webcom: string}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "get",
    "memberof": "src/core/Device.js~Device",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Device.js~Device.get",
    "access": "private",
    "description": "Get a device by its user uid and its uid",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Device, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userUid",
        "description": "The user's uid"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "deviceUid",
        "description": "The device's uid"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Device, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "src/core/Error.js",
    "content": "/*\nclass Error {\n\n}\n*/\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/Error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "file",
    "name": "src/core/Invite.js",
    "content": "import {\n  ACCEPTED,\n  CANCELED,\n  ONGOING,\n  REJECTED\n} from './util/constants';\nimport * as DataSync from './util/DataSync';\nimport * as Log from './util/Log';\nimport cache from './util/cache';\nimport Room from './Room';\nimport * as Events from '../definitions/Events';\n\n/**\n * Update\n * @param {Invite} invite The invite\n * @param {string} status The new status\n * @param {string} [reason=null] The reason (a message)\n * @param {object} [_ended=null]\n * @access private\n * @returns {Promise<Invite, Error>}\n */\nconst update = (invite, status, reason = null, _ended = null) => {\n  const values = {\n    status,\n    reason,\n    _ended\n  };\n  if (invite.status !== ONGOING) {\n    return Promise.reject(new Error('This invitation has already been answered'));\n  }\n  return DataSync.update(`_/invites/${invite.to}/${invite.uid}`, values)\n    .then(() => {\n      Object.keys(values).forEach((prop) => {\n        invite[prop] = values[prop]; // eslint-disable-line no-param-reassign\n      });\n      return Room.get(invite.room);\n    })\n    .then(() => ({ invite }))\n    .catch(Log.r('Invite_update'));\n};\n\n/**\n * Invitation\n * @public\n */\nexport default class Invite {\n  /**\n   * Create an invite\n   * @param {Webcom/api.DataSnapshot|object} snapData The data snapshot\n   * @access protected\n   */\n  constructor(snapData) {\n    let values = snapData;\n    if (snapData && snapData.val && typeof snapData.val === 'function') {\n      values = Object.assign({},\n        snapData.val(),\n        { uid: snapData.name(), to: snapData.ref().parent().name() });\n    }\n    /**\n     * Invite's unique id\n     * @type string\n     */\n    this.uid = values.uid;\n    /**\n     * Invite's sender uid\n     * @type {string}\n     */\n    this.from = values.from;\n    /**\n     * Invitee's uid\n     * @type {string}\n     */\n    this.to = values.to;\n    /**\n     * The id of the room associated to the invite\n     * @type {string}\n     */\n    this.room = values.room;\n    /**\n     * The invitation status :\n     * - ONGOING - The receiver has not yet responded to the invitation\n     * - ACCEPTED - The receiver has accepted the invitation\n     * - REJECTED - The receiver has rejected the invitation\n     * - CANCELED - The sender canceled the invitation\n     * @type {string}\n     */\n    this.status = values.status;\n    /**\n     * Invite message. This will be either a custom message,\n     * if the status is ONGOING or a reason when status is CANCELED|REJECTED.\n     * @type {string}\n     */\n    this.topic = values.topic;\n    /**\n     * Invite creation timestamp\n     * @type {number}\n     */\n    this._created = values._created;\n    /**\n     * Invite expiration timestamp\n     * @type {number}\n     */\n    this._ended = values._ended;\n    /**\n     * Invite events callbacks\n     * @type {{}}\n     * @private\n     */\n    this._callbacks = {};\n  }\n\n  /**\n   * Is this invitation waiting for a reply ?\n   * @type {boolean}\n   */\n  get isOnGoing() {\n    return this.status === ONGOING;\n  }\n\n  /**\n   * Was this invitation rejected ?\n   * @type {boolean}\n   */\n  get isRejected() {\n    return this.status === REJECTED;\n  }\n\n  /**\n   * Was this invitation accepted ?\n   * @type {boolean}\n   */\n  get isAccepted() {\n    return this.status === ACCEPTED;\n  }\n\n  /**\n   * Was this invitation canceled ?\n   * @type {boolean}\n   */\n  get isCanceled() {\n    return this.status === CANCELED;\n  }\n\n  /**\n   * Cancels the invitation. Only the sender can cancel the invitation.\n   * @param {string} [reason] The reason the sender is canceling the invite\n   * @return {Promise<Invite>}\n   */\n  cancel(reason) {\n    return update(this, CANCELED, reason, DataSync.ts());\n  }\n\n  /**\n   * Rejects the invitation. Only the receiver can reject the invitation.\n   * @param {string} [reason] The reason the receiver is rejecting the invite\n   * @return {Promise<Invite>}\n   */\n  reject(reason) {\n    return update(this, REJECTED, reason, DataSync.ts());\n  }\n\n  /**\n   * Accept the invitation. Only the receiver can accept the invitation.\n   * @return {Promise<Invite>}\n   */\n  accept() {\n    return update(this, ACCEPTED);\n  }\n\n  /**\n   * Register a callback for a status update\n   * @param {string} status Can be:\n   * - ACCEPTED\n   * - REJECTED\n   * - CANCELED\n   * @param {function} callback\n   */\n  on(status, callback) {\n    if (Events.invite.supports(status)) {\n      // Register callback\n      if (!this._callbacks[status]) {\n        this._callbacks[status] = [];\n      }\n      this._callbacks[status].push(callback);\n      // Defined listener & subscribe if needed\n      if (!this._listener) {\n        /**\n         * Invite status update callback\n         * @type {function}\n         * @private\n         */\n        this._listener = (snapData) => {\n          const updated = snapData.val();\n          if (updated !== null && updated !== this.status) {\n            this.status = updated;\n            (this._callbacks[updated] || []).forEach((cb) => {\n              cb(this);\n            });\n          }\n        };\n        DataSync.on(`_/invites/${this.to}/${this.uid}/status`, 'value', this._listener.bind(this));\n      }\n    }\n  }\n\n  /**\n   * Register a callback for all status change events\n   * @param {function} callback\n   */\n  onStatusChange(callback) {\n    [ACCEPTED, REJECTED, CANCELED].forEach((event) => {\n      this.on(event, callback);\n    });\n  }\n\n  /**\n   * Un-register a callback for a status update\n   * @param {string} [status] Can be:\n   * - ACCEPTED\n   * - REJECTED\n   * - CANCELED\n   * - null This will un-register all callbacks\n   * @param {function} [callback]\n   */\n  off(status, callback) {\n    if (!status) {\n      this._callbacks = {};\n    } else if (this._callbacks[status]) {\n      if (callback) {\n        const idx = this._callbacks[status].findIndex(cb => cb === callback);\n        if (idx >= 0) {\n          this._callbacks.splice(idx, 1);\n        }\n      } else {\n        this._callbacks[status] = [];\n      }\n    }\n    if (![CANCELED, ACCEPTED, REJECTED]\n      .some(event => this._callbacks[event] && this._callbacks[event].length > 0)) {\n      DataSync.off(`_/invites/${this.to}/${this.uid}/status`, 'value');\n    }\n  }\n\n  /**\n   * Un-register a callback for all status change events\n   * @param {function} [callback]\n   */\n  offStatusChange(callback) {\n    if (!callback) {\n      this.off();\n    } else {\n      [ACCEPTED, REJECTED, CANCELED].forEach((event) => {\n        this.off(event, callback);\n      });\n    }\n  }\n\n  /**\n   * Create the invitation & add the user to the participants list\n   * @access protected\n   * @param {User} invitee The user to invite\n   * @param {Room} room The room to invite the user to\n   * @param {string} [message] A message for the invitee\n   */\n  static send(invitee, room, message = null) {\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can send an invite.'));\n    }\n\n    const inviteMetaData = {\n      from: cache.user.uid,\n      room: room.uid,\n      status: ONGOING,\n      _created: DataSync.ts(),\n      topic: message\n    };\n\n    return DataSync.push(`_/invites/${invitee.uid}`, inviteMetaData)\n      .then((inviteRef) => {\n        const inviteId = inviteRef.name();\n        return new Invite(Object.assign({ uid: inviteId, to: invitee.uid }, inviteMetaData));\n      })\n      .catch(Log.r('Invite#send'));\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/Invite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 107,
    "kind": "function",
    "name": "update",
    "memberof": "src/core/Invite.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Invite.js~update",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/Invite.js",
    "importStyle": null,
    "description": "Update",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Invite, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Invite"
        ],
        "spread": false,
        "optional": false,
        "name": "invite",
        "description": "The invite"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": "The new status"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "reason",
        "description": "The reason (a message)"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "_ended",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Invite, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "class",
    "name": "Invite",
    "memberof": "src/core/Invite.js",
    "static": true,
    "longname": "src/core/Invite.js~Invite",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/Invite.js",
    "importStyle": "Invite",
    "description": "Invitation",
    "lineNumber": 46,
    "interface": false
  },
  {
    "__docId__": 109,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#constructor",
    "access": "protected",
    "description": "Create an invite",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Webcom/api.DataSnapshot",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "snapData",
        "description": "The data snapshot"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#uid",
    "access": "public",
    "description": "Invite's unique id",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "from",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#from",
    "access": "public",
    "description": "Invite's sender uid",
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "to",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#to",
    "access": "public",
    "description": "Invitee's uid",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "room",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#room",
    "access": "public",
    "description": "The id of the room associated to the invite",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "status",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#status",
    "access": "public",
    "description": "The invitation status :\n- ONGOING - The receiver has not yet responded to the invitation\n- ACCEPTED - The receiver has accepted the invitation\n- REJECTED - The receiver has rejected the invitation\n- CANCELED - The sender canceled the invitation",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "topic",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#topic",
    "access": "public",
    "description": "Invite message. This will be either a custom message,\nif the status is ONGOING or a reason when status is CANCELED|REJECTED.",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "_created",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#_created",
    "access": "private",
    "description": "Invite creation timestamp",
    "lineNumber": 98,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "_ended",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#_ended",
    "access": "private",
    "description": "Invite expiration timestamp",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "_callbacks",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#_callbacks",
    "access": "private",
    "description": "Invite events callbacks",
    "lineNumber": 109,
    "type": {
      "nullable": null,
      "types": [
        "{}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 119,
    "kind": "get",
    "name": "isOnGoing",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#isOnGoing",
    "access": "public",
    "description": "Is this invitation waiting for a reply ?",
    "lineNumber": 116,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 120,
    "kind": "get",
    "name": "isRejected",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#isRejected",
    "access": "public",
    "description": "Was this invitation rejected ?",
    "lineNumber": 124,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 121,
    "kind": "get",
    "name": "isAccepted",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#isAccepted",
    "access": "public",
    "description": "Was this invitation accepted ?",
    "lineNumber": 132,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 122,
    "kind": "get",
    "name": "isCanceled",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#isCanceled",
    "access": "public",
    "description": "Was this invitation canceled ?",
    "lineNumber": 140,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "cancel",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#cancel",
    "access": "public",
    "description": "Cancels the invitation. Only the sender can cancel the invitation.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "reason",
        "description": "The reason the sender is canceling the invite"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Invite>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "reject",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#reject",
    "access": "public",
    "description": "Rejects the invitation. Only the receiver can reject the invitation.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "reason",
        "description": "The reason the receiver is rejecting the invite"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Invite>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "accept",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#accept",
    "access": "public",
    "description": "Accept the invitation. Only the receiver can accept the invitation.",
    "lineNumber": 166,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Invite>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "on",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#on",
    "access": "public",
    "description": "Register a callback for a status update",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": "Can be:\n- ACCEPTED\n- REJECTED\n- CANCELED"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "_listener",
    "memberof": "src/core/Invite.js~Invite",
    "static": false,
    "longname": "src/core/Invite.js~Invite#_listener",
    "access": "private",
    "description": "Invite status update callback",
    "lineNumber": 192,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "onStatusChange",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#onStatusChange",
    "access": "public",
    "description": "Register a callback for all status change events",
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "off",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#off",
    "access": "public",
    "description": "Un-register a callback for a status update",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "status",
        "description": "Can be:\n- ACCEPTED\n- REJECTED\n- CANCELED\n- null This will un-register all callbacks"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "offStatusChange",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Invite.js~Invite#offStatusChange",
    "access": "public",
    "description": "Un-register a callback for all status change events",
    "lineNumber": 248,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "send",
    "memberof": "src/core/Invite.js~Invite",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Invite.js~Invite.send",
    "access": "protected",
    "description": "Create the invitation & add the user to the participants list",
    "lineNumber": 265,
    "params": [
      {
        "nullable": null,
        "types": [
          "User"
        ],
        "spread": false,
        "optional": false,
        "name": "invitee",
        "description": "The user to invite"
      },
      {
        "nullable": null,
        "types": [
          "Room"
        ],
        "spread": false,
        "optional": false,
        "name": "room",
        "description": "The room to invite the user to"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "message",
        "description": "A message for the invitee"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "file",
    "name": "src/core/Message.js",
    "content": "import * as DataSync from './util/DataSync';\nimport * as Log from './util/Log';\n\nimport cache from './util/cache';\n\n/**\n * Instant Message\n * @public\n */\nexport default class Message {\n  /**\n   * Create a message\n   * @param {Webcom/api.DataSnapshot|Object} snapData The data snapshot\n   * @param {string} roomId The message's room id\n   * @access protected\n   */\n  constructor(snapData, roomId) {\n    const values = Object.assign({}, snapData.val());\n    /**\n     * The message unique id\n     * @type {string}\n     */\n    this.uid = snapData.name();\n    /**\n     * The room uid\n     * @type {string}\n     */\n    this.roomId = roomId;\n    /**\n     * The message\n     * @type {string}\n     */\n    this.text = values.text;\n    /**\n     * The message sender\n     * @type {string}\n     */\n    this.from = values.from;\n    /**\n     * Joined date\n     * @type {number}\n     */\n    this._created = values._created;\n  }\n\n  /**\n   * Edit the text message. Only the sender or moderator/owner of the room can edit a message.\n   * @param {string} newText The new message\n   * @returns {Promise<Message>}\n   */\n  edit(newText) {\n    return DataSync.update(`/rooms/${this.roomId}/messages/${this.uid}`, { text: newText })\n      .then(() => {\n        this.text = newText;\n        return this;\n      })\n      .catch(Log.r('Message~edit'));\n  }\n\n  /**\n   * Remove the text message. Only the sender or moderator/owner of the room can remove a message.\n   * @returns {Promise}\n   */\n  remove() {\n    return DataSync.remove(`/rooms/${this.roomId}/messages/${this.uid}`)\n      .catch(Log.r('Message~remove'));\n  }\n\n  /**\n   *\n   * @param {Room} room The room to send the message to\n   * @param {string} text The message\n   * @return {Promise<Message>}\n   */\n  static send(room, text) {\n    if (!cache.user) {\n      return Promise.reject(\n        new Error('Cannot send a message to the Room without a User being logged in.')\n      );\n    }\n    const data = {\n      from: cache.user.uid,\n      _created: DataSync.ts(),\n      text\n    };\n    return DataSync.push(`_/rooms/${room.uid}/messages`, data)\n      .then(pushRef => DataSync.get(`_/rooms/${room.uid}/messages/${pushRef.name()}`))\n      .then(snapData => new Message(snapData, room.uid))\n      .catch(Log.r('Message#send'));\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/Message.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 135,
    "kind": "class",
    "name": "Message",
    "memberof": "src/core/Message.js",
    "static": true,
    "longname": "src/core/Message.js~Message",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/Message.js",
    "importStyle": "Message",
    "description": "Instant Message",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 136,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/Message.js~Message",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Message.js~Message#constructor",
    "access": "protected",
    "description": "Create a message",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Webcom/api.DataSnapshot",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "snapData",
        "description": "The data snapshot"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "roomId",
        "description": "The message's room id"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/Message.js~Message",
    "static": false,
    "longname": "src/core/Message.js~Message#uid",
    "access": "public",
    "description": "The message unique id",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "roomId",
    "memberof": "src/core/Message.js~Message",
    "static": false,
    "longname": "src/core/Message.js~Message#roomId",
    "access": "public",
    "description": "The room uid",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "text",
    "memberof": "src/core/Message.js~Message",
    "static": false,
    "longname": "src/core/Message.js~Message#text",
    "access": "public",
    "description": "The message",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "from",
    "memberof": "src/core/Message.js~Message",
    "static": false,
    "longname": "src/core/Message.js~Message#from",
    "access": "public",
    "description": "The message sender",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "_created",
    "memberof": "src/core/Message.js~Message",
    "static": false,
    "longname": "src/core/Message.js~Message#_created",
    "access": "private",
    "description": "Joined date",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "edit",
    "memberof": "src/core/Message.js~Message",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Message.js~Message#edit",
    "access": "public",
    "description": "Edit the text message. Only the sender or moderator/owner of the room can edit a message.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Message>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "newText",
        "description": "The new message"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Message>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "remove",
    "memberof": "src/core/Message.js~Message",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Message.js~Message#remove",
    "access": "public",
    "description": "Remove the text message. Only the sender or moderator/owner of the room can remove a message.",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "send",
    "memberof": "src/core/Message.js~Message",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Message.js~Message.send",
    "access": "public",
    "description": "",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "Room"
        ],
        "spread": false,
        "optional": false,
        "name": "room",
        "description": "The room to send the message to"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "The message"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Message>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 146,
    "kind": "file",
    "name": "src/core/Participant.js",
    "content": "/**\n * {@link Room} participant\n * @public\n */\nexport default class Participant {\n  /**\n   * Create a participant\n   * @param {Webcom/api.DataSnapshot|Object} snapData The data snapshot\n   * @access protected\n   */\n  constructor(snapData) {\n    const values = Object.assign({}, snapData.val());\n    /**\n     * The participant unique id\n     * @type {string}\n     */\n    this.uid = snapData.name();\n    /**\n     * The Participant's role. Can be:\n     * - OWNER: the owner/creator of the {@link Room}\n     * - MODERATOR: a participant with {@link Room} management Rights\n     * - NONE: basic participant\n     * @type {string}\n     */\n    this.role = values.role;\n    /**\n     * The participant status Can be:\n     * - NOT_CONNECTED: the participant did not accept the invitation yet and/or did not\n     * join the {@link Room} yet\n     * - CONNECTED: the participant is in the {@link Room}\n     * - WAS_CONNECTED: the participant left the {@link Room}\n     * @type {string}\n     */\n    this.status = values.status;\n    /**\n     * Joined date\n     * @type {number}\n     */\n    this._joined = values._joined;\n    /**\n     * Participant's userAgent\n     * @type {string}\n     */\n    this.userAgent = values.userAgent;\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/Participant.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 147,
    "kind": "class",
    "name": "Participant",
    "memberof": "src/core/Participant.js",
    "static": true,
    "longname": "src/core/Participant.js~Participant",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/Participant.js",
    "importStyle": "Participant",
    "description": "{@link Room} participant",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 148,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/Participant.js~Participant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Participant.js~Participant#constructor",
    "access": "protected",
    "description": "Create a participant",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Webcom/api.DataSnapshot",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "snapData",
        "description": "The data snapshot"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 149,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/Participant.js~Participant",
    "static": false,
    "longname": "src/core/Participant.js~Participant#uid",
    "access": "public",
    "description": "The participant unique id",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 150,
    "kind": "member",
    "name": "role",
    "memberof": "src/core/Participant.js~Participant",
    "static": false,
    "longname": "src/core/Participant.js~Participant#role",
    "access": "public",
    "description": "The Participant's role. Can be:\n- OWNER: the owner/creator of the {@link Room}\n- MODERATOR: a participant with {@link Room} management Rights\n- NONE: basic participant",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "status",
    "memberof": "src/core/Participant.js~Participant",
    "static": false,
    "longname": "src/core/Participant.js~Participant#status",
    "access": "public",
    "description": "The participant status Can be:\n- NOT_CONNECTED: the participant did not accept the invitation yet and/or did not\njoin the {@link Room} yet\n- CONNECTED: the participant is in the {@link Room}\n- WAS_CONNECTED: the participant left the {@link Room}",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "_joined",
    "memberof": "src/core/Participant.js~Participant",
    "static": false,
    "longname": "src/core/Participant.js~Participant#_joined",
    "access": "private",
    "description": "Joined date",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "userAgent",
    "memberof": "src/core/Participant.js~Participant",
    "static": false,
    "longname": "src/core/Participant.js~Participant#userAgent",
    "access": "public",
    "description": "Participant's userAgent",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 154,
    "kind": "file",
    "name": "src/core/Room.js",
    "content": "import {\n  CANCELED,\n  CLOSED,\n  CONNECTED,\n  NONE,\n  NOT_CONNECTED,\n  OPENED,\n  OWNER,\n  REJECTED,\n  WAS_CONNECTED\n} from './util/constants';\nimport * as DataSync from './util/DataSync';\nimport cache from './util/cache';\nimport Participant from './Participant';\nimport Message from './Message';\nimport Local from './stream/Local';\nimport Invite from './Invite';\nimport * as Events from '../definitions/Events';\nimport * as Log from './util/Log';\n\nconst _joinRoom = (room, role) => {\n  const uid = cache.user.uid.split('/').join(':');\n\n  if (room.status !== CLOSED) {\n    const participant = {\n      status: CONNECTED,\n      userAgent: cache.userAgent,\n      _joined: DataSync.ts()\n    };\n    if (role) {\n      participant.role = role;\n    }\n    Log.w('Room#join', [participant, `_/rooms/${room.uid}/participants/${uid}`]);\n    return DataSync\n    // .update(`_/rooms/${room.uid}/participants/${cache.user.uid}`, participant)\n      .update(`_/rooms/${room.uid}/participants/${uid}`, participant)\n      .then(() => room);\n    /* .then(() => {\n      DataSync\n        .onDisconnect(`_/rooms/${room.uid}/participants/${shortUserId}/status`)\n        .set(WAS_CONNECTED);\n      return room;\n    }); */\n  }\n  return Promise.reject(new Error('can\\'t join a close room'));\n};\n\n/**\n * Room information\n * @access public\n */\nexport default class Room {\n  /**\n   * Create a room\n   * @param {Webcom/api.DataSnapshot|Object} snapData The data snapshot\n   * @access protected\n   */\n  constructor(snapData, roomUid) {\n    let values = snapData;\n    if (snapData && snapData.val && typeof snapData.val === 'function') {\n      // values = Object.assign({}, snapData.val(), {uid: snapData.name()});\n      values = Object.assign({}, snapData.val(), { uid: roomUid });\n    }\n    /**\n     * The room unique id\n     * @type {string}\n     */\n    this.uid = values.uid;\n    /**\n     * The room name\n     * @type {string}\n     */\n    this.name = values.name;\n    /**\n     * The local stream of the room\n     * @type {Local}\n     */\n    this.localStream = {};\n    /**\n     * The room owner uid\n     * @type {string}\n     */\n    this.owner = values.owner;\n    /**\n     * The room status:\n     * - OPENED\n     * - CLOSED\n     * @type {string}\n     */\n    this.status = values.status;\n\n    /**\n     * Indicates that the room is public so all users can join\n     * @type {boolean}\n     */\n    this._public = !!values._public;\n\n    /**\n     * Additional room informations\n     * @type {Object}\n     */\n    this.extra = values.extra;\n\n    /**\n     * List of declared callbacks\n     * @type {Object}\n     */\n    this._callbacks = {};\n  }\n\n  /**\n   * Get the list of participants.\n   * This will only work if the user is either a participant or the owner of the room.\n   * @returns {Promise<Participant[], Error>}\n   */\n  participants() {\n    return DataSync.list(`_/rooms/${this.uid}/participants`, Participant, this.uid);\n  }\n\n  /**\n   * Get the list of messages.\n   * This will only work if the user is either a participant or the owner of the room.\n   * @return {Promise<Message[], Error>}\n   */\n  messages() {\n    return DataSync.list(`_/rooms/${this.uid}/messages`, Message, this.uid);\n  }\n\n  /**\n   * Get the list of streams\n   * @returns {Promise}\n   * @access private\n   */\n  _streams(localStreams) {\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can list a Room\\'s streams.'));\n    }\n    return DataSync.get(`_/rooms/${this.uid}/streams`)\n      .then((snapData) => {\n        const values = snapData.val();\n        Log.d('Rooms~_streams', values);\n        if (values) {\n          return Object.keys(values).map(key => Object.assign({\n            uid: key,\n            roomId: this.uid\n          }, values[key]));\n        }\n        return [];\n      })\n      .then(streams => streams.filter(stream => (\n        localStreams === (stream.device === cache.device && stream.from === cache.user.uid))))\n      .then(streams => streams.map(cache.streams[`get${localStreams ? 'Shared' : 'Remote'}`].bind(cache.streams)))\n      .then(streams => streams.filter(stream => stream !== null));\n  }\n\n  /**\n   * Get the list of locally published streams.\n   * The streams published with another device won't be visible here\n   * This will only work if the user is either a participant or the owner of the room.\n   * @return {Promise<Local[], Error>}\n   */\n  localStreams() {\n    return this._streams(true)\n      .catch(Log.r('Room~localStreams'));\n  }\n\n  /**\n   * Get the list of remotely published streams.\n   * This will only work if the user is either a participant or the owner of the room.\n   * @return {Promise<Remote[], Error>}\n   */\n  remoteStreams() {\n    return this._streams(false)\n      .catch(Log.r('Room~remoteStreams'));\n  }\n\n  /**\n   * Invite users to the room.\n   * This will only work if the current User is the owner or a moderator of this Room.\n   * This will create the invitation and add the user to the participants list.\n   * @param {User[]} users the users to invite\n   * @param {string} [role='NONE'] the role of the invitee\n   * @param {string} [message] a message to add to the invite\n   * @return {Promise<{room: Room, invites: Invite[]}, Error>}\n   */\n  invite(users, role = NONE, message) {\n    const _path = user => `_/rooms/${this.uid}/participants/${user.uid}`;\n    const _data = {\n      status: NOT_CONNECTED,\n      role: role || NONE\n    };\n    // Add users as participant so they can join the room\n    return Promise.all(users.map(user => DataSync.set(_path(user), _data)))\n    // Send invites\n      .then(() => Promise.all(users.map(user => Invite.send(user, this, message))))\n      .then((invites) => {\n        const removeParticipant = invite => DataSync.remove(`_/rooms/${invite.room}/participants/${invite.to}`);\n        invites.forEach((invite) => {\n          invite.on(REJECTED, removeParticipant);\n          invite.on(CANCELED, removeParticipant);\n        });\n        return { room: this, invites };\n      })\n      .catch((e) => {\n        Log.e('Room~invite', e);\n        users.forEach(user => DataSync.remove(`_/rooms/${this.uid}/participants/${user.uid}`));\n        return Promise.reject(e);\n      });\n  }\n\n  /**\n   * Register a callback for a specific event\n   * @param {string} event The event name ({@link Events/Room}):\n   * - PARTICIPANT_ADDED: a participant is added to the room\n   * - PARTICIPANT_CHANGED: a participant changes his status (join)\n   * - PARTICIPANT_REMOVED: a participant leave the room\n   * - MESSAGE_ADDED: new instant message\n   * - MESSAGE_CHANGED: an existing message has been modified (moderation)\n   * - MESSAGE_REMOVED: a message has been removed (moderation)\n   * - STREAM_PUBLISHED: a participant published a new Stream\n   * - STREAM_CHANGED: a participant changes his published Stream (moderation, type, mute...)\n   * - STREAM_UNPUBLISHED: a participant stops the publication of his Stream\n   * @param {function} callback\n   * The callback for the event, the arguments depends on the type of event:\n   * - PARTICIPANT_* : callback({@link Participant} p [, Error e])\n   * - MESSAGE_* : callback({@link Message} m [, Error e])\n   * - STREAM_* : callback({@link Remote} s [, Error e])\n   * @param {Webcom/api.Query~cancelCallback} cancelCallback The error callback for the event,\n   * takes an Error as only argument\n   */\n  on(event, callback, cancelCallback) {\n    const\n      path = Events.room.toPath(event)(this);\n\n\n    const Obj = Events.room.toClass(event);\n    if (path && Obj) {\n      const typedCallback = (snapData) => {\n        if (!/^STREAM_/i.test(event) || !snapData) {\n          // if(/^MESSAGE_/i.test(event) || !snapData) {\n          Log.i(`Room~on(${event})`, snapData ? new Obj(snapData) : null);\n          callback(snapData ? new Obj(snapData) : null);\n        } else if (cache.user) {\n          const streamData = Object.assign({\n            uid: snapData.name(),\n            roomId: this.uid\n          }, snapData.val());\n          if (streamData.from !== cache.user.uid || streamData.device !== cache.device) {\n            const remoteStream = cache.streams.getRemote(streamData);\n            Log.i(`Room~on(${event})`, remoteStream);\n            callback(remoteStream);\n          }\n        }\n      };\n      DataSync.on(path, event, typedCallback, cancelCallback);\n      if (!this._callbacks[event]) {\n        this._callbacks[event] = [];\n      }\n      this._callbacks[event].push(typedCallback);\n    }\n  }\n\n  /**\n   * Send an instant message\n   * @param {string} message The message to send\n   * @return {Promise<Message>}\n   */\n  sendMessage(message) {\n    return Message.send(this, message);\n  }\n\n  /**\n   * Publish a local stream\n   * @param {string} type The stream type, see {@link StreamTypes} for possible values\n   * @param {Element} [localStreamContainer] The element the stream is attached to.\n   * Can be null if already specified in {@link Config}.\n   * @param {MediaStreamConstraints} [constraints] The stream constraints.\n   * If not defined, the constraints defined in {@link Config} will be used.\n   * @returns {Promise<Local, Error>}\n   */\n  share(type, localStreamContainer, constraints) {\n    Log.i('Room~share', { type, localStreamContainer, constraints });\n    return Local.share(this.uid, type, localStreamContainer, constraints);\n  }\n\n  /**\n   * get a local stream in video tag\n   * @param {string} type The stream type, see {@link StreamTypes} for possible values\n   * @param {Element} [localStreamContainer] The element the stream is attached to.\n   * Can be null if already specified in {@link Config}.\n   * @param {MediaStreamConstraints} [constraints] The stream constraints.\n   * If not defined, the constraints defined in {@link Config} will be used.\n   * @returns {Promise<Local, Error>}\n   */\n  getLocalVideo(type, localStreamContainer, constraints) {\n    Log.i('Room~getLocalVideo', { type, localStreamContainer, constraints });\n    return Local.getLocalVideo(this.uid, type, localStreamContainer, constraints)\n      .then((localStream) => {\n        this.localStream = localStream;\n        return localStream;\n      });\n  }\n\n  /**\n   * publish a local stream\n   * @returns {Local}\n   */\n  publish() {\n    Log.i('Room~publish Local');\n    return Local.publish(this.localStream);\n  }\n\n  /**\n   * Join the room. Sets the connected status of the current participant to CONNECTED.\n   * @return {Promise}\n   */\n  join() {\n    Log.i('Room~join', this);\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can join a Room.'));\n    }\n    return _joinRoom(this).catch(Log.r('Room~join'));\n  }\n\n  /**\n   * Leave the room. Sets the connected status of the current participant to WAS_CONNECTED,\n   * deletes medias and callbacks, closes WebRTC stacks in use.\n   * @return {Promise}\n   */\n  leave() {\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can leave a Room.'));\n    }\n    Log.i('Room~leave', this);\n    // Cancel onDisconnect\n    const uid = cache.user.uid.split('/').join(':');\n    DataSync.onDisconnect(`_/rooms/${this.uid}/participants/${uid}/status`).cancel();\n\n    // Disconnect user's callbacks\n    Object.keys(this._callbacks).forEach((event) => {\n      DataSync.off(Events.room.toPath(event)(this), event);\n    });\n    // Unpublish all published local streams\n    this.localStreams()\n      .then(localStreams => localStreams.forEach(localStream => localStream.close()));\n    // Unsubscribe all remote streams\n    this.remoteStreams()\n      .then(remoteStreams => remoteStreams.forEach(remoteStream => remoteStream.unSubscribe()));\n    // Update status\n    return DataSync.set(`_/rooms/${this.uid}/participants/${uid}/status`, WAS_CONNECTED)\n    // return DataSync.set(`_/rooms/${this.uid}/participants/${shortUserId}/status`, WAS_CONNECTED)\n      .catch(Log.r('Room~leave'));\n  }\n\n  /**\n   * Leaves & close the Room. Only the owner/moderator can close a room.\n   * @return {Promise}\n   */\n  close() {\n    Log.i('Room~close', this);\n    this.status = CLOSED;\n    return this.leave()\n      .then(() => DataSync.update(`rooms/${this.uid}`, { status: CLOSED, _closed: DataSync.ts() }))\n      .then(() => DataSync.remove(`_/rooms/${this.uid}`))\n      .catch(Log.r('Room~close'));\n  }\n\n  /**\n   * Create a room\n   * @access protected\n   * @param {String} [name] The room name\n   * @param {object} [extra=null] Extra informations\n   * @param {boolean} [publicRoom=false] Indicates public room\n   * @returns {Promise<Room, Error>}\n   */\n  static create(name, extra = null, publicRoom = false) {\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can create a Room.'));\n    }\n\n    const roomMetaData = {\n      owner: cache.user.uid,\n      _public: publicRoom,\n      name: name || `${cache.user.name}-${Date.now()}`\n    };\n    const roomFullMetaData = Object.assign({\n      status: OPENED,\n      _created: DataSync.ts(),\n      extra\n    }, roomMetaData);\n\n    let room = null;\n    // Create public room infos\n    // return DataSync.push('rooms', roomFullMetaData)\n    const id1 = Math.floor(Math.random() * 1000);\n    const id2 = Math.floor(Math.random() * 1000);\n    return DataSync.push(`rooms/${id1}/${id2}`, roomFullMetaData)\n    // Create private room infos\n      .then((roomRef) => {\n        room = new Room(Object.assign({ uid: `${id1}/${id2}/${roomRef.name()}` }, roomFullMetaData));\n        cache.room = roomFullMetaData;\n        return DataSync.update(`_/rooms/${room.uid}/meta`, roomMetaData);\n      })\n      // Join the room\n      .then(() => _joinRoom(room, OWNER))\n      .catch(Log.r('Room#create'));\n  }\n\n  /**\n   * Get a {@link Room} from its `uid`\n   * @access protected\n   * @param uid\n   * @returns {Promise.<Room>}\n   */\n  static get(uid) {\n    return DataSync.get(`rooms/${uid}`)\n      .then((snapData) => {\n        if (snapData.val()) {\n          return new Room(snapData, uid);\n        }\n        return null;\n      });\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/Room.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 155,
    "kind": "function",
    "name": "_joinRoom",
    "memberof": "src/core/Room.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Room.js~_joinRoom",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/Room.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "room",
        "types": [
          "*"
        ]
      },
      {
        "name": "role",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "class",
    "name": "Room",
    "memberof": "src/core/Room.js",
    "static": true,
    "longname": "src/core/Room.js~Room",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/Room.js",
    "importStyle": "Room",
    "description": "Room information",
    "lineNumber": 52,
    "interface": false
  },
  {
    "__docId__": 157,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#constructor",
    "access": "protected",
    "description": "Create a room",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "Webcom/api.DataSnapshot",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "snapData",
        "description": "The data snapshot"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#uid",
    "access": "public",
    "description": "The room unique id",
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "name",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#name",
    "access": "public",
    "description": "The room name",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "localStream",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#localStream",
    "access": "public",
    "description": "The local stream of the room",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "Local"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "owner",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#owner",
    "access": "public",
    "description": "The room owner uid",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "status",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#status",
    "access": "public",
    "description": "The room status:\n- OPENED\n- CLOSED",
    "lineNumber": 90,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "_public",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#_public",
    "access": "private",
    "description": "Indicates that the room is public so all users can join",
    "lineNumber": 96,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "extra",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#extra",
    "access": "public",
    "description": "Additional room informations",
    "lineNumber": 102,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "_callbacks",
    "memberof": "src/core/Room.js~Room",
    "static": false,
    "longname": "src/core/Room.js~Room#_callbacks",
    "access": "private",
    "description": "List of declared callbacks",
    "lineNumber": 108,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "participants",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#participants",
    "access": "public",
    "description": "Get the list of participants.\nThis will only work if the user is either a participant or the owner of the room.",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Participant[], Error>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Participant[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "messages",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#messages",
    "access": "public",
    "description": "Get the list of messages.\nThis will only work if the user is either a participant or the owner of the room.",
    "lineNumber": 125,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Message[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "_streams",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#_streams",
    "access": "private",
    "description": "Get the list of streams",
    "lineNumber": 134,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": [
      {
        "name": "localStreams",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "localStreams",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#localStreams",
    "access": "public",
    "description": "Get the list of locally published streams.\nThe streams published with another device won't be visible here\nThis will only work if the user is either a participant or the owner of the room.",
    "lineNumber": 162,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "remoteStreams",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#remoteStreams",
    "access": "public",
    "description": "Get the list of remotely published streams.\nThis will only work if the user is either a participant or the owner of the room.",
    "lineNumber": 172,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Remote[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "invite",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#invite",
    "access": "public",
    "description": "Invite users to the room.\nThis will only work if the current User is the owner or a moderator of this Room.\nThis will create the invitation and add the user to the participants list.",
    "lineNumber": 186,
    "params": [
      {
        "nullable": null,
        "types": [
          "User[]"
        ],
        "spread": false,
        "optional": false,
        "name": "users",
        "description": "the users to invite"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'NONE'",
        "defaultRaw": "'NONE'",
        "name": "role",
        "description": "the role of the invitee"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "message",
        "description": "a message to add to the invite"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{room: Room, invites: Invite[]}, Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "on",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#on",
    "access": "public",
    "description": "Register a callback for a specific event",
    "lineNumber": 231,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event name ({@link Events/Room}):\n- PARTICIPANT_ADDED: a participant is added to the room\n- PARTICIPANT_CHANGED: a participant changes his status (join)\n- PARTICIPANT_REMOVED: a participant leave the room\n- MESSAGE_ADDED: new instant message\n- MESSAGE_CHANGED: an existing message has been modified (moderation)\n- MESSAGE_REMOVED: a message has been removed (moderation)\n- STREAM_PUBLISHED: a participant published a new Stream\n- STREAM_CHANGED: a participant changes his published Stream (moderation, type, mute...)\n- STREAM_UNPUBLISHED: a participant stops the publication of his Stream"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback for the event, the arguments depends on the type of event:\n- PARTICIPANT_* : callback({@link Participant} p [, Error e])\n- MESSAGE_* : callback({@link Message} m [, Error e])\n- STREAM_* : callback({@link Remote} s [, Error e])"
      },
      {
        "nullable": null,
        "types": [
          "Webcom/api.Query~cancelCallback"
        ],
        "spread": false,
        "optional": false,
        "name": "cancelCallback",
        "description": "The error callback for the event,\ntakes an Error as only argument"
      }
    ],
    "return": null
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "sendMessage",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#sendMessage",
    "access": "public",
    "description": "Send an instant message",
    "lineNumber": 268,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message to send"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Message>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "share",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#share",
    "access": "public",
    "description": "Publish a local stream",
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Local, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The stream type, see {@link StreamTypes} for possible values"
      },
      {
        "nullable": null,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": true,
        "name": "localStreamContainer",
        "description": "The element the stream is attached to.\nCan be null if already specified in {@link Config}."
      },
      {
        "nullable": null,
        "types": [
          "MediaStreamConstraints"
        ],
        "spread": false,
        "optional": true,
        "name": "constraints",
        "description": "The stream constraints.\nIf not defined, the constraints defined in {@link Config} will be used."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local, Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "getLocalVideo",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#getLocalVideo",
    "access": "public",
    "description": "get a local stream in video tag",
    "lineNumber": 295,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Local, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The stream type, see {@link StreamTypes} for possible values"
      },
      {
        "nullable": null,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": true,
        "name": "localStreamContainer",
        "description": "The element the stream is attached to.\nCan be null if already specified in {@link Config}."
      },
      {
        "nullable": null,
        "types": [
          "MediaStreamConstraints"
        ],
        "spread": false,
        "optional": true,
        "name": "constraints",
        "description": "The stream constraints.\nIf not defined, the constraints defined in {@link Config} will be used."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local, Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "publish",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#publish",
    "access": "public",
    "description": "publish a local stream",
    "lineNumber": 308,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Local}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Local"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "join",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#join",
    "access": "public",
    "description": "Join the room. Sets the connected status of the current participant to CONNECTED.",
    "lineNumber": 317,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "leave",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#leave",
    "access": "public",
    "description": "Leave the room. Sets the connected status of the current participant to WAS_CONNECTED,\ndeletes medias and callbacks, closes WebRTC stacks in use.",
    "lineNumber": 330,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "close",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/Room.js~Room#close",
    "access": "public",
    "description": "Leaves & close the Room. Only the owner/moderator can close a room.",
    "lineNumber": 359,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "create",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Room.js~Room.create",
    "access": "protected",
    "description": "Create a room",
    "lineNumber": 376,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Room, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "name",
        "description": "The room name"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "extra",
        "description": "Extra informations"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "publicRoom",
        "description": "Indicates public room"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Room, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "get",
    "memberof": "src/core/Room.js~Room",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/Room.js~Room.get",
    "access": "protected",
    "description": "Get a {@link Room} from its `uid`",
    "lineNumber": 415,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Room>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "uid",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Room>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 184,
    "kind": "file",
    "name": "src/core/User.js",
    "content": "import Webcom from 'webcom/webcom';\nimport * as DataSync from './util/DataSync';\nimport cache from './util/cache';\nimport * as Log from './util/Log';\nimport Room from './Room';\nimport Device from './Device';\nimport { CONNECTED, NOT_CONNECTED } from './util/constants';\n\nlet initializing = false;\n\n/**\n * User informations\n * @public\n */\nexport default class User {\n  /**\n   * Create a user\n   * @param {Webcom/api.DataSnapshot|object} snapData The data snapshot\n   * @access protected\n   */\n  constructor(snapData, userId) {\n    const values = Object.assign({}, snapData.val());\n    /**\n     * User's unique id\n     * @type {string}\n     */\n    // this.uid = snapData.name();\n    this.uid = userId;\n    /**\n     * User's display name\n     * @type {string}\n     */\n    this.name = values.name;\n    /**\n     * User's status\n     * @type {string}\n     */\n    this.status = values.status;\n    /**\n     * User's last know connection ts\n     * @type {number}\n     */\n    this.lastSeen = values.lastSeen;\n    /**\n     * Indicates if the user is an anonymous user\n     * @type {boolean}\n     */\n    this.anonymous = /^anonymous/.test(values.provider);\n    // TODO #Feat: Add 'extra' property for unrestricted additional information ?\n  }\n\n  /**\n   * Invite a user directly. This will create a new Room, log you in it & invite the user.\n   * @param {string} [message] a message to add to the invite\n   * @return {Promise<{room: Room, invite: Invite}, Error>}\n   */\n  invite(message) {\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can invite another User.'));\n    }\n    return Room.create(`${cache.user.uid}-${this.uid}`)\n      .then(room => room.invite([this], null, message))\n      .then(data => ({ room: data.room, invite: data.invites[0] }))\n      .catch(Log.r('User~invite'));\n  }\n\n  /**\n   * List Users's devices. Only for current user.\n   * @access protected\n   * @return {Promise<Device[], Error>}\n   */\n  devices() {\n    return DataSync.list(`_/devices/${this.uid}`, Device);\n  }\n\n  /**\n   * Init the current user\n   * @access protected\n   * @param {json} auth The user's identity (webcom JSON structure)\n   * @param {string} [name] The user's display name\n   * @returns {Promise<User, Error>}\n   */\n  static init(auth, name) {\n    const id1 = Math.floor(Math.random() * 1000);\n    const id2 = Math.floor(Math.random() * 1000);\n    const uid = `${id1}/${id2}/${auth.uid}`;\n    const userUid = `${id1}:${id2}:${auth.uid}`;\n    // const uid = auth.uid;\n    if (!initializing) {\n      initializing = true;\n      const d = { status: CONNECTED, lastSeen: DataSync.ts(), provider: auth.provider };\n      if (name) {\n        Object.assign(d, { name });\n      }\n      let deviceId = Webcom.INTERNAL.PersistentStorage.get(uid);\n      return DataSync.update(`users/${uid}`, d)\n      // Register current device\n        .then(() => {\n          const deviceMetadata = {\n            status: CONNECTED,\n            sdk: {\n              reach: SDK_VERSION, // eslint-disable-line no-undef\n              webcom: Webcom.SDK_VERSION\n            },\n            userAgent: navigator.userAgent\n          };\n          cache.userAgent = deviceMetadata.userAgent;\n          if (deviceId) {\n            return DataSync.update(`_/devices/${uid}/${deviceId}`, deviceMetadata);\n          }\n          return DataSync.push(`_/devices/${uid}`, deviceMetadata);\n        })\n        // Save device\n        .then((deviceRef) => {\n          if (!deviceId) {\n            deviceId = deviceRef.name();\n            Webcom.INTERNAL.PersistentStorage.set(uid, deviceId);\n          }\n          cache.device = deviceId;\n        })\n        // Add onDisconnect actions\n        .then(() => {\n          // Disconnect device\n          DataSync.onDisconnect(`_/devices/${uid}/${deviceId}/status`).set(NOT_CONNECTED);\n          // Update user status\n          DataSync.onDisconnect(`users/${uid}`).update({\n            status: NOT_CONNECTED,\n            lastSeen: DataSync.ts()\n          });\n        })\n        // Get user\n        // .then(() => User.get(uid))\n        .then(() => User.get(userUid))\n        .then((user) => {\n          initializing = false;\n          return user;\n        })\n        .catch((e) => {\n          Log.e(e);\n          initializing = false;\n          return Promise.reject(e);\n        });\n    }\n    // return User.get(uid);\n    return User.get(userUid);\n  }\n\n  /**\n   * Disconnect the current user\n   * @access protected\n   * @param {User} user The current user\n   * @returns {Promise}\n   */\n  static disconnect(user) {\n    // Cancel onDisconnect\n    // due to the problem of long list, uids have a : instead of /\n    const userUid = user.uid.replace(/:/g, '/');\n    // DataSync.onDisconnect(`_/devices/${user.uid}/${cache.device}/status`).cancel();\n    // DataSync.onDisconnect(`users/${user.uid}`).cancel();\n    DataSync.onDisconnect(`_/devices/${userUid}/${cache.device}/status`).cancel();\n    DataSync.onDisconnect(`users/${userUid}`).cancel();\n    if (user.anonymous) {\n      return DataSync.remove(`_/devices/${userUid}`)\n        .then(() => DataSync.get(`_/invites/${userUid}`))\n        .then((invites) => {\n          const inviteIds = [];\n          invites.forEach((invite) => {\n            inviteIds.push(invite.name());\n          });\n          return Promise.all(inviteIds.map(inviteId => DataSync.remove(`_/invites/${userUid}/${inviteId}`)));\n        })\n        // TODO refactor data model for invites so we can delete _/invites/${user.uid}\n        // .then(() => DataSync.remove(`_/invites/${user.uid}`))\n        .then(() => DataSync.remove(`users/${userUid}`))\n        .then(() => {\n          Webcom.INTERNAL.PersistentStorage.remove(userUid);\n        })\n        .catch(Log.r('User#anonymous_disconnect'));\n    }\n    return DataSync.set(`_/devices/${userUid}/${cache.device}/status`, NOT_CONNECTED)\n      .then(() => DataSync.get(`_/devices/${userUid}`))\n      .then((devices) => {\n        // Only change user's status if no other device connected\n        const hasConnectedDevices = devices.forEach(device => (\n          new RegExp(`^${CONNECTED}$`)\n        ).test(device.val().status));\n\n        if (!hasConnectedDevices) {\n          return DataSync.update(`users/${userUid}`, { status: NOT_CONNECTED });\n        }\n        return true;\n      })\n      .catch(Log.r('User#disconnect'));\n  }\n\n  /**\n   * Get a user by its uid\n   * @access private\n   * @param {string} uid The user's uid\n   * @returns {Promise<User, Error>}\n   */\n  static get(uid) {\n    // due to the problem of long list, uids have a : instead of /\n    const userUid = uid.replace(/:/g, '/');\n    return DataSync.get(`users/${userUid}`)\n      // .then(snapData => snapData ? new User(snapData, newUid) : null)\n      .then(snapData => (snapData ? new User(snapData, uid) : null))\n      .catch(Log.r('User#get'));\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/User.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 185,
    "kind": "variable",
    "name": "initializing",
    "memberof": "src/core/User.js",
    "static": true,
    "longname": "src/core/User.js~initializing",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/User.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 186,
    "kind": "class",
    "name": "User",
    "memberof": "src/core/User.js",
    "static": true,
    "longname": "src/core/User.js~User",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/User.js",
    "importStyle": "User",
    "description": "User informations",
    "lineNumber": 15,
    "interface": false
  },
  {
    "__docId__": 187,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/User.js~User",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/User.js~User#constructor",
    "access": "protected",
    "description": "Create a user",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Webcom/api.DataSnapshot",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "snapData",
        "description": "The data snapshot"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/User.js~User",
    "static": false,
    "longname": "src/core/User.js~User#uid",
    "access": "public",
    "description": "User's unique id",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "name",
    "memberof": "src/core/User.js~User",
    "static": false,
    "longname": "src/core/User.js~User#name",
    "access": "public",
    "description": "User's display name",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "status",
    "memberof": "src/core/User.js~User",
    "static": false,
    "longname": "src/core/User.js~User#status",
    "access": "public",
    "description": "User's status",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "lastSeen",
    "memberof": "src/core/User.js~User",
    "static": false,
    "longname": "src/core/User.js~User#lastSeen",
    "access": "public",
    "description": "User's last know connection ts",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "anonymous",
    "memberof": "src/core/User.js~User",
    "static": false,
    "longname": "src/core/User.js~User#anonymous",
    "access": "public",
    "description": "Indicates if the user is an anonymous user",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "invite",
    "memberof": "src/core/User.js~User",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/User.js~User#invite",
    "access": "public",
    "description": "Invite a user directly. This will create a new Room, log you in it & invite the user.",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "message",
        "description": "a message to add to the invite"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{room: Room, invite: Invite}, Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "devices",
    "memberof": "src/core/User.js~User",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/User.js~User#devices",
    "access": "protected",
    "description": "List Users's devices. Only for current user.",
    "lineNumber": 72,
    "return": {
      "nullable": null,
      "types": [
        "Promise<Device[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "init",
    "memberof": "src/core/User.js~User",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/User.js~User.init",
    "access": "protected",
    "description": "Init the current user",
    "lineNumber": 83,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<User, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "json"
        ],
        "spread": false,
        "optional": false,
        "name": "auth",
        "description": "The user's identity (webcom JSON structure)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "name",
        "description": "The user's display name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<User, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/core/User.js~User",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/User.js~User.disconnect",
    "access": "protected",
    "description": "Disconnect the current user",
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "User"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "The current user"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "get",
    "memberof": "src/core/User.js~User",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/User.js~User.get",
    "access": "private",
    "description": "Get a user by its uid",
    "lineNumber": 202,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<User, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uid",
        "description": "The user's uid"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<User, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 198,
    "kind": "file",
    "name": "src/core/stream/Local.js",
    "content": "import * as StreamTypes from '../../definitions/StreamTypes';\nimport * as Log from '../util/Log';\nimport cache from '../util/cache';\nimport * as DataSync from '../util/DataSync';\nimport Media from '../util/Media';\nimport {\n  CLOSED,\n  CLOSING,\n  CONNECTED,\n  NONE\n} from '../util/constants';\n\nconst _facingModes = [Media.facingMode.USER, Media.facingMode.ENVIRONMENT];\n\nconst _getConstraintValue = (constraints, prop) => (\n  constraints[prop].exact || constraints[prop].ideal || constraints[prop]\n);\n\n/* eslint-disable no-param-reassign */\nconst _setConstrainValue = (constraints, prop, other, value) => {\n  constraints[prop] = { exact: value };\n  delete constraints[other];\n};\n/* eslint-enable no-param-reassign */\n\n/**\n * The local stream\n */\nexport default class Local {\n  /**\n   * @access protected\n   * @param {object} values\n   */\n  constructor(values) {\n    /**\n     * The uid of the room the stream is published in\n     * @type {string}\n     */\n    this.roomId = values.roomId;\n    /**\n     * The uid of this stream\n     * @type {string}\n     */\n    this.uid = values.uid;\n    /**\n     * The type of the stream\n     * @type {string}\n     */\n    this.type = values.type;\n    /**\n     * Indicates if a track is muted\n     * @type {{audio: boolean, video: boolean}}\n     */\n    this.muted = Object.assign({ audio: false, video: false }, values.muted);\n    /**\n     * The local DOM container element where the {@link Local~media} is displayed\n     * @type {Element}\n     */\n    this.container = values.container || cache.config.localStreamContainer;\n    /**\n     * The local DOM media element where the {@link Local~media} is displayed\n     * @type {Element}\n     */\n    this.node = null;\n    /**\n     * List of the PeerConnections associated to this local stream\n     * @type {PeerConnection[]}\n     */\n    this.peerConnections = [];\n    /**\n     * Local stream status\n     * @type {string}\n     */\n    this.status = NONE;\n    /**\n     * is the video is loaded int the local DOM media element\n     * @type {boolean}\n     */\n    this.isVideoLoaded = false;\n    /**\n     * @access private\n     * @type {{audio: string, video: string}}\n     */\n    this._inputs = {};\n\n    // Set constraints\n    this.constraints = values.constraints;\n  }\n\n  /**\n   * The Media Constraints. (defaults to global config)\n   * @param {MediaConstraints} constraints\n   */\n  set constraints(constraints) {\n    const\n      values = constraints || cache.config.constraints;\n\n\n    const defaultConstraints = Media.constraints();\n    ['audio', 'video'].forEach((type) => {\n      if (!~this.type.indexOf(type)) { // eslint-disable-line no-bitwise\n        values[type] = false;\n      } else if (!values[type]) {\n        values[type] = defaultConstraints[type];\n      }\n      if (values[type].deviceId || values[type].facingMode) {\n        this._inputs[type] = _getConstraintValue(\n          values[type],\n          values[type].facingMode ? 'facingMode' : 'deviceId'\n        );\n      }\n    });\n    Log.d('Local~set#contraints', values);\n    /**\n     * @ignore\n     */\n    this._constraints = values;\n  }\n\n  /**\n   * The Media Constraints. (defaults to global config)\n   * @type {MediaConstraints}\n   */\n  get constraints() {\n    return this._constraints;\n  }\n\n  /**\n   * Updates the stream constraints and retrieve the new MediaStream\n   * @param constraints\n   * @returns {*|Promise.<TResult>}\n   */\n  updateConstraints(constraints) {\n    Log.d('Local~updateConstraints', constraints);\n    this.constraints = constraints;\n    return navigator.mediaDevices.getUserMedia(this.constraints)\n      .then((media) => {\n        ['audio', 'video'].forEach((kind) => {\n          const constraintsValue = this.constraints[kind];\n          if (constraintsValue) {\n            if (constraintsValue.deviceId || constraintsValue.facingMode) {\n              this._inputs[kind] = _getConstraintValue(\n                constraintsValue,\n                constraintsValue.facingMode ? 'facingMode' : 'deviceId'\n              );\n            }\n          }\n        });\n        this.media = media;\n      });\n  }\n\n  /**\n   * The associated MediaStream\n   * @type {MediaStream}\n   */\n  set media(mediaStream) {\n    if (mediaStream) {\n      if (!(mediaStream instanceof MediaStream)) {\n        throw new Error('The media MUST be a MediaStream');\n      }\n\n      const checkDevices = {};\n      mediaStream.getTracks().forEach((track) => {\n        // Reset mute\n        track.enabled = !this.muted[track.kind]; // eslint-disable-line no-param-reassign\n        // Get device label\n        if (!this._inputs[track.kind]) {\n          checkDevices[track.kind] = track.label;\n        }\n      });\n      // Try to get deviceId from label\n      if (Object.keys(checkDevices).length) {\n        Media.devices().then((devices) => {\n          Object.keys(checkDevices).forEach((kind) => {\n            if (devices[`${kind}input`]) {\n              const deviceIds = devices[`${kind}input`]\n                .filter(device => device.label.length && device.label === checkDevices[kind]);\n              if (deviceIds.length === 1 && !this._inputs[kind]) {\n                this._inputs[kind] = deviceIds[0].deviceId;\n              }\n              if (deviceIds.length === 0\n                && devices[`${kind}input`][0].label === ''\n                && !this._inputs[kind]) {\n                // from a webview, the label is not delivered\n                this._inputs[kind] = devices[`${kind}input`][0].deviceId;\n              }\n            }\n          });\n        });\n      }\n      // Display\n      this.node = Media.attachStream(mediaStream, this.container, this.node, 0);\n      this.node.onloadeddata = () => {\n        this.isVideoLoaded = true;\n      };\n      this.status = CONNECTED;\n      Log.d('Local~set media', { mediaStream }, this.node);\n      // Renegotiate\n      this.peerConnections.forEach(peerConnection => peerConnection.renegotiate(this._media,\n        mediaStream));\n    } else if (this.media && !mediaStream) {\n      // Remove node\n      this.node.srcObject = null;\n      this.container.removeChild(this.node);\n      this.node = null;\n      // Stop stream\n      this.media.getTracks().forEach(track => track.stop());\n      // Close PeerConnections\n      this.peerConnections.forEach(peerConnection => peerConnection.close());\n    }\n    // Save\n    /**\n     * @ignore\n     */\n    this._media = mediaStream;\n  }\n\n  /**\n   * The associated MediaStream\n   * @type {MediaStream}\n   */\n  get media() {\n    return this._media;\n  }\n\n  /**\n   * Mute a track of a Stream\n   * @param {string} [track=AUDIO] The track to mute. (AUDIO, VIDEO, AUDIO_VIDEO)\n   * @param {boolean} [state=true] true for mute & false for un-mute\n   * @example <caption>mute video</caption>\n   * stream.mute(Reach.t.VIDEO)\n   * @example <caption>mute audio</caption>\n   * stream.mute(Reach.t.AUDIO)\n   * // or\n   * stream.mute()\n   */\n  mute(track = StreamTypes.AUDIO, state = true) {\n    Log.d('mute', track, state);\n    let { audio, video } = this.muted;\n    let\n      tracks;\n    switch (track) {\n      case StreamTypes.AUDIO:\n        audio = state;\n        tracks = this.media.getAudioTracks();\n        break;\n      case StreamTypes.VIDEO:\n      case StreamTypes.SCREEN_SHARING:\n        video = state;\n        tracks = this.media.getVideoTracks();\n        break;\n      case StreamTypes.AUDIO_VIDEO:\n        audio = state;\n        video = state;\n        tracks = this.media.getTracks();\n        break;\n      default:\n        break;\n    }\n    // Mute media tracks\n    tracks.forEach((track) => { // eslint-disable-line no-shadow\n      track.enabled = !state; // eslint-disable-line no-param-reassign\n    });\n    // Signal subscribers\n    this.muted = { audio, video };\n    DataSync.set(`_/rooms/${this.roomId}/streams/${this.uid}/muted`, this.muted);\n  }\n\n  /**\n   * Un-mute a track of a Stream\n   * @param {string} [track=AUDIO] The track to mute. (AUDIO, VIDEO, AUDIO_VIDEO)\n   * @example <caption>Un-mute video</caption>\n   * stream.unMute(Reach.t.VIDEO)\n   * @example <caption>Un-mute audio</caption>\n   * stream.unMute(Reach.t.AUDIO)\n   * // or\n   * stream.unMute()\n   */\n  unMute(track) {\n    this.mute(track, false);\n  }\n\n  /**\n   * Removes stream for published list, closes associated\n   * PeerConnections and stops current MediaStream\n   * @returns {Promise}\n   */\n  close() {\n    if (!~[CLOSED, CLOSING].indexOf(this.status)) { // eslint-disable-line no-bitwise\n      this.status = CLOSING;\n      // Stop listening to Subscribers\n      const path = `_/rooms/${this.roomId}/subscribers/${this.uid}`;\n      DataSync.off(path, 'child_added');\n      DataSync.off(path, 'child_removed');\n      // Cancel onDisconnects\n      DataSync.onDisconnect(`_/rooms/${this.roomId}/streams/${this.uid}`).cancel();\n      DataSync.onDisconnect(`_/rooms/${this.roomId}/subscribers/${this.uid}`).cancel();\n      // Remove subscribers\n      DataSync.remove(path);\n      // Remove stream\n      DataSync.remove(`_/rooms/${this.roomId}/streams/${this.uid}`);\n      this.media = null;\n      // Close\n      this.status = CLOSED;\n    }\n    return Promise.resolve(this.status);\n  }\n\n  /**\n   * Switch video input device\n   * @param {string} [deviceId] A video input device Id or the `facingMode` value\n   * @returns {Promise<Local, Error>}\n   */\n  switchCamera(deviceId) {\n    return this._switchDevice(StreamTypes.VIDEO, deviceId);\n  }\n\n  /**\n   * Switch audio input device\n   * @param {string} [deviceId] A audio input device Id\n   * @returns {Promise<Local, Error>}\n   */\n  switchMicrophone(deviceId) {\n    return this._switchDevice(StreamTypes.AUDIO, deviceId);\n  }\n\n  /**\n   * Switch input device\n   * @access private\n   * @param {string} kind The kind of device to switch\n   * @param {string} [deviceId] An input device id\n   * @returns {Promise<Local, Error>}\n   */\n  _switchDevice(kind, deviceId) {\n    Log.d('Local~_switchDevice', kind, deviceId);\n    if (this.media.getTracks().some(track => track.kind === kind)) {\n      let next = Promise.resolve(deviceId);\n      const currentModeIdx = _facingModes.indexOf(this._inputs[kind]);\n      if (!deviceId && !!~currentModeIdx) { // eslint-disable-line no-bitwise\n        // Loop facingModes\n        next = Promise.resolve(_facingModes[(currentModeIdx + 1) % _facingModes.length]);\n      } else if (!~_facingModes.indexOf(deviceId)) { // eslint-disable-line no-bitwise\n        // Loop deviceIds\n        next = Media.devices()\n          .then((d) => {\n            // devices IDs\n            const devices = d[`${kind}input`].map(mediaDevice => mediaDevice.deviceId);\n            // Sort to ensure same order\n            devices.sort();\n            // New device\n            let nextDevice = deviceId;\n            if (deviceId && !devices.some(device => device === deviceId)) {\n              return Promise.reject(new Error(`Unknown ${kind} device`));\n            }\n            if (!deviceId && devices.length > 1) {\n              let idx = this._inputs[kind]\n                ? devices.findIndex(v => v === this._inputs[kind], this)\n                : 0;\n              nextDevice = devices[++idx % devices.length]; // eslint-disable-line no-plusplus\n            }\n            return nextDevice;\n          });\n      } else {\n        next = Promise.resolve(deviceId);\n      }\n\n      return next\n        .then((device) => { // eslint-disable-line consistent-return\n          if (this._inputs[kind] !== device) {\n            // Update video streams\n            this._inputs[kind] = device;\n            // Stop tracks\n            this.media.getTracks().forEach(track => track.stop());\n            // Update constraints\n            const constraints = Object.assign({}, this.constraints);\n            let props = ['facingMode', 'deviceId'];\n            if (!~_facingModes.indexOf(device)) { // eslint-disable-line no-bitwise\n              props = props.reverse();\n            }\n            _setConstrainValue(constraints[kind], props[0], props[1], device);\n            Log.d('Local~_switchDevice', kind, constraints);\n            return this.updateConstraints(constraints);\n          }\n        })\n        .then(() => this);\n    }\n    return Promise.reject(new Error(`Current stream does not contain a ${kind} track`));\n  }\n\n  /**\n   * Publish a local stream\n   * @access protected\n   * @param {string} roomId The room Id\n   * @param {string} type The stream type, see {@link StreamTypes} for possible values\n   * @param {?Element} container The element the stream is attached to.\n   * @param {?MediaStreamConstraints} [constraints] The stream constraints.\n   * If not defined the constraints defined in ReachConfig will be used.\n   * @returns {Promise<Local, Error>}\n   */\n  static share(roomId, type, container, constraints) {\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can share a stream.'));\n    }\n    const streamMetaData = {\n      from: cache.user.uid,\n      device: cache.device,\n      type\n    };\n\n\n    const sharedStream = new Local(Object.assign({ roomId, constraints, container },\n      streamMetaData));\n    Log.d('Local~share', { sharedStream });\n    return navigator.mediaDevices.getUserMedia(sharedStream.constraints)\n      .then((media) => {\n        sharedStream.media = media;\n      })\n      // Got MediaStream, publish it\n      .then(() => DataSync.push(`_/rooms/${roomId}/streams`, streamMetaData))\n      .then((streamRef) => {\n        sharedStream.uid = streamRef.name();\n        if (/video/i.test(sharedStream.type)) {\n          if (sharedStream.isVideoLoaded) {\n            const streamSize = {\n              height: sharedStream.node.videoHeight,\n              width: sharedStream.node.videoWidth,\n            };\n            streamRef.update(streamSize);\n          } else {\n            sharedStream.node.onloadeddata = function () { // eslint-disable-line func-names\n              const streamSize = {\n                height: sharedStream.node.videoHeight,\n                width: sharedStream.node.videoWidth,\n              };\n              streamRef.update(streamSize);\n            };\n          }\n        }\n        if (/video/i.test(sharedStream.type)) {\n          window.addEventListener('resize', (() => {\n            if (sharedStream.node != null) {\n              const streamSize = {\n                height: sharedStream.node.videoHeight,\n                width: sharedStream.node.videoWidth,\n              };\n              streamRef.update(streamSize);\n            }\n          }));\n        }\n        // Save sharedStream\n        cache.streams.shared[sharedStream.uid] = sharedStream;\n        // Remove shared stream on Disconnect\n        DataSync.onDisconnect(`_/rooms/${roomId}/streams/${sharedStream.uid}`).remove();\n        // Remove shared stream on Disconnect\n        DataSync.onDisconnect(`_/rooms/${roomId}/subscribers/${sharedStream.uid}`).remove();\n        // Start listening to subscribers\n        const\n          path = `_/rooms/${sharedStream.roomId}/subscribers/${sharedStream.uid}`;\n\n\n        const value = snapData => Object.assign({ device: snapData.name() }, snapData.val() || {});\n        DataSync.on(path, 'child_added',\n          (snapData) => {\n            const subscriber = value(snapData);\n            Log.d('Local~subscribed', subscriber);\n            cache.peerConnections.offer(sharedStream, subscriber)\n              .then(pc => sharedStream.peerConnections.push(pc));\n          },\n          Log.e.bind(Log));\n        DataSync.on(path, 'child_removed',\n          (snapData) => {\n            const subscriber = value(snapData);\n            Log.d('Local~un-subscribed', subscriber);\n            const closedPC = cache.peerConnections.close(sharedStream.uid, subscriber.device);\n            sharedStream.peerConnections = sharedStream.peerConnections\n              .filter(pc => pc !== closedPC);\n          },\n          Log.e.bind(Log));\n        Log.d('Local~shared', { sharedStream });\n        return sharedStream;\n      });\n  }\n\n  /**\n   * Get a local stream\n   * @access protected\n   * @param {string} roomId The room Id\n   * @param {string} type The stream type, see {@link StreamTypes} for possible values\n   * @param {?Element} container The element the stream is attached to.\n   * @param {?MediaStreamConstraints} [constraints] The stream constraints.\n   * If not defined the constraints defined in ReachConfig will be used.\n   * @returns {Promise<Local, Error>}\n   */\n  static getLocalVideo(roomId, type, container, constraints) {\n    if (!cache.user) {\n      return Promise.reject(new Error('Only an authenticated user can share a stream.'));\n    }\n    const streamMetaData = {\n      from: cache.user.uid,\n      device: cache.device,\n      userAgent: cache.userAgent,\n      type\n    };\n\n\n    const sharedStream = new Local(Object.assign({ roomId, constraints, container },\n      streamMetaData));\n    sharedStream.streamMetaData = streamMetaData;\n    Log.d('Local~getLocalVideo', { sharedStream });\n    return navigator.mediaDevices.getUserMedia(sharedStream.constraints)\n      .then((media) => {\n        sharedStream.media = media;\n        return sharedStream;\n      });\n  }\n\n  /**\n   * Publish a local stream\n   * @access protected\n   * @returns {Local}\n   */\n  static publish(sharedStream) {\n    Log.d('Local~publish');\n    const { roomId } = sharedStream;\n    return DataSync.push(`_/rooms/${roomId}/streams`, sharedStream.streamMetaData)\n      .then((streamRef) => {\n        sharedStream.uid = streamRef.name(); // eslint-disable-line no-param-reassign\n        if (sharedStream.isVideoLoaded) {\n          const streamSize = {\n            height: sharedStream.node.videoHeight,\n            width: sharedStream.node.videoWidth,\n          };\n          streamRef.update(streamSize);\n        } else {\n          sharedStream.node.onloadeddata = function () { // eslint-disable-line\n            const streamSize = {\n              height: sharedStream.node.videoHeight,\n              width: sharedStream.node.videoWidth,\n            };\n            streamRef.update(streamSize);\n          };\n        }\n        window.addEventListener('resize', (() => {\n          if (sharedStream.node != null) {\n            const streamSize = {\n              height: sharedStream.node.videoHeight,\n              width: sharedStream.node.videoWidth,\n            };\n            streamRef.update(streamSize);\n          }\n        }));\n        // Save sharedStream\n        cache.streams.shared[sharedStream.uid] = sharedStream;\n        // Remove shared stream on Disconnect\n        DataSync.onDisconnect(`_/rooms/${roomId}/streams/${sharedStream.uid}`).remove();\n        // Remove shared stream on Disconnect\n        DataSync.onDisconnect(`_/rooms/${roomId}/subscribers/${sharedStream.uid}`).remove();\n        // Start listening to subscribers\n        const\n          path = `_/rooms/${sharedStream.roomId}/subscribers/${sharedStream.uid}`;\n\n\n        const value = snapData => Object.assign({ device: snapData.name() }, snapData.val() || {});\n        DataSync.on(path, 'child_added',\n          (snapData) => {\n            const subscriber = value(snapData);\n            Log.d('Local~subscribed', subscriber);\n            cache.peerConnections.offer(sharedStream, subscriber)\n              .then(pc => sharedStream.peerConnections.push(pc));\n          },\n          Log.e.bind(Log));\n        DataSync.on(path, 'child_removed',\n          (snapData) => {\n            const subscriber = value(snapData);\n            Log.d('Local~un-subscribed', subscriber);\n            const closedPC = cache.peerConnections.close(sharedStream.uid, subscriber.device);\n            /* eslint-disable no-param-reassign */\n            sharedStream.peerConnections = sharedStream.peerConnections\n              .filter(pc => pc !== closedPC);\n            /* eslint-enable no-param-reassign */\n          },\n          Log.e.bind(Log));\n        Log.d('Local~shared', { sharedStream });\n        return sharedStream;\n      });\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/stream/Local.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "name": "_facingModes",
    "memberof": "src/core/stream/Local.js",
    "static": true,
    "longname": "src/core/stream/Local.js~_facingModes",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/stream/Local.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "function",
    "name": "_getConstraintValue",
    "memberof": "src/core/stream/Local.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/stream/Local.js~_getConstraintValue",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/stream/Local.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "constraints",
        "types": [
          "*"
        ]
      },
      {
        "name": "prop",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 201,
    "kind": "function",
    "name": "_setConstrainValue",
    "memberof": "src/core/stream/Local.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/stream/Local.js~_setConstrainValue",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/stream/Local.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "constraints",
        "types": [
          "*"
        ]
      },
      {
        "name": "prop",
        "types": [
          "*"
        ]
      },
      {
        "name": "other",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 202,
    "kind": "class",
    "name": "Local",
    "memberof": "src/core/stream/Local.js",
    "static": true,
    "longname": "src/core/stream/Local.js~Local",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/stream/Local.js",
    "importStyle": "Local",
    "description": "The local stream",
    "lineNumber": 29,
    "interface": false
  },
  {
    "__docId__": 203,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#constructor",
    "access": "protected",
    "description": "",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "member",
    "name": "roomId",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#roomId",
    "access": "public",
    "description": "The uid of the room the stream is published in",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#uid",
    "access": "public",
    "description": "The uid of this stream",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 206,
    "kind": "member",
    "name": "type",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#type",
    "access": "public",
    "description": "The type of the stream",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 207,
    "kind": "member",
    "name": "muted",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#muted",
    "access": "public",
    "description": "Indicates if a track is muted",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "{audio: boolean, video: boolean}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 208,
    "kind": "member",
    "name": "container",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#container",
    "access": "public",
    "description": "The local DOM container element where the {@link Local~media} is displayed",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "Element"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "node",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#node",
    "access": "public",
    "description": "The local DOM media element where the {@link Local~media} is displayed",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Element"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "peerConnections",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#peerConnections",
    "access": "public",
    "description": "List of the PeerConnections associated to this local stream",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "PeerConnection[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 211,
    "kind": "member",
    "name": "status",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#status",
    "access": "public",
    "description": "Local stream status",
    "lineNumber": 74,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 212,
    "kind": "member",
    "name": "isVideoLoaded",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#isVideoLoaded",
    "access": "public",
    "description": "is the video is loaded int the local DOM media element",
    "lineNumber": 79,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 213,
    "kind": "member",
    "name": "_inputs",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#_inputs",
    "access": "private",
    "description": "",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "{audio: string, video: string}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "set",
    "name": "constraints",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#constraints",
    "access": "public",
    "description": "The Media Constraints. (defaults to global config)",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaConstraints"
        ],
        "spread": false,
        "optional": false,
        "name": "constraints",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "_constraints",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#_constraints",
    "access": "private",
    "description": "",
    "lineNumber": 117,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "get",
    "name": "constraints",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#constraints",
    "access": "public",
    "description": "The Media Constraints. (defaults to global config)",
    "lineNumber": 124,
    "type": {
      "nullable": null,
      "types": [
        "MediaConstraints"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "updateConstraints",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#updateConstraints",
    "access": "public",
    "description": "Updates the stream constraints and retrieve the new MediaStream",
    "lineNumber": 133,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*|Promise.<TResult>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "constraints",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*",
        "Promise.<TResult>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 221,
    "kind": "set",
    "name": "media",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#media",
    "access": "public",
    "description": "The associated MediaStream",
    "lineNumber": 157,
    "type": {
      "nullable": null,
      "types": [
        "MediaStream"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 226,
    "kind": "member",
    "name": "_media",
    "memberof": "src/core/stream/Local.js~Local",
    "static": false,
    "longname": "src/core/stream/Local.js~Local#_media",
    "access": "private",
    "description": "",
    "lineNumber": 216,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "get",
    "name": "media",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#media",
    "access": "public",
    "description": "The associated MediaStream",
    "lineNumber": 223,
    "type": {
      "nullable": null,
      "types": [
        "MediaStream"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "mute",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#mute",
    "access": "public",
    "description": "Mute a track of a Stream",
    "examples": [
      "<caption>mute video</caption>\nstream.mute(Reach.t.VIDEO)",
      "<caption>mute audio</caption>\nstream.mute(Reach.t.AUDIO)\n// or\nstream.mute()"
    ],
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "AUDIO",
        "defaultRaw": "AUDIO",
        "name": "track",
        "description": "The track to mute. (AUDIO, VIDEO, AUDIO_VIDEO)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "state",
        "description": "true for mute & false for un-mute"
      }
    ],
    "return": null
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "unMute",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#unMute",
    "access": "public",
    "description": "Un-mute a track of a Stream",
    "examples": [
      "<caption>Un-mute video</caption>\nstream.unMute(Reach.t.VIDEO)",
      "<caption>Un-mute audio</caption>\nstream.unMute(Reach.t.AUDIO)\n// or\nstream.unMute()"
    ],
    "lineNumber": 280,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "AUDIO",
        "defaultRaw": "AUDIO",
        "name": "track",
        "description": "The track to mute. (AUDIO, VIDEO, AUDIO_VIDEO)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "close",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#close",
    "access": "public",
    "description": "Removes stream for published list, closes associated\nPeerConnections and stops current MediaStream",
    "lineNumber": 289,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "switchCamera",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#switchCamera",
    "access": "public",
    "description": "Switch video input device",
    "lineNumber": 315,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Local, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "deviceId",
        "description": "A video input device Id or the `facingMode` value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local, Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "switchMicrophone",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#switchMicrophone",
    "access": "public",
    "description": "Switch audio input device",
    "lineNumber": 324,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Local, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "deviceId",
        "description": "A audio input device Id"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local, Error>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "_switchDevice",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Local.js~Local#_switchDevice",
    "access": "private",
    "description": "Switch input device",
    "lineNumber": 335,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Local, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "kind",
        "description": "The kind of device to switch"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "deviceId",
        "description": "An input device id"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "share",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/stream/Local.js~Local.share",
    "access": "protected",
    "description": "Publish a local stream",
    "lineNumber": 401,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Local, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "roomId",
        "description": "The room Id"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The stream type, see {@link StreamTypes} for possible values"
      },
      {
        "nullable": true,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": false,
        "name": "container",
        "description": "The element the stream is attached to."
      },
      {
        "nullable": true,
        "types": [
          "MediaStreamConstraints"
        ],
        "spread": false,
        "optional": true,
        "name": "constraints",
        "description": "The stream constraints.\nIf not defined the constraints defined in ReachConfig will be used."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "getLocalVideo",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/stream/Local.js~Local.getLocalVideo",
    "access": "protected",
    "description": "Get a local stream",
    "lineNumber": 495,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Local, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "roomId",
        "description": "The room Id"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The stream type, see {@link StreamTypes} for possible values"
      },
      {
        "nullable": true,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": false,
        "name": "container",
        "description": "The element the stream is attached to."
      },
      {
        "nullable": true,
        "types": [
          "MediaStreamConstraints"
        ],
        "spread": false,
        "optional": true,
        "name": "constraints",
        "description": "The stream constraints.\nIf not defined the constraints defined in ReachConfig will be used."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Local, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "publish",
    "memberof": "src/core/stream/Local.js~Local",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/stream/Local.js~Local.publish",
    "access": "protected",
    "description": "Publish a local stream",
    "lineNumber": 523,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Local}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Local"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": [
      {
        "name": "sharedStream",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "src/core/stream/Remote.js",
    "content": "import cache from '../util/cache';\nimport * as DataSync from '../util/DataSync';\nimport * as Log from '../util/Log';\nimport * as Events from '../../definitions/Events';\n\n/**\n * A published Stream\n * @public\n */\nexport default class Remote {\n  /**\n   * @access protected\n   * @param {object} values\n   */\n  constructor(values) {\n    Log.d('Remote~new', values);\n    /**\n     * The uid of the room the stream is published in\n     * @type {string}\n     */\n    this.roomId = values.roomId;\n    /**\n     * The uid of this stream\n     * @type {string}\n     */\n    this.uid = values.uid;\n    /**\n     * The uid of the publisher of the stream\n     * @type {string}\n     */\n    this.from = values.from;\n    /**\n     * The type of the stream\n     * @type {string}\n     */\n    this.type = values.type;\n    /**\n     * @type {string}\n     */\n    this.device = values.device;\n    /**\n     * the user agent of the publisher of the stream\n     * @type {string}\n     */\n    this.userAgent = values.userAgent;\n    /**\n     * @type {string}\n     */\n    this.height = values.height;\n    /**\n     * @type {string}\n     */\n    this.width = values.width;\n    /**\n     * The local DOM container element where the {@link Local~media} is displayed\n     * @type {Element}\n     */\n    this.container = cache.config.remoteStreamContainer;\n    /**\n     * @type {{audio: boolean, video: boolean}}\n     */\n    this.muted = Object.assign({ audio: false, video: false }, values.muted);\n    /**\n     * List of callbacks for mute status change\n     * @type {{MUTE: function[]}}\n     * @private\n     */\n    this._callbacks = {};\n    /**\n     * PeerConnections associated to this remote stream\n     * @type {PeerConnection}\n     */\n    this.peerConnection = null;\n  }\n\n  /**\n   * DOM element where the MediaStream is displayed\n   * @returns {Element}\n   */\n  get node() {\n    return this.peerConnection ? this.peerConnection.node : null;\n  }\n\n  /**\n   * Subscribe to the stream\n   * @param {Element} [remoteStreamContainer] The element the stream is attached to.\n   * Can be null if already specified in ReachConfig.\n   * @returns {Promise}\n   */\n  subscribe(remoteStreamContainer) {\n    if (!cache.user) {\n      return Promise.reject(\n        new Error('Only an authenticated user can subscribe to a Room\\'s stream.')\n      );\n    }\n    // TODO: Test if not already subscribed ?\n    this.container = remoteStreamContainer || cache.config.remoteStreamContainer;\n    Log.d('Remote~subscribe', this.container);\n    return cache.peerConnections.answer(this, this.container)\n      .then((pc) => {\n        this.peerConnection = pc;\n      })\n      .then(() => DataSync.update(`_/rooms/${this.roomId}/subscribers/${this.uid}/${cache.device}`, {\n        to: cache.user.uid,\n        _created: DataSync.ts()\n      }))\n      .then(() => {\n        DataSync.onDisconnect(`_/rooms/${this.roomId}/subscribers/${this.uid}/${cache.device}`)\n          .remove();\n        let subscribed = false;\n        DataSync.on(`_/rooms/${this.roomId}/streams/${this.uid}`, 'value', (snapData) => {\n          const values = snapData.val();\n          Log.d('Remote~updated', values);\n          if (values) {\n            // Update type\n            this.type = values.type;\n            // update stream size\n            const { width, height } = values;\n            if ((height || width) && (height !== this.height || width !== this.height)) {\n              this.height = values.height;\n              this.width = values.width;\n              Log.w(this._callbacks[Events.stream.SIZE]);\n              (this._callbacks[Events.stream.SIZE] || []).forEach(cb => (\n                cb(this.height, this.width)\n              ));\n            }\n            // Update mute status\n            const { muted } = values;\n            if (muted && (muted.audio !== this.muted.audio || muted.video !== this.muted.video)) {\n              this.muted = muted;\n              Log.w(this._callbacks[Events.stream.MUTE]);\n              (this._callbacks[Events.stream.MUTE] || []).forEach(cb => cb(this.muted));\n            }\n            subscribed = true;\n          } else if (subscribed) {\n            Log.i('Remote#removed', this);\n            this._close(true);\n          }\n        });\n      })\n      // .catch(Log.r('Remote~subscribe'));\n      .catch(() => Promise.reject(\n        new Error('Failed to subscribe to the remote stream')\n      ));\n  }\n\n  /**\n   * Unsubscribe from the stream\n   * @returns {Promise}\n   */\n  unSubscribe() {\n    return this._close(false);\n  }\n\n  /**\n   * Close the remote Stream\n   * @param {boolean} remote Close is initiated by publisher\n   * @returns {*}\n   * @private\n   */\n  _close(remote) {\n    // Cancel onDisconnect\n    DataSync.onDisconnect(`_/rooms/${this.roomId}/subscribers/${this.uid}/${cache.device}`)\n      .cancel();\n    // Stop listening to stream modifications\n    DataSync.off(`_/rooms/${this.roomId}/streams/${this.uid}`, 'value');\n    // Un-subscribe\n    if (!remote) {\n      DataSync.remove(`_/rooms/${this.roomId}/subscribers/${this.uid}/${cache.device}`);\n    }\n    // Close PeerConnection\n    return Promise.resolve(cache.peerConnections.close(this.uid, this.device));\n  }\n\n  /**\n   * Register a callback for a specific event\n   * @param {string} event The event name ({@link Events/Stream})\n   * @param {function} callback The callback for the event\n   */\n  on(event, callback) {\n    if (Events.stream.supports(event)) {\n      if (!this._callbacks[event]) {\n        this._callbacks[event] = [];\n      }\n      this._callbacks[event].push(callback);\n    }\n  }\n\n  /**\n   * Register a callback for a specific event\n   * @param {string} [event] The event name ({@link Events/Stream})\n   * @param {function} [callback] The callback for the event\n   */\n  off(event, callback) {\n    if (!event) {\n      this._callbacks = {};\n    } else if (Events.stream.supports(event)) {\n      if (!callback) {\n        this._callbacks[event] = [];\n      } else {\n        this._callbacks[event] = this._callbacks[event].filter(cb => cb !== callback);\n      }\n    }\n  }\n\n  /**\n   * @access protected\n   * @param {object} values\n   */\n  update(values) {\n    Object.keys(values).forEach((key) => {\n      this[key] = values[key];\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/stream/Remote.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "class",
    "name": "Remote",
    "memberof": "src/core/stream/Remote.js",
    "static": true,
    "longname": "src/core/stream/Remote.js~Remote",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/stream/Remote.js",
    "importStyle": "Remote",
    "description": "A published Stream",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 243,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#constructor",
    "access": "protected",
    "description": "",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "roomId",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#roomId",
    "access": "public",
    "description": "The uid of the room the stream is published in",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "uid",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#uid",
    "access": "public",
    "description": "The uid of this stream",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 246,
    "kind": "member",
    "name": "from",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#from",
    "access": "public",
    "description": "The uid of the publisher of the stream",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 247,
    "kind": "member",
    "name": "type",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#type",
    "access": "public",
    "description": "The type of the stream",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 248,
    "kind": "member",
    "name": "device",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#device",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 249,
    "kind": "member",
    "name": "userAgent",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#userAgent",
    "access": "public",
    "description": "the user agent of the publisher of the stream",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 250,
    "kind": "member",
    "name": "height",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#height",
    "access": "public",
    "description": "",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 251,
    "kind": "member",
    "name": "width",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#width",
    "access": "public",
    "description": "",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 252,
    "kind": "member",
    "name": "container",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#container",
    "access": "public",
    "description": "The local DOM container element where the {@link Local~media} is displayed",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "Element"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 253,
    "kind": "member",
    "name": "muted",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#muted",
    "access": "public",
    "description": "",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "{audio: boolean, video: boolean}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 254,
    "kind": "member",
    "name": "_callbacks",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#_callbacks",
    "access": "private",
    "description": "List of callbacks for mute status change",
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "{MUTE: function[]}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "peerConnection",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#peerConnection",
    "access": "public",
    "description": "PeerConnections associated to this remote stream",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "PeerConnection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 256,
    "kind": "get",
    "name": "node",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#node",
    "access": "public",
    "description": "DOM element where the MediaStream is displayed",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Element}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Element"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "subscribe",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#subscribe",
    "access": "public",
    "description": "Subscribe to the stream",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": true,
        "name": "remoteStreamContainer",
        "description": "The element the stream is attached to.\nCan be null if already specified in ReachConfig."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "unSubscribe",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#unSubscribe",
    "access": "public",
    "description": "Unsubscribe from the stream",
    "lineNumber": 151,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "_close",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#_close",
    "access": "private",
    "description": "Close the remote Stream",
    "lineNumber": 161,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "remote",
        "description": "Close is initiated by publisher"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "on",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#on",
    "access": "public",
    "description": "Register a callback for a specific event",
    "lineNumber": 180,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event name ({@link Events/Stream})"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback for the event"
      }
    ],
    "return": null
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "off",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#off",
    "access": "public",
    "description": "Register a callback for a specific event",
    "lineNumber": 194,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "event",
        "description": "The event name ({@link Events/Stream})"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "The callback for the event"
      }
    ],
    "return": null
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "update",
    "memberof": "src/core/stream/Remote.js~Remote",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#update",
    "access": "protected",
    "description": "",
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 270,
    "kind": "member",
    "name": "[key]",
    "memberof": "src/core/stream/Remote.js~Remote",
    "static": false,
    "longname": "src/core/stream/Remote.js~Remote#[key]",
    "access": "public",
    "description": null,
    "lineNumber": 212,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "file",
    "name": "src/core/stream/StreamManager.js",
    "content": "import Remote from './Remote';\n\n/**\n * @access protected\n */\nexport default class StreamManager {\n  /**\n   * Constructor\n   * @access protected\n   */\n  constructor() {\n    /**\n     * Shared local streams\n     * @type {{*: Local}}\n     */\n    this.shared = {};\n    /**\n     * Subscribed remote streams\n     * @type {{*: Remote}}\n     */\n    this.remote = {};\n  }\n\n  /**\n   * Get a Remote stream reference\n   * @param {object} streamData\n   * @returns {Remote}\n   */\n  getRemote(streamData) {\n    let remoteStream = this.remote[streamData.uid];\n    if (remoteStream) {\n      remoteStream.update(streamData);\n    } else {\n      remoteStream = new Remote(streamData);\n      this.remote[streamData.uid] = remoteStream;\n    }\n    return remoteStream;\n  }\n\n  /**\n   * Get a Remote stream reference\n   * @param {object} streamData\n   * @returns {Remote}\n   */\n  getShared(streamData) {\n    // TODO: If it does not exists locally as it should, maybe we should remove it ?\n    return this.shared[streamData.uid];\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/stream/StreamManager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 272,
    "kind": "class",
    "name": "StreamManager",
    "memberof": "src/core/stream/StreamManager.js",
    "static": true,
    "longname": "src/core/stream/StreamManager.js~StreamManager",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/stream/StreamManager.js",
    "importStyle": "StreamManager",
    "description": "",
    "lineNumber": 6,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 273,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/stream/StreamManager.js~StreamManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/StreamManager.js~StreamManager#constructor",
    "access": "protected",
    "description": "Constructor",
    "lineNumber": 11,
    "ignore": true
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "shared",
    "memberof": "src/core/stream/StreamManager.js~StreamManager",
    "static": false,
    "longname": "src/core/stream/StreamManager.js~StreamManager#shared",
    "access": "public",
    "description": "Shared local streams",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "{*: Local}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 275,
    "kind": "member",
    "name": "remote",
    "memberof": "src/core/stream/StreamManager.js~StreamManager",
    "static": false,
    "longname": "src/core/stream/StreamManager.js~StreamManager#remote",
    "access": "public",
    "description": "Subscribed remote streams",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "{*: Remote}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "getRemote",
    "memberof": "src/core/stream/StreamManager.js~StreamManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/StreamManager.js~StreamManager#getRemote",
    "access": "public",
    "description": "Get a Remote stream reference",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Remote}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "streamData",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Remote"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "getShared",
    "memberof": "src/core/stream/StreamManager.js~StreamManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/stream/StreamManager.js~StreamManager#getShared",
    "access": "public",
    "description": "Get a Remote stream reference",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Remote}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "streamData",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Remote"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 278,
    "kind": "file",
    "name": "src/core/util/DataSync.js",
    "content": "import cache from './cache';\n\n/**\n * Get the event string for Webcom from Reach events\n * @access protected\n * @param {string} event A Reach event\n * @return {string}\n */\nexport const eventType = (event) => {\n  let evt;\n  if ((/_ADDED$/i).test(event) || /_PUBLISHED$/.test(event)) {\n    evt = 'added';\n  } else if (/_CHANGED$/.test(event) || /_REFRESHED$/.test(event)) {\n    evt = 'changed';\n  } else if (/_REMOVED$/.test(event) || /_UNPUBLISHED$/.test(event)) {\n    evt = 'removed';\n  }\n  return evt ? `child_${evt}` : event;\n};\n\n/**\n * Write method\n * @param {string} method Write method (set,update)\n * @param {string} path The path to set\n * @param {object} data The data to set\n * @ignore\n */\nconst _write = (method, path, data) => new Promise((resolve, reject) => {\n  cache.base.child(path)[method](data, error => (error ? reject(error) : resolve()));\n});\n\n/**\n * {@link Webcom#set} as a {@link Promise}\n * @access protected\n * @param {string} path The path to set\n * @param {object} data The data to set\n * @return {Promise<*, Error>}\n */\nexport const set = _write.bind(undefined, 'set');\n\n/**\n * {@link Webcom#push} as a {@link Promise}\n * @access protected\n * @param {string} path The path to push\n * @param {object} data The data to push\n * @return {Promise<Webcom, Error>}\n */\nexport const push = (path, data) => new Promise((resolve, reject) => {\n  const pushRef = cache.base.child(path).push(data,\n    error => (error ? reject(error) : resolve(pushRef)));\n});\n\n/**\n * {@link Webcom#update} as a {@link Promise}\n * @access protected\n * @param {string} path The path to update\n * @param {object} data The data to update\n * @return {Promise<*, Error>}\n */\nexport const update = _write.bind(undefined, 'update');\n\n/**\n * {@link Webcom#remove} as a {@link Promise}\n * @access protected\n * @param {string} path The path to remove\n * @return {Promise<*, Error>}\n */\nexport const remove = path => new Promise((resolve, reject) => {\n  cache.base.child(path).remove(error => (error ? reject(error) : resolve()));\n});\n\n/**\n * {@link Webcom#once} shortcut as a {@link Promise}\n * @access protected\n * @param {string} path The path\n * @param {string} event The event\n * @returns {Promise<Webcom/api.DataSnapshot, Error>}\n */\nexport const once = (path, event) => new Promise((resolve, reject) => {\n  cache.base.child(path).once(eventType(event), resolve, reject);\n});\n\n/**\n * {@link Webcom#once}('value') as a {@link Promise}\n * @access protected\n * @param {string} path The path to get\n * @return {Promise<Webcom/api.DataSnapshot, Error>}\n */\nexport const get = path => once(path, 'value');\n\n/**\n * List values as a {@link Promise}\n * @access protected\n * @param {string} path The path to get\n * @param {function} Type The type of the object to list\n * @param params Additional constructor parameters\n * @return {Promise<Object[], Error>}\n */\nexport const list = (path, Type, ...params) => get(path)\n  .then((snapData) => {\n    if (snapData) {\n      const values = [];\n      snapData.forEach((snapChild) => {\n        values.push(new Type(snapChild, ...params));\n      });\n      return values;\n    }\n    return [];\n  });\n\n/**\n * {@link Webcom#on} shortcut\n * @access protected\n * @param {string} path The path\n * @param {string} event The event\n * @param {Webcom/api.Query~queryCallback|function} queryCallback The callback\n * @param {Webcom/api.Query~cancelCallback|function} [cancelCallback] The callback\n */\nexport const on = (path, event, queryCallback, cancelCallback) => {\n  cache.base.child(path).on(eventType(event), queryCallback, cancelCallback);\n};\n\n/**\n * {@link Webcom#off} shortcut\n * @access protected\n * @param {string} path The path\n * @param {string} event The event\n * @param {function} [callback] The callback\n */\nexport const off = (path, event, callback) => {\n  cache.base.child(path).off(eventType(event), callback);\n};\n\n/**\n * {@link Webcom#onDisconnect} shortcut\n * @access protected\n * @param {string} path The path\n * @return {Webcom/api.OnDisconnect}\n */\nexport const onDisconnect = path => cache.base.child(path).onDisconnect();\n\n/**\n * Timestamp value\n * @access protected\n * @type {function}\n */\n// export const ts = () => Webcom.ServerValue.TIMESTAMP;\nexport const ts = () => Date.now();\n// HACK #DataSync: Rollback when TIMESTAMP works again (server-side bug with security rules)\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/util/DataSync.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 279,
    "kind": "function",
    "name": "eventType",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~eventType",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{eventType}",
    "description": "Get the event string for Webcom from Reach events",
    "lineNumber": 9,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "A Reach event"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 280,
    "kind": "function",
    "name": "_write",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~_write",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": null,
    "description": "Write method",
    "lineNumber": 28,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "Write method (set,update)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to set"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to set"
      }
    ],
    "return": null
  },
  {
    "__docId__": 281,
    "kind": "variable",
    "name": "set",
    "memberof": "src/core/util/DataSync.js",
    "static": true,
    "longname": "src/core/util/DataSync.js~set",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{set}",
    "description": "{@link Webcom#set} as a {@link Promise}",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to set"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "function",
    "name": "push",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~push",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{push}",
    "description": "{@link Webcom#push} as a {@link Promise}",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to push"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to push"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Webcom, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "name": "update",
    "memberof": "src/core/util/DataSync.js",
    "static": true,
    "longname": "src/core/util/DataSync.js~update",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{update}",
    "description": "{@link Webcom#update} as a {@link Promise}",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to update"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to update"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "function",
    "name": "remove",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~remove",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{remove}",
    "description": "{@link Webcom#remove} as a {@link Promise}",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to remove"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 285,
    "kind": "function",
    "name": "once",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~once",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{once}",
    "description": "{@link Webcom#once} shortcut as a {@link Promise}",
    "lineNumber": 79,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Webcom/api.DataSnapshot, Error>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Webcom/api.DataSnapshot, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 286,
    "kind": "function",
    "name": "get",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~get",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{get}",
    "description": "{@link Webcom#once}('value') as a {@link Promise}",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to get"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Webcom/api.DataSnapshot, Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 287,
    "kind": "function",
    "name": "list",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~list",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{list}",
    "description": "List values as a {@link Promise}",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path to get"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "Type",
        "description": "The type of the object to list"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Additional constructor parameters"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object[], Error>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 288,
    "kind": "function",
    "name": "on",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~on",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{on}",
    "description": "{@link Webcom#on} shortcut",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event"
      },
      {
        "nullable": null,
        "types": [
          "Webcom/api.Query~queryCallback",
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "queryCallback",
        "description": "The callback"
      },
      {
        "nullable": null,
        "types": [
          "Webcom/api.Query~cancelCallback",
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "cancelCallback",
        "description": "The callback"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 289,
    "kind": "function",
    "name": "off",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~off",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{off}",
    "description": "{@link Webcom#off} shortcut",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "The callback"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 290,
    "kind": "function",
    "name": "onDisconnect",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~onDisconnect",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{onDisconnect}",
    "description": "{@link Webcom#onDisconnect} shortcut",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Webcom/api.OnDisconnect"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 291,
    "kind": "function",
    "name": "ts",
    "memberof": "src/core/util/DataSync.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/DataSync.js~ts",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/DataSync.js",
    "importStyle": "{ts}",
    "description": "Timestamp value",
    "lineNumber": 148,
    "type": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 292,
    "kind": "file",
    "name": "src/core/util/Log.js",
    "content": "import cache from './cache';\n\n/**\n * List of possible log levels\n * @access private\n * @type {string[]}\n */\nconst levels = ['DEBUG', 'INFO', 'WARN', 'ERROR'];\n/**\n * Is log enabled for a specific level\n * @access private\n * @param {string} level The level to test\n * @returns {boolean}\n */\nconst isEnabled = level => (\n  levels.indexOf(level.toUpperCase()) >= levels.indexOf(cache.logLevel.toUpperCase())\n);\n/**\n * Global Console. (to avoid drop_console...)\n * @access private\n * @type {Console}\n */\nconst gConsole = global.console;\n/**\n * Shorthand for console call\n * @access private\n * @param {string} method A method of the console object\n * @param {string} level The log level\n * @param {*} messages the log content\n */\nconst logger = (method, level, ...messages) => (\n  isEnabled(level)\n    ? gConsole[method.toLowerCase()].bind(gConsole)(...messages)\n    : () => {}\n);\n/**\n * Use a group to log\n * @access private\n * @param {string} level The log level\n * @param {string} message The group title\n * @param {*} items the log content\n */\nconst group = (level, message, ...items) => {\n  if (items.length > 0) {\n    logger.bind(\n      undefined,\n      gConsole.group ? 'group' : level,\n      level\n    )(typeof message === 'string' ? message : '');\n\n    let values = (typeof message !== 'string' ? [message] : []).concat(items);\n    if (items.length === 1\n      && items[0] instanceof Array\n      && typeof items[0].length !== 'undefined') {\n      values = items[0]; // eslint-disable-line prefer-destructuring\n    }\n    values.forEach(item => logger.bind(undefined, level, level)(item));\n    if (gConsole.groupEnd) {\n      gConsole.groupEnd();\n    }\n  } else {\n    logger.bind(undefined, level, level, message);\n  }\n};\n\n/**\n * Log debug messages if log level is set to DEBUG.\n * @access protected\n * @see https://developer.mozilla.org/fr/docs/Web/API/Console/log\n */\nexport const d = group.bind(undefined, levels[0]);\n/**\n * Log information messages if log level is set to DEBUG or INFO.\n * @access protected\n * @see https://developer.mozilla.org/fr/docs/Web/API/Console/info\n */\nexport const i = group.bind(undefined, levels[1]);\n/**\n * Log warning messages if log level is set to DEBUG, INFO or WARN.\n * @access protected\n * @see https://developer.mozilla.org/fr/docs/Web/API/Console/warn\n */\nexport const w = group.bind(undefined, levels[2]);\n/**\n * Log error messages. Errors are always logged.\n * @access protected\n * @see https://developer.mozilla.org/fr/docs/Web/API/Console/error\n */\nexport const e = gConsole.error.bind(gConsole);\n/**\n * Promise rejection logger to use with catch\n * @access protected\n * @param {string} message\n * @returns {function}\n */\nexport const r = message => (reason) => {\n  d(message, reason);\n  return Promise.reject(reason || message);\n};\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/util/Log.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 293,
    "kind": "variable",
    "name": "levels",
    "memberof": "src/core/util/Log.js",
    "static": true,
    "longname": "src/core/util/Log.js~levels",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": null,
    "description": "List of possible log levels",
    "lineNumber": 8,
    "type": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 294,
    "kind": "function",
    "name": "isEnabled",
    "memberof": "src/core/util/Log.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Log.js~isEnabled",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": null,
    "description": "Is log enabled for a specific level",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": "The level to test"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 295,
    "kind": "variable",
    "name": "gConsole",
    "memberof": "src/core/util/Log.js",
    "static": true,
    "longname": "src/core/util/Log.js~gConsole",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": null,
    "description": "Global Console. (to avoid drop_console...)",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "Console"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 296,
    "kind": "function",
    "name": "logger",
    "memberof": "src/core/util/Log.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Log.js~logger",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": null,
    "description": "Shorthand for console call",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "A method of the console object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": "The log level"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "messages",
        "description": "the log content"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 297,
    "kind": "function",
    "name": "group",
    "memberof": "src/core/util/Log.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Log.js~group",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": null,
    "description": "Use a group to log",
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": "The log level"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The group title"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "items",
        "description": "the log content"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 298,
    "kind": "variable",
    "name": "d",
    "memberof": "src/core/util/Log.js",
    "static": true,
    "longname": "src/core/util/Log.js~d",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": "{d}",
    "description": "Log debug messages if log level is set to DEBUG.",
    "see": [
      "https://developer.mozilla.org/fr/docs/Web/API/Console/log"
    ],
    "lineNumber": 71,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "variable",
    "name": "i",
    "memberof": "src/core/util/Log.js",
    "static": true,
    "longname": "src/core/util/Log.js~i",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": "{i}",
    "description": "Log information messages if log level is set to DEBUG or INFO.",
    "see": [
      "https://developer.mozilla.org/fr/docs/Web/API/Console/info"
    ],
    "lineNumber": 77,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "variable",
    "name": "w",
    "memberof": "src/core/util/Log.js",
    "static": true,
    "longname": "src/core/util/Log.js~w",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": "{w}",
    "description": "Log warning messages if log level is set to DEBUG, INFO or WARN.",
    "see": [
      "https://developer.mozilla.org/fr/docs/Web/API/Console/warn"
    ],
    "lineNumber": 83,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "name": "e",
    "memberof": "src/core/util/Log.js",
    "static": true,
    "longname": "src/core/util/Log.js~e",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": "{e}",
    "description": "Log error messages. Errors are always logged.",
    "see": [
      "https://developer.mozilla.org/fr/docs/Web/API/Console/error"
    ],
    "lineNumber": 89,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "function",
    "name": "r",
    "memberof": "src/core/util/Log.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Log.js~r",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/Log.js",
    "importStyle": "{r}",
    "description": "Promise rejection logger to use with catch",
    "lineNumber": 96,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 303,
    "kind": "file",
    "name": "src/core/util/Media.js",
    "content": "/* eslint max-params: [2, 5], max-len: [0, 120] */\nimport * as Log from './Log';\nimport Reach from '../../Reach';\n\n/**\n * Video resolution presets\n * @access private\n * @type {{UHD: {w: number, h: number, min: string}, FHD: {w: number, h: number, min: string, max: string}, HD: {w: number, h: number, min: string, max: string}, SVGA: {w: number, h: number, min: string, max: string}, SD: {w: number, h: number, min: string, max: string}, VGA: {w: number, h: number, max: string}}}\n */\nconst presets = {\n  UHD: { w: 3840, h: 2160, min: 'HD' },\n  FHD: {\n    w: 1920, h: 1080, min: 'HD', max: 'UHD'\n  },\n  HD: {\n    w: 1280, h: 720, min: 'SD', max: 'FHD'\n  },\n  SVGA: {\n    w: 800, h: 600, min: 'VGA', max: 'HD'\n  },\n  SD: {\n    w: 720, h: 576, min: 'VGA', max: 'HD'\n  },\n  VGA: { w: 640, h: 480, max: 'SVGA' }\n};\n\n/**\n * Assign deviceId to constraint\n * @param constraint\n * @param deviceId\n * @returns {*}\n */\nconst _assignDevice = (constraint, deviceId) => {\n  if (constraint && deviceId) {\n    return Object.assign(\n      /^((user)|(environment))$/i.test(deviceId) ? { facingMode: deviceId } : { deviceId },\n      constraint === true ? {} : constraint\n    );\n  }\n  return constraint;\n};\n\n/**\n * Helpers for MediaDevices and MediaStreamConstraints.\n */\nexport default class Media {\n  /**\n   * facingMode values to use with constraints\n   * @returns {{USER: string, ENVIRONMENT: string}}\n   */\n  static get facingMode() {\n    return {\n      USER: 'user',\n      ENVIRONMENT: 'environment'\n    };\n  }\n\n  /**\n   * Helpers to create a MediaStreamConstraints configuration object\n   * @param {boolean|MediaTrackConstraints|string} [videoConstraints='HD'] a boolean, a video constraints object or a preset id (UHD, FHD, HD, SVGA, SD, VGA)\n   * @param {boolean|MediaTrackConstraints} [audioConstraints=true] a boolean or an audio constraints object\n   * @param {string} [type=ideal] type of constraints for video when using a preset (exact,min,max or ideal)\n   * @param {string|object} [videoDeviceId] video input device id or facingMode\n   * @param {string|object} [audioDeviceId] audio input device id\n   * @returns {object}\n   * @throws {Error}\n   *\n   * @example <caption>HD AudioVideo with default devices</caption>\n   * let myConstraints = Reach.media.constraints();\n   * console.log(myConstraints);\n   *\n   * @example <caption>Full HD Video without audio using default devices</caption>\n   * let myConstraints = Reach.media.constraints('FHD', false, 'exact');\n   * console.log(myConstraints);\n   */\n  static constraints(videoConstraints = 'HD', audioConstraints = true, type = 'ideal', videoDeviceId, audioDeviceId) {\n    let video = videoConstraints;\n    if (typeof videoConstraints === 'string') {\n      if (presets[videoConstraints.toUpperCase()]) {\n        const\n          preset = presets[videoConstraints.toUpperCase()];\n\n\n        const dimConstraint = (dim) => {\n          if (/^(min|max|exact)$/.test(type)) {\n            const r = {};\n            r[type] = preset[dim];\n            return r;\n          }\n          return {\n            min: preset.min ? presets[preset.min][dim] : preset[dim],\n            ideal: preset[dim],\n            max: preset.max ? presets[preset.max][dim] : preset[dim]\n          };\n        };\n        video = { width: dimConstraint('w'), height: dimConstraint('h') };\n      } else {\n        throw new Error('Unknown Video Resolution preset (UHD, FHD, HD, SVGA, SD, VGA)');\n      }\n    }\n    video = _assignDevice(video, videoDeviceId);\n\n    const audio = _assignDevice(audioConstraints, audioDeviceId);\n\n    Log.d('Media#constraints', { video, audio });\n    return { video, audio };\n  }\n\n  /**\n   * Init stream display node depending on stream type\n   * @param {MediaStream} mediaStream The MediaStream to display\n   * @param {Element} container Container node for streams\n   * @param {Element} previous Previous node for the stream\n   * @param {number} [volume=.7] the default volume\n   * @return {Element}\n   */\n  static attachStream(mediaStream, container, previous, volume = 0.7) {\n    let tagName = '';\n    if (mediaStream.getVideoTracks().length > 0) {\n      tagName = 'video';\n    } else if (mediaStream.getAudioTracks().length > 0) {\n      tagName = 'audio';\n    }\n    Log.d('Media#attachStream', mediaStream, tagName);\n    if (tagName.length > 0) {\n      let _node = previous;\n      if (!_node || _node.tagName.toLowerCase() !== tagName) {\n        _node = document.createElement(tagName);\n        _node.autoplay = true;\n        // set these attributes in order to launch the video on IOS\n        if (Reach.browser.browser === 'safari') {\n          _node.setAttribute('playsinline', true);\n          _node.setAttribute('muted', true);\n        } else {\n          // _node.setAttribute('type','video/mp4');\n        }\n        _node.style.borderRadius = '1px';\n      }\n      if (container) {\n        if (previous && previous !== _node) {\n          container.replaceChild(_node, previous);\n        } else if (!previous) {\n          container.appendChild(_node);\n        }\n      }\n      _node.srcObject = mediaStream;\n      /* _node.addEventListener('play', (event) => {\n        Log.d(`video.onplay = ${event.type}`);\n        _node.srcObject.onaddtrack = (track) => {\n          Log.d(`[Local] listener: video.onaddtrack = ${track.label}`); // eslint-disable-line\n        };\n        _node.srcObject.onremovetrack = (track) => {\n          Log.d(`[Local] listener: video.onremovetrack = ${track.label}`); // eslint-disable-line\n        };\n        _node.srcObject.oninactive = () => {\n          Log.d(`[Local] listener: video.oninactive`); // eslint-disable-line\n        };\n        _node.srcObject.onplaying = (event) => {\n          console.debug(`[Local] listener: video.onplaying = ${event.type}`); // eslint-disable-line\n        };\n        _node.srcObject.onstalled = (event) => {\n          console.debug(`[Local] listener: video.onstalled = ${event.type}`); // eslint-disable-line\n        };\n        _node.srcObject.onsuspend = (event) => {\n          console.debug(`[Local] listener: video.onsuspend = ${event.type}`); // eslint-disable-line\n          console.debug(event); // eslint-disable-line\n          console.debug('on passe l');\n        };\n      }); */\n      /* _node.onsuspend = (event) => {\n        console.debug(`[Local] listener: video.onsuspend = ${event}`); // eslint-disable-line\n        console.debug(event); // eslint-disable-line\n        /!* console.debug('on est ici');\n                const tagmuted = _node.muted;\n                _node.setAttribute('muted',true);\n                let autoPlayAllowed = true;\n                const promise = _node.play();\n                if (promise instanceof Promise) {\n                    promise.then(function(status) {\n                        console.dir(promise);\n                    });\n                    promise.catch(function(error) {\n                        console.error(error.message);\n                        if (error.name === 'NotAllowedError') {\n                            autoPlayAllowed = false;\n                        } else {\n                            // Don't throw the error so that we get to the then\n                            // or throw it but set the autoPlayAllowed to true in here\n                        }\n                    }).then(function() {\n                        if (autoPlayAllowed) {\n                            console.log('autoplay allowed')\n                        } else {\n                            console.log('autoplay NOT allowed')\n                        }\n                    });\n                } else {\n                    console.log('autoplay unknown')\n                } *!/\n      }; */\n      // _node.addEventListener('loadeddata', () => Log.d('on a charg les donnes'));\n      // _node.addEventListener('error', error => Log.d(`on a une erreur ${error}`));\n      // _node.setAttribute('controls',true);\n      // disabled doesn't seem to be needed\n      // _node.disabled = false;\n      _node.volume = volume;\n      return _node;\n    }\n    return previous;\n  }\n\n  /**\n   * List available input devices\n   * @return {Promise<{audioinput: MediaDeviceInfo[], videoinput: MediaDeviceInfo[]}>}\n   *\n   * @example\n   * Reach.media.devices().then(devices => {\n   *  // Video cameras\n   *  console.log(devices.videoinput);\n   *  // Audio mics\n   *  console.log(devices.audioinput);\n   * });\n   */\n  static devices() {\n    return navigator.mediaDevices.enumerateDevices()\n      .then((devices) => {\n        const r = {};\n        devices.forEach((device) => {\n          if (!r[device.kind]) {\n            r[device.kind] = [];\n          }\n          r[device.kind].push(device);\n        });\n        Log.d('Media#devices', r);\n        return r;\n      })\n      .catch(Log.r('Media#devices'));\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/util/Media.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 304,
    "kind": "variable",
    "name": "presets",
    "memberof": "src/core/util/Media.js",
    "static": true,
    "longname": "src/core/util/Media.js~presets",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/Media.js",
    "importStyle": null,
    "description": "Video resolution presets",
    "lineNumber": 10,
    "type": {
      "nullable": null,
      "types": [
        "{UHD: {w: number, h: number, min: string}, FHD: {w: number, h: number, min: string, max: string}, HD: {w: number, h: number, min: string, max: string}, SVGA: {w: number, h: number, min: string, max: string}, SD: {w: number, h: number, min: string, max: string}, VGA: {w: number, h: number, max: string}}"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 305,
    "kind": "function",
    "name": "_assignDevice",
    "memberof": "src/core/util/Media.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Media.js~_assignDevice",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/Media.js",
    "importStyle": null,
    "description": "Assign deviceId to constraint",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "constraint",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "deviceId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 306,
    "kind": "class",
    "name": "Media",
    "memberof": "src/core/util/Media.js",
    "static": true,
    "longname": "src/core/util/Media.js~Media",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/util/Media.js",
    "importStyle": "Media",
    "description": "Helpers for MediaDevices and MediaStreamConstraints.",
    "lineNumber": 46,
    "interface": false
  },
  {
    "__docId__": 307,
    "kind": "get",
    "name": "facingMode",
    "memberof": "src/core/util/Media.js~Media",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Media.js~Media.facingMode",
    "access": "public",
    "description": "facingMode values to use with constraints",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{USER: string, ENVIRONMENT: string}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{USER: string, ENVIRONMENT: string}"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "{\"USER\": string, \"ENVIRONMENT\": string}"
      ]
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "constraints",
    "memberof": "src/core/util/Media.js~Media",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Media.js~Media.constraints",
    "access": "public",
    "description": "Helpers to create a MediaStreamConstraints configuration object",
    "examples": [
      "<caption>HD AudioVideo with default devices</caption>\nlet myConstraints = Reach.media.constraints();\nconsole.log(myConstraints);",
      "<caption>Full HD Video without audio using default devices</caption>\nlet myConstraints = Reach.media.constraints('FHD', false, 'exact');\nconsole.log(myConstraints);"
    ],
    "lineNumber": 76,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean",
          "MediaTrackConstraints",
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'HD'",
        "defaultRaw": "'HD'",
        "name": "videoConstraints",
        "description": "a boolean, a video constraints object or a preset id (UHD, FHD, HD, SVGA, SD, VGA)"
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "MediaTrackConstraints"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "audioConstraints",
        "description": "a boolean or an audio constraints object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "ideal",
        "defaultRaw": "ideal",
        "name": "type",
        "description": "type of constraints for video when using a preset (exact,min,max or ideal)"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "videoDeviceId",
        "description": "video input device id or facingMode"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "audioDeviceId",
        "description": "audio input device id"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": ""
      }
    ]
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "attachStream",
    "memberof": "src/core/util/Media.js~Media",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Media.js~Media.attachStream",
    "access": "public",
    "description": "Init stream display node depending on stream type",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "mediaStream",
        "description": "The MediaStream to display"
      },
      {
        "nullable": null,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": false,
        "name": "container",
        "description": "Container node for streams"
      },
      {
        "nullable": null,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": false,
        "name": "previous",
        "description": "Previous node for the stream"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": ".7",
        "defaultRaw": ".7",
        "name": "volume",
        "description": "the default volume"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Element"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "devices",
    "memberof": "src/core/util/Media.js~Media",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/util/Media.js~Media.devices",
    "access": "public",
    "description": "List available input devices",
    "examples": [
      "Reach.media.devices().then(devices => {\n // Video cameras\n console.log(devices.videoinput);\n // Audio mics\n console.log(devices.audioinput);\n});"
    ],
    "lineNumber": 224,
    "return": {
      "nullable": null,
      "types": [
        "Promise<{audioinput: MediaDeviceInfo[], videoinput: MediaDeviceInfo[]}>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 311,
    "kind": "file",
    "name": "src/core/util/cache.js",
    "content": "import Webcom from 'webcom/webcom';\nimport Config from '../Config';\nimport StreamManager from '../stream/StreamManager';\nimport PeerConnectionManager from '../webrtc/PeerConnectionManager';\n\n/**\n * singleton\n * @type {CacheManager}\n * @private\n */\nlet _cache = null;\n\n/**\n * Singleton to handle global references\n * @access protected\n */\nclass CacheManager {\n  /**\n   * Construct singleton\n   * @return {CacheManager}\n   */\n  constructor() {\n    if (!_cache) {\n      _cache = this;\n    }\n    return _cache;\n  }\n\n  /**\n   * The base reference\n   * @param {Webcom} url the reference or its url\n   */\n  set base(url) {\n    /**\n     * @ignore\n     */\n    this._base = url instanceof Webcom ? url : new Webcom(url);\n  }\n\n  /**\n   * The base reference\n   * @type {Webcom}\n   */\n  get base() {\n    return this._base;\n  }\n\n  /**\n   * The connected user\n   * @param {Config} config the connected user\n   */\n  set config(config) {\n    if (!this._config) {\n      /**\n       * @ignore\n       */\n      this._config = new Config(config);\n    } else {\n      this._config.assign(config);\n    }\n  }\n\n  /**\n   * The connected user\n   * @type {Config}\n   */\n  get config() {\n    if (!this._config) {\n      this._config = new Config();\n    }\n    return this._config;\n  }\n\n  /**\n   * The connected user\n   * @param {User} user the connected user\n   */\n  set user(user) {\n    /**\n     * @ignore\n     */\n    this._user = user;\n  }\n\n  /**\n   * The connected user\n   * @type {User}\n   */\n  get user() {\n    return this._user;\n  }\n\n  /**\n   * The current device\n   * @param {string} device the current device\n   */\n  set device(device) {\n    /**\n     * @ignore\n     */\n    this._device = device;\n  }\n\n  /**\n   * The current device\n   * @type {string}\n   */\n  get device() {\n    return this._device;\n  }\n\n  /**\n   * The log level (DEBUG, INFO, WARN, ERROR)\n   * @type {string}\n   */\n  set logLevel(level) {\n    if (/^DEBUG|INFO|WARN|ERROR$/i.test(level)) {\n      /**\n       * @ignore\n       */\n      this._logLevel = level;\n    } else if (level) {\n      throw new Error('Unsupported log level (DEBUG, INFO, WARN, ERROR)');\n    }\n  }\n\n  /**\n   * The log level (DEBUG, INFO, WARN, ERROR)\n   * @returns {string}\n   */\n  get logLevel() {\n    return this._logLevel || 'ERROR';\n  }\n\n  /**\n   * Streams manager\n   * @returns {StreamManager}\n   */\n  get streams() {\n    if (!this._streams) {\n      /**\n       * @ignore\n       */\n      this._streams = new StreamManager();\n    }\n    return this._streams;\n  }\n\n  /**\n   * PeerConnections manager\n   * @returns {PeerConnectionManager}\n   */\n  get peerConnections() {\n    if (!this._peerConnections) {\n      /**\n       * @ignore\n       */\n      this._peerConnections = new PeerConnectionManager();\n    }\n    return this._peerConnections;\n  }\n\n  /**\n   *\n   * @param room\n   */\n  set room(room) {\n    this._room = room;\n  }\n\n  /**\n   *\n   * @returns {*}\n   */\n  get room() {\n    return this._room;\n  }\n}\n\n/**\n * The singleton instance\n * @ignore\n * @type {CacheManager}\n */\nconst cache = new CacheManager();\n\n/**\n * Singleton for shared references\n * @access protected\n */\nexport default cache;\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/util/cache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 312,
    "kind": "variable",
    "name": "_cache",
    "memberof": "src/core/util/cache.js",
    "static": true,
    "longname": "src/core/util/cache.js~_cache",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/util/cache.js",
    "importStyle": null,
    "description": "singleton",
    "lineNumber": 11,
    "type": {
      "nullable": null,
      "types": [
        "CacheManager"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 313,
    "kind": "class",
    "name": "CacheManager",
    "memberof": "src/core/util/cache.js",
    "static": true,
    "longname": "src/core/util/cache.js~CacheManager",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/cache.js",
    "importStyle": null,
    "description": "Singleton to handle global references",
    "lineNumber": 17,
    "pseudoExport": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 314,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#constructor",
    "access": "public",
    "description": "Construct singleton",
    "lineNumber": 22,
    "return": {
      "nullable": null,
      "types": [
        "CacheManager"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 315,
    "kind": "set",
    "name": "base",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#base",
    "access": "public",
    "description": "The base reference",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "Webcom"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "the reference or its url"
      }
    ]
  },
  {
    "__docId__": 316,
    "kind": "member",
    "name": "_base",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_base",
    "access": "private",
    "description": "",
    "lineNumber": 37,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "get",
    "name": "base",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#base",
    "access": "public",
    "description": "The base reference",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Webcom"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 318,
    "kind": "set",
    "name": "config",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#config",
    "access": "public",
    "description": "The connected user",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Config"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "the connected user"
      }
    ]
  },
  {
    "__docId__": 319,
    "kind": "member",
    "name": "_config",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_config",
    "access": "private",
    "description": "",
    "lineNumber": 57,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "get",
    "name": "config",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#config",
    "access": "public",
    "description": "The connected user",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "Config"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 322,
    "kind": "set",
    "name": "user",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#user",
    "access": "public",
    "description": "The connected user",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "User"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "the connected user"
      }
    ]
  },
  {
    "__docId__": 323,
    "kind": "member",
    "name": "_user",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_user",
    "access": "private",
    "description": "",
    "lineNumber": 82,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "get",
    "name": "user",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#user",
    "access": "public",
    "description": "The connected user",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "User"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 325,
    "kind": "set",
    "name": "device",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#device",
    "access": "public",
    "description": "The current device",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "device",
        "description": "the current device"
      }
    ]
  },
  {
    "__docId__": 326,
    "kind": "member",
    "name": "_device",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_device",
    "access": "private",
    "description": "",
    "lineNumber": 101,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "get",
    "name": "device",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#device",
    "access": "public",
    "description": "The current device",
    "lineNumber": 108,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 328,
    "kind": "set",
    "name": "logLevel",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#logLevel",
    "access": "public",
    "description": "The log level (DEBUG, INFO, WARN, ERROR)",
    "lineNumber": 116,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 329,
    "kind": "member",
    "name": "_logLevel",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_logLevel",
    "access": "private",
    "description": "",
    "lineNumber": 121,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "get",
    "name": "logLevel",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#logLevel",
    "access": "public",
    "description": "The log level (DEBUG, INFO, WARN, ERROR)",
    "lineNumber": 131,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "get",
    "name": "streams",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#streams",
    "access": "public",
    "description": "Streams manager",
    "lineNumber": 139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{StreamManager}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "StreamManager"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "member",
    "name": "_streams",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_streams",
    "access": "private",
    "description": "",
    "lineNumber": 144,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "get",
    "name": "peerConnections",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#peerConnections",
    "access": "public",
    "description": "PeerConnections manager",
    "lineNumber": 153,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{PeerConnectionManager}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "PeerConnectionManager"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "member",
    "name": "_peerConnections",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_peerConnections",
    "access": "private",
    "description": "",
    "lineNumber": 158,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "set",
    "name": "room",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#room",
    "access": "public",
    "description": "",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "room",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 336,
    "kind": "member",
    "name": "_room",
    "memberof": "src/core/util/cache.js~CacheManager",
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#_room",
    "access": "private",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "get",
    "name": "room",
    "memberof": "src/core/util/cache.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/util/cache.js~CacheManager#room",
    "access": "public",
    "description": "",
    "lineNumber": 175,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "variable",
    "name": "cache",
    "memberof": "src/core/util/cache.js",
    "static": true,
    "longname": "src/core/util/cache.js~cache",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/cache.js",
    "importStyle": "cache",
    "description": "Singleton for shared references",
    "lineNumber": 191,
    "ignore": true,
    "type": {
      "types": [
        "src/core/util/cache.js~CacheManager"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "file",
    "name": "src/core/util/constants.js",
    "content": "/**\n * OPENED\n * @access protected\n * @type {string}\n */\nexport const OPENED = 'OPENED';\n/**\n * CLOSED\n * @access protected\n * @type {string}\n */\nexport const CLOSED = 'CLOSED';\n/**\n * CLOSING\n * @access protected\n * @type {string}\n */\nexport const CLOSING = 'CLOSING';\n/**\n * CONNECTED\n * @access protected\n * @type {string}\n */\nexport const CONNECTED = 'CONNECTED';\n/**\n * NOT_CONNECTED\n * @access protected\n * @type {string}\n */\nexport const NOT_CONNECTED = 'NOT_CONNECTED';\n/**\n * WAS_CONNECTED\n * @access protected\n * @type {string}\n */\nexport const WAS_CONNECTED = 'WAS_CONNECTED';\n/**\n * OWNER\n * @access protected\n * @type {string}\n */\nexport const OWNER = 'OWNER';\n/**\n * MODERATOR\n * @access protected\n * @type {string}\n */\nexport const MODERATOR = 'MODERATOR';\n/**\n * PARTICIPANT\n * @access protected\n * @type {string}\n */\nexport const PARTICIPANT = 'PARTICIPANT';\n/**\n * NONE\n * @access protected\n * @type {string}\n */\nexport const NONE = 'NONE';\n/**\n * Ongoing invitation\n * @access protected\n * @type {string}\n */\nexport const ONGOING = 'ONGOING';\n/**\n * Accepted invitation\n * @access protected\n * @type {string}\n */\nexport const ACCEPTED = 'ACCEPTED';\n/**\n * Rejected invitation\n * @access protected\n * @type {string}\n */\nexport const REJECTED = 'REJECTED';\n/**\n * Canceled invitation\n * @access protected\n * @type {string}\n */\nexport const CANCELED = 'CANCELED';\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/util/constants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 340,
    "kind": "variable",
    "name": "OPENED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~OPENED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{OPENED}",
    "description": "OPENED",
    "lineNumber": 6,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 341,
    "kind": "variable",
    "name": "CLOSED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~CLOSED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{CLOSED}",
    "description": "CLOSED",
    "lineNumber": 12,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 342,
    "kind": "variable",
    "name": "CLOSING",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~CLOSING",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{CLOSING}",
    "description": "CLOSING",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 343,
    "kind": "variable",
    "name": "CONNECTED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~CONNECTED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{CONNECTED}",
    "description": "CONNECTED",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 344,
    "kind": "variable",
    "name": "NOT_CONNECTED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~NOT_CONNECTED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{NOT_CONNECTED}",
    "description": "NOT_CONNECTED",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 345,
    "kind": "variable",
    "name": "WAS_CONNECTED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~WAS_CONNECTED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{WAS_CONNECTED}",
    "description": "WAS_CONNECTED",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 346,
    "kind": "variable",
    "name": "OWNER",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~OWNER",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{OWNER}",
    "description": "OWNER",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 347,
    "kind": "variable",
    "name": "MODERATOR",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~MODERATOR",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{MODERATOR}",
    "description": "MODERATOR",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 348,
    "kind": "variable",
    "name": "PARTICIPANT",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~PARTICIPANT",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{PARTICIPANT}",
    "description": "PARTICIPANT",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 349,
    "kind": "variable",
    "name": "NONE",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~NONE",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{NONE}",
    "description": "NONE",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 350,
    "kind": "variable",
    "name": "ONGOING",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~ONGOING",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{ONGOING}",
    "description": "Ongoing invitation",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 351,
    "kind": "variable",
    "name": "ACCEPTED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~ACCEPTED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{ACCEPTED}",
    "description": "Accepted invitation",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 352,
    "kind": "variable",
    "name": "REJECTED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~REJECTED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{REJECTED}",
    "description": "Rejected invitation",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 353,
    "kind": "variable",
    "name": "CANCELED",
    "memberof": "src/core/util/constants.js",
    "static": true,
    "longname": "src/core/util/constants.js~CANCELED",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/util/constants.js",
    "importStyle": "{CANCELED}",
    "description": "Canceled invitation",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 354,
    "kind": "file",
    "name": "src/core/webrtc/GetStats.js",
    "content": "import * as Log from '../util/Log';\n\n// Last time updated: 2018-12-20 6:58:08 AM UTC\n\n// _______________\n// getStats v1.0.9\n\n// Open-Sourced: https://github.com/muaz-khan/getStats\n\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n/* eslint-disable */\nconst GetStats = (mediaStreamTrack, callback, interval) => {\n  const RTCPeerConnection = window.RTCPeerConnection\n    || window.mozRTCPeerConnection\n    || window.webkitRTCPeerConnection;\n\n  if (typeof MediaStreamTrack === 'undefined') {\n    MediaStreamTrack = {}; // eslint-disable-line no-global-assign\n  }\n\n  const systemNetworkType = ((navigator.connection || {}).type || 'unknown')\n    .toString()\n    .toLowerCase();\n\n  const getStatsResult = {\n    encryption: 'sha-256',\n    audio: {\n      send: {\n        tracks: [],\n        codecs: [],\n        availableBandwidth: 0,\n        streams: 0,\n        framerateMean: 0,\n        bitrateMean: 0\n      },\n      recv: {\n        tracks: [],\n        codecs: [],\n        availableBandwidth: 0,\n        streams: 0,\n        framerateMean: 0,\n        bitrateMean: 0\n      },\n      bytesSent: 0,\n      bytesReceived: 0,\n      latency: 0,\n      packetsLost: 0\n    },\n    video: {\n      send: {\n        tracks: [],\n        codecs: [],\n        availableBandwidth: 0,\n        streams: 0,\n        framerateMean: 0,\n        bitrateMean: 0\n      },\n      recv: {\n        tracks: [],\n        codecs: [],\n        availableBandwidth: 0,\n        streams: 0,\n        framerateMean: 0,\n        bitrateMean: 0\n      },\n      bytesSent: 0,\n      bytesReceived: 0,\n      latency: 0,\n      packetsLost: 0\n    },\n    bandwidth: {\n      systemBandwidth: 0,\n      sentPerSecond: 0,\n      encodedPerSecond: 0,\n      helper: {\n        audioBytesSent: 0,\n        videoBytestSent: 0\n      },\n      speed: 0\n    },\n    results: {},\n    connectionType: {\n      systemNetworkType,\n      systemIpAddress: '192.168.1.2',\n      local: {\n        candidateType: [],\n        transport: [],\n        ipAddress: [],\n        networkType: []\n      },\n      remote: {\n        candidateType: [],\n        transport: [],\n        ipAddress: [],\n        networkType: []\n      }\n    },\n    resolutions: {\n      send: {\n        width: 0,\n        height: 0\n      },\n      recv: {\n        width: 0,\n        height: 0\n      }\n    },\n    internal: {\n      audio: {\n        send: {},\n        recv: {}\n      },\n      video: {\n        send: {},\n        recv: {}\n      },\n      candidates: {}\n    },\n    nomore() {\n      nomore = true;\n    }\n  };\n\n  const getStatsParser = {\n    checkIfOfferer(result) {\n      if (result.type === 'googLibjingleSession') {\n        getStatsResult.isOfferer = result.googInitiator;\n      }\n    }\n  };\n\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n  let peer = this;\n\n  if (!(arguments[0] instanceof RTCPeerConnection)) {\n    throw '1st argument is not instance of RTCPeerConnection.';\n  }\n\n  peer = arguments[0];\n\n  if (arguments[1] instanceof MediaStreamTrack) {\n    mediaStreamTrack = arguments[1]; // redundant on non-safari\n    callback = arguments[2];\n    interval = arguments[3];\n  }\n\n  let nomore = false;\n\n  // a wrapper around getStats which hides the differences (where possible)\n  // following code-snippet is taken from somewhere on the github\n  function getStatsWrapper(cb) {\n    // if !peer or peer.signalingState == 'closed' then return;\n\n    peer.getStats(window.mediaStreamTrack || null).then((res) => {\n      const items = [];\n      res.forEach((r) => {\n        items.push(r);\n      });\n      cb(items);\n    }).catch(cb);\n\n    /* if (typeof window.InstallTrigger !== 'undefined' || isSafari) { // maybe \"isEdge?\"\n        peer.getStats(window.mediaStreamTrack || null).then(function(res) {\n            var items = [];\n            res.forEach(function(r) {\n                items.push(r);\n            });\n            cb(items);\n        }).catch(cb);\n    } else {\n        peer.getStats(function(res) {\n            var items = [];\n            res.result().forEach(function(res) {\n                var item = {};\n                res.names().forEach(function(name) {\n                    item[name] = res.stat(name);\n                });\n                item.id = res.id;\n                item.type = res.type;\n                item.timestamp = res.timestamp;\n                items.push(item);\n            });\n            cb(items);\n        });\n    } */\n  }\n\n  function getStatsLooper() {\n    getStatsWrapper((results) => {\n      if (!results || !results.forEach) return;\n      // Log.d('getStats~getStatsLooper', results);\n      results.forEach((result) => {\n        // console.error('result', result);\n        Object.keys(getStatsParser).forEach((key) => {\n          Log.d(key);\n          if (typeof getStatsParser[key] === 'function') {\n            try {\n              getStatsParser[key](result);\n            } catch (e) {\n              // console.error(e.message, e.stack, e);\n              // Log.e(e);\n              Log.d('getStats~error', results);\n            }\n          }\n        });\n      });\n\n      try {\n        if (peer.iceConnectionState.search(/failed|closed|disconnected/gi) !== -1) {\n          nomore = true;\n        }\n      } catch (e) {\n        nomore = true;\n      }\n\n      if (nomore === true) {\n        if (getStatsResult.datachannel) {\n          getStatsResult.datachannel.state = 'close';\n        }\n        getStatsResult.ended = true;\n      }\n\n      // allow users to access native results\n      getStatsResult.results = results;\n\n      if (getStatsResult.audio && getStatsResult.video) {\n        getStatsResult.bandwidth.speed = (\n          getStatsResult.audio.bytesSent - getStatsResult.bandwidth.helper.audioBytesSent\n        ) + (getStatsResult.video.bytesSent - getStatsResult.bandwidth.helper.videoBytesSent);\n        getStatsResult.bandwidth.helper.audioBytesSent = getStatsResult.audio.bytesSent;\n        getStatsResult.bandwidth.helper.videoBytesSent = getStatsResult.video.bytesSent;\n      }\n\n      callback(getStatsResult);\n\n      // second argument checks to see, if target-user is still connected.\n      if (!nomore && typeof interval !== 'undefined' && interval) {\n        setTimeout(getStatsLooper, interval || 1000);\n      }\n    });\n  }\n\n  getStatsParser.datachannel = function (result) {\n    if (result.type !== 'datachannel') return;\n\n    getStatsResult.datachannel = {\n      state: result.state // open or connecting\n    };\n  };\n\n  getStatsParser.googCertificate = function (result) {\n    if (result.type === 'googCertificate') {\n      getStatsResult.encryption = result.googFingerprintAlgorithm;\n    }\n\n    // Safari-11 or higher\n    if (result.type === 'certificate') {\n      // todo: is it possible to have different encryption methods for senders and receivers?\n      // if yes, then we need to set:\n      //    getStatsResult.encryption.local = value;\n      //    getStatsResult.encryption.remote = value;\n      getStatsResult.encryption = result.fingerprintAlgorithm;\n    }\n  };\n\n  getStatsParser.checkAudioTracks = function (result) {\n    if (result.mediaType !== 'audio') return;\n\n    let sendrecvType = result.id.split('_').pop();\n    if (result.isRemote === true) {\n      sendrecvType = 'recv';\n    }\n    if (result.isRemote === false) {\n      sendrecvType = 'send';\n    }\n\n    if (!sendrecvType) return;\n\n    if (getStatsResult.audio[sendrecvType].codecs.indexOf(result.googCodecName || 'opus') === -1) {\n      getStatsResult.audio[sendrecvType].codecs.push(result.googCodecName || 'opus');\n    }\n\n    if (result.bytesSent) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.audio[sendrecvType].prevBytesSent) {\n        getStatsResult.internal.audio[sendrecvType].prevBytesSent = result.bytesSent;\n      }\n\n      var bytes = result.bytesSent - getStatsResult.internal.audio[sendrecvType].prevBytesSent;\n      getStatsResult.internal.audio[sendrecvType].prevBytesSent = result.bytesSent;\n\n      kilobytes = bytes / 1024;\n      getStatsResult.audio[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult.audio.bytesSent = kilobytes.toFixed(1);\n    }\n\n    if (result.bytesReceived) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.audio[sendrecvType].prevBytesReceived) {\n        getStatsResult.internal.audio[sendrecvType].prevBytesReceived = result.bytesReceived;\n      }\n\n      var bytes = result.bytesReceived - getStatsResult.internal.audio[sendrecvType].prevBytesReceived;\n      getStatsResult.internal.audio[sendrecvType].prevBytesReceived = result.bytesReceived;\n\n      kilobytes = bytes / 1024;\n\n      // getStatsResult.audio[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult.audio.bytesReceived = kilobytes.toFixed(1);\n    }\n\n    if (result.googTrackId && getStatsResult.audio[sendrecvType].tracks.indexOf(result.googTrackId) === -1) {\n      getStatsResult.audio[sendrecvType].tracks.push(result.googTrackId);\n    }\n\n    // calculate latency\n    if (result.googCurrentDelayMs) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.audio.prevGoogCurrentDelayMs) {\n        getStatsResult.internal.audio.prevGoogCurrentDelayMs = result.googCurrentDelayMs;\n      }\n\n      var bytes = result.googCurrentDelayMs - getStatsResult.internal.audio.prevGoogCurrentDelayMs;\n      getStatsResult.internal.audio.prevGoogCurrentDelayMs = result.googCurrentDelayMs;\n\n      getStatsResult.audio.latency = bytes.toFixed(1);\n\n      if (getStatsResult.audio.latency < 0) {\n        getStatsResult.audio.latency = 0;\n      }\n    }\n\n    // calculate packetsLost\n    if (result.packetsLost) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.audio.prevPacketsLost) {\n        getStatsResult.internal.audio.prevPacketsLost = result.packetsLost;\n      }\n\n      var bytes = result.packetsLost - getStatsResult.internal.audio.prevPacketsLost;\n      getStatsResult.internal.audio.prevPacketsLost = result.packetsLost;\n\n      getStatsResult.audio.packetsLost = bytes.toFixed(1);\n\n      if (getStatsResult.audio.packetsLost < 0) {\n        getStatsResult.audio.packetsLost = 0;\n      }\n    }\n  };\n\n  getStatsParser.checkVideoTracks = function (result) {\n    if (result.mediaType !== 'video') return;\n\n    let sendrecvType = result.id.split('_').pop();\n    if (result.isRemote === true) {\n      sendrecvType = 'recv';\n    }\n    if (result.isRemote === false) {\n      sendrecvType = 'send';\n    }\n\n    if (!sendrecvType) return;\n\n    if (getStatsResult.video[sendrecvType].codecs.indexOf(result.googCodecName || 'VP8') === -1) {\n      getStatsResult.video[sendrecvType].codecs.push(result.googCodecName || 'VP8');\n    }\n\n    if (result.bytesSent) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.video[sendrecvType].prevBytesSent) {\n        getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent;\n      }\n\n      var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBytesSent;\n      getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent;\n\n      kilobytes = bytes / 1024;\n\n      getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult.video.bytesSent = kilobytes.toFixed(1);\n    }\n\n    if (result.bytesReceived) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.video[sendrecvType].prevBytesReceived) {\n        getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived;\n      }\n\n      var bytes = result.bytesReceived - getStatsResult.internal.video[sendrecvType].prevBytesReceived;\n      getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived;\n\n      kilobytes = bytes / 1024;\n      // getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult.video.bytesReceived = kilobytes.toFixed(1);\n    }\n\n    if (result.googFrameHeightReceived && result.googFrameWidthReceived) {\n      getStatsResult.resolutions[sendrecvType].width = result.googFrameWidthReceived;\n      getStatsResult.resolutions[sendrecvType].height = result.googFrameHeightReceived;\n    }\n\n    if (result.googFrameHeightSent && result.googFrameWidthSent) {\n      getStatsResult.resolutions[sendrecvType].width = result.googFrameWidthSent;\n      getStatsResult.resolutions[sendrecvType].height = result.googFrameHeightSent;\n    }\n\n    if (result.googTrackId && getStatsResult.video[sendrecvType].tracks.indexOf(result.googTrackId) === -1) {\n      getStatsResult.video[sendrecvType].tracks.push(result.googTrackId);\n    }\n\n    if (result.framerateMean) {\n      getStatsResult.bandwidth.framerateMean = result.framerateMean;\n      var kilobytes = 0;\n      if (!getStatsResult.internal.video[sendrecvType].prevFramerateMean) {\n        getStatsResult.internal.video[sendrecvType].prevFramerateMean = result.bitrateMean;\n      }\n\n      var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevFramerateMean;\n      getStatsResult.internal.video[sendrecvType].prevFramerateMean = result.framerateMean;\n\n      kilobytes = bytes / 1024;\n      getStatsResult.video[sendrecvType].framerateMean = bytes.toFixed(1);\n    }\n\n    if (result.bitrateMean) {\n      getStatsResult.bandwidth.bitrateMean = result.bitrateMean;\n      var kilobytes = 0;\n      if (!getStatsResult.internal.video[sendrecvType].prevBitrateMean) {\n        getStatsResult.internal.video[sendrecvType].prevBitrateMean = result.bitrateMean;\n      }\n\n      var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBitrateMean;\n      getStatsResult.internal.video[sendrecvType].prevBitrateMean = result.bitrateMean;\n\n      kilobytes = bytes / 1024;\n      getStatsResult.video[sendrecvType].bitrateMean = bytes.toFixed(1);\n    }\n\n    // calculate latency\n    if (result.googCurrentDelayMs) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.video.prevGoogCurrentDelayMs) {\n        getStatsResult.internal.video.prevGoogCurrentDelayMs = result.googCurrentDelayMs;\n      }\n\n      var bytes = result.googCurrentDelayMs - getStatsResult.internal.video.prevGoogCurrentDelayMs;\n      getStatsResult.internal.video.prevGoogCurrentDelayMs = result.googCurrentDelayMs;\n\n      getStatsResult.video.latency = bytes.toFixed(1);\n\n      if (getStatsResult.video.latency < 0) {\n        getStatsResult.video.latency = 0;\n      }\n    }\n\n    // calculate packetsLost\n    if (result.packetsLost) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal.video.prevPacketsLost) {\n        getStatsResult.internal.video.prevPacketsLost = result.packetsLost;\n      }\n\n      var bytes = result.packetsLost - getStatsResult.internal.video.prevPacketsLost;\n      getStatsResult.internal.video.prevPacketsLost = result.packetsLost;\n\n      getStatsResult.video.packetsLost = bytes.toFixed(1);\n\n      if (getStatsResult.video.packetsLost < 0) {\n        getStatsResult.video.packetsLost = 0;\n      }\n    }\n  };\n\n  getStatsParser.bweforvideo = function (result) {\n    if (result.type !== 'VideoBwe') return;\n\n    getStatsResult.bandwidth.availableSendBandwidth = result.googAvailableSendBandwidth;\n\n    getStatsResult.bandwidth.googActualEncBitrate = result.googActualEncBitrate;\n    getStatsResult.bandwidth.googAvailableSendBandwidth = result.googAvailableSendBandwidth;\n    getStatsResult.bandwidth.googAvailableReceiveBandwidth = result.googAvailableReceiveBandwidth;\n    getStatsResult.bandwidth.googRetransmitBitrate = result.googRetransmitBitrate;\n    getStatsResult.bandwidth.googTargetEncBitrate = result.googTargetEncBitrate;\n    getStatsResult.bandwidth.googBucketDelay = result.googBucketDelay;\n    getStatsResult.bandwidth.googTransmitBitrate = result.googTransmitBitrate;\n  };\n\n  getStatsParser.candidatePair = function (result) {\n    if (result.type !== 'googCandidatePair' && result.type !== 'candidate-pair' && result.type !== 'local-candidate' && result.type !== 'remote-candidate') return;\n\n    // result.googActiveConnection means either STUN or TURN is used.\n\n    if (result.googActiveConnection == 'true') {\n      // id === 'Conn-audio-1-0'\n      // localCandidateId, remoteCandidateId\n\n      // bytesSent, bytesReceived\n\n      Object.keys(getStatsResult.internal.candidates).forEach((cid) => {\n        const candidate = getStatsResult.internal.candidates[cid];\n        if (candidate.ipAddress.indexOf(result.googLocalAddress) !== -1) {\n          getStatsResult.connectionType.local.candidateType = candidate.candidateType;\n          getStatsResult.connectionType.local.ipAddress = candidate.ipAddress;\n          getStatsResult.connectionType.local.networkType = candidate.networkType;\n          getStatsResult.connectionType.local.transport = candidate.transport;\n        }\n        if (candidate.ipAddress.indexOf(result.googRemoteAddress) !== -1) {\n          getStatsResult.connectionType.remote.candidateType = candidate.candidateType;\n          getStatsResult.connectionType.remote.ipAddress = candidate.ipAddress;\n          getStatsResult.connectionType.remote.networkType = candidate.networkType;\n          getStatsResult.connectionType.remote.transport = candidate.transport;\n        }\n      });\n\n      getStatsResult.connectionType.transport = result.googTransportType;\n\n      var localCandidate = getStatsResult.internal.candidates[result.localCandidateId];\n      if (localCandidate) {\n        if (localCandidate.ipAddress) {\n          getStatsResult.connectionType.systemIpAddress = localCandidate.ipAddress;\n        }\n      }\n\n      var remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];\n      if (remoteCandidate) {\n        if (remoteCandidate.ipAddress) {\n          getStatsResult.connectionType.systemIpAddress = remoteCandidate.ipAddress;\n        }\n      }\n    }\n\n    if (result.type === 'candidate-pair') {\n      if (result.selected === true && result.nominated === true && result.state === 'succeeded') {\n        // remoteCandidateId, localCandidateId, componentId\n        var localCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];\n        var remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];\n\n        // Firefox used above two pairs for connection\n      }\n    }\n\n    if (result.type === 'local-candidate') {\n      getStatsResult.connectionType.local.candidateType = result.candidateType;\n      getStatsResult.connectionType.local.ipAddress = result.ipAddress;\n      getStatsResult.connectionType.local.networkType = result.networkType;\n      getStatsResult.connectionType.local.transport = result.mozLocalTransport || result.transport;\n    }\n\n    if (result.type === 'remote-candidate') {\n      getStatsResult.connectionType.remote.candidateType = result.candidateType;\n      getStatsResult.connectionType.remote.ipAddress = result.ipAddress;\n      getStatsResult.connectionType.remote.networkType = result.networkType;\n      getStatsResult.connectionType.remote.transport = result.mozRemoteTransport || result.transport;\n    }\n\n    if (isSafari) {\n      // result.remoteCandidateId\n      // todo: below line will always force \"send\" on Safari; find a solution\n      const sendrecvType = result.localCandidateId ? 'send' : 'recv';\n\n      if (!sendrecvType) return;\n\n      if (result.bytesSent) {\n        var kilobytes = 0;\n        if (!getStatsResult.internal.video[sendrecvType].prevBytesSent) {\n          getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent;\n        }\n\n        var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBytesSent;\n        getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent;\n\n        kilobytes = bytes / 1024;\n\n        getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n        getStatsResult.video.bytesSent = kilobytes.toFixed(1);\n      }\n\n      if (result.bytesReceived) {\n        var kilobytes = 0;\n        if (!getStatsResult.internal.video[sendrecvType].prevBytesReceived) {\n          getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived;\n        }\n\n        var bytes = result.bytesReceived - getStatsResult.internal.video[sendrecvType].prevBytesReceived;\n        getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived;\n\n        kilobytes = bytes / 1024;\n        // getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n        getStatsResult.video.bytesReceived = kilobytes.toFixed(1);\n      }\n\n      if (result.availableOutgoingBitrate) {\n        var kilobytes = 0;\n        if (!getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate) {\n          getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate = result.availableOutgoingBitrate;\n        }\n\n        var bytes = result.availableOutgoingBitrate - getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate;\n        getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate = result.availableOutgoingBitrate;\n\n        kilobytes = bytes / 1024;\n        // getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n        getStatsResult.video.availableOutgoingBitrate = kilobytes.toFixed(1);\n      }\n\n      if (result.availableIncomingBitrate) {\n        var kilobytes = 0;\n        if (!getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate) {\n          getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate = result.availableIncomingBitrate;\n        }\n\n        var bytes = result.availableIncomingBitrate - getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate;\n        getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate = result.availableIncomingBitrate;\n\n        kilobytes = bytes / 1024;\n        // getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n        getStatsResult.video.availableIncomingBitrate = kilobytes.toFixed(1);\n      }\n    }\n  };\n\n  const LOCAL_candidateType = {};\n  const LOCAL_transport = {};\n  const LOCAL_ipAddress = {};\n  const LOCAL_networkType = {};\n\n  getStatsParser.localcandidate = function (result) {\n    if (result.type !== 'localcandidate' && result.type !== 'local-candidate') return;\n    if (!result.id) return;\n\n    if (!LOCAL_candidateType[result.id]) {\n      LOCAL_candidateType[result.id] = [];\n    }\n\n    if (!LOCAL_transport[result.id]) {\n      LOCAL_transport[result.id] = [];\n    }\n\n    if (!LOCAL_ipAddress[result.id]) {\n      LOCAL_ipAddress[result.id] = [];\n    }\n\n    if (!LOCAL_networkType[result.id]) {\n      LOCAL_networkType[result.id] = [];\n    }\n\n    if (result.candidateType && LOCAL_candidateType[result.id].indexOf(result.candidateType) === -1) {\n      LOCAL_candidateType[result.id].push(result.candidateType);\n    }\n\n    if (result.transport && LOCAL_transport[result.id].indexOf(result.transport) === -1) {\n      LOCAL_transport[result.id].push(result.transport);\n    }\n\n    if (result.ipAddress && LOCAL_ipAddress[result.id].indexOf(`${result.ipAddress}:${result.portNumber}`) === -1) {\n      LOCAL_ipAddress[result.id].push(`${result.ipAddress}:${result.portNumber}`);\n    }\n\n    if (result.networkType && LOCAL_networkType[result.id].indexOf(result.networkType) === -1) {\n      LOCAL_networkType[result.id].push(result.networkType);\n    }\n\n    getStatsResult.internal.candidates[result.id] = {\n      candidateType: LOCAL_candidateType[result.id],\n      ipAddress: LOCAL_ipAddress[result.id],\n      portNumber: result.portNumber,\n      networkType: LOCAL_networkType[result.id],\n      priority: result.priority,\n      transport: LOCAL_transport[result.id],\n      timestamp: result.timestamp,\n      id: result.id,\n      type: result.type\n    };\n\n    getStatsResult.connectionType.local.candidateType = LOCAL_candidateType[result.id];\n    getStatsResult.connectionType.local.ipAddress = LOCAL_ipAddress[result.id];\n    getStatsResult.connectionType.local.networkType = LOCAL_networkType[result.id];\n    getStatsResult.connectionType.local.transport = LOCAL_transport[result.id];\n  };\n\n  const REMOTE_candidateType = {};\n  const REMOTE_transport = {};\n  const REMOTE_ipAddress = {};\n  const REMOTE_networkType = {};\n\n  getStatsParser.remotecandidate = function (result) {\n    if (result.type !== 'remotecandidate' && result.type !== 'remote-candidate') return;\n    if (!result.id) return;\n\n    if (!REMOTE_candidateType[result.id]) {\n      REMOTE_candidateType[result.id] = [];\n    }\n\n    if (!REMOTE_transport[result.id]) {\n      REMOTE_transport[result.id] = [];\n    }\n\n    if (!REMOTE_ipAddress[result.id]) {\n      REMOTE_ipAddress[result.id] = [];\n    }\n\n    if (!REMOTE_networkType[result.id]) {\n      REMOTE_networkType[result.id] = [];\n    }\n\n    if (result.candidateType && REMOTE_candidateType[result.id].indexOf(result.candidateType) === -1) {\n      REMOTE_candidateType[result.id].push(result.candidateType);\n    }\n\n    if (result.transport && REMOTE_transport[result.id].indexOf(result.transport) === -1) {\n      REMOTE_transport[result.id].push(result.transport);\n    }\n\n    if (result.ipAddress && REMOTE_ipAddress[result.id].indexOf(`${result.ipAddress}:${result.portNumber}`) === -1) {\n      REMOTE_ipAddress[result.id].push(`${result.ipAddress}:${result.portNumber}`);\n    }\n\n    if (result.networkType && REMOTE_networkType[result.id].indexOf(result.networkType) === -1) {\n      REMOTE_networkType[result.id].push(result.networkType);\n    }\n\n    getStatsResult.internal.candidates[result.id] = {\n      candidateType: REMOTE_candidateType[result.id],\n      ipAddress: REMOTE_ipAddress[result.id],\n      portNumber: result.portNumber,\n      networkType: REMOTE_networkType[result.id],\n      priority: result.priority,\n      transport: REMOTE_transport[result.id],\n      timestamp: result.timestamp,\n      id: result.id,\n      type: result.type\n    };\n\n    getStatsResult.connectionType.remote.candidateType = REMOTE_candidateType[result.id];\n    getStatsResult.connectionType.remote.ipAddress = REMOTE_ipAddress[result.id];\n    getStatsResult.connectionType.remote.networkType = REMOTE_networkType[result.id];\n    getStatsResult.connectionType.remote.transport = REMOTE_transport[result.id];\n  };\n\n  getStatsParser.dataSentReceived = function (result) {\n    if (!result.googCodecName || (result.mediaType !== 'video' && result.mediaType !== 'audio')) return;\n\n    if (result.bytesSent) {\n      getStatsResult[result.mediaType].bytesSent = parseInt(result.bytesSent);\n    }\n\n    if (result.bytesReceived) {\n      getStatsResult[result.mediaType].bytesReceived = parseInt(result.bytesReceived);\n    }\n  };\n\n  getStatsParser.inboundrtp = function (result) {\n    if (!isSafari) return;\n    if (result.type !== 'inbound-rtp') return;\n\n    const mediaType = result.mediaType || 'audio';\n    const sendrecvType = result.isRemote ? 'recv' : 'send';\n\n    if (!sendrecvType) return;\n\n    if (result.bytesSent) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal[mediaType][sendrecvType].prevBytesSent) {\n        getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;\n      }\n\n      var bytes = result.bytesSent - getStatsResult.internal[mediaType][sendrecvType].prevBytesSent;\n      getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;\n\n      kilobytes = bytes / 1024;\n\n      getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult[mediaType].bytesSent = kilobytes.toFixed(1);\n    }\n\n    if (result.bytesReceived) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived) {\n        getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;\n      }\n\n      var bytes = result.bytesReceived - getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived;\n      getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;\n\n      kilobytes = bytes / 1024;\n      // getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult[mediaType].bytesReceived = kilobytes.toFixed(1);\n    }\n  };\n\n  getStatsParser.outboundrtp = function (result) {\n    if (!isSafari) return;\n    if (result.type !== 'outbound-rtp') return;\n\n    const mediaType = result.mediaType || 'audio';\n    const sendrecvType = result.isRemote ? 'recv' : 'send';\n\n    if (!sendrecvType) return;\n\n    if (result.bytesSent) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal[mediaType][sendrecvType].prevBytesSent) {\n        getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;\n      }\n\n      var bytes = result.bytesSent - getStatsResult.internal[mediaType][sendrecvType].prevBytesSent;\n      getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;\n\n      kilobytes = bytes / 1024;\n\n      getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult[mediaType].bytesSent = kilobytes.toFixed(1);\n    }\n\n    if (result.bytesReceived) {\n      var kilobytes = 0;\n      if (!getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived) {\n        getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;\n      }\n\n      var bytes = result.bytesReceived - getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived;\n      getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;\n\n      kilobytes = bytes / 1024;\n      // getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n      getStatsResult[mediaType].bytesReceived = kilobytes.toFixed(1);\n    }\n  };\n\n  getStatsParser.track = function (result) {\n    if (!isSafari) return;\n    if (result.type !== 'track') return;\n\n    const sendrecvType = result.remoteSource === true ? 'send' : 'recv';\n\n    if (result.frameWidth && result.frameHeight) {\n      getStatsResult.resolutions[sendrecvType].width = result.frameWidth;\n      getStatsResult.resolutions[sendrecvType].height = result.frameHeight;\n    }\n\n    // framesSent, framesReceived\n  };\n\n  const SSRC = {\n    audio: {\n      send: [],\n      recv: []\n    },\n    video: {\n      send: [],\n      recv: []\n    }\n  };\n\n  getStatsParser.ssrc = function (result) {\n    if (!result.googCodecName || (result.mediaType !== 'video' && result.mediaType !== 'audio')) return;\n    if (result.type !== 'ssrc') return;\n    const sendrecvType = result.id.split('_').pop();\n\n    if (SSRC[result.mediaType][sendrecvType].indexOf(result.ssrc) === -1) {\n      SSRC[result.mediaType][sendrecvType].push(result.ssrc);\n    }\n\n    getStatsResult[result.mediaType][sendrecvType].streams = SSRC[result.mediaType][sendrecvType].length;\n  };\n\n  getStatsLooper();\n};\n\nexport default GetStats;\n/* eslint-enable */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/webrtc/GetStats.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 355,
    "kind": "function",
    "name": "GetStats",
    "memberof": "src/core/webrtc/GetStats.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/webrtc/GetStats.js~GetStats",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/webrtc/GetStats.js",
    "importStyle": "GetStats",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "mediaStreamTrack",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      },
      {
        "name": "interval",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 356,
    "kind": "file",
    "name": "src/core/webrtc/PeerConnection.js",
    "content": "/* global RTCPeerConnection */\n/* global RTCRtpSender */\nimport SocketIO from 'socket.io-client';\nimport cache from '../util/cache';\nimport * as Log from '../util/Log';\nimport Media from '../util/Media';\nimport Device from '../Device';\nimport * as DataSync from '../util/DataSync';\nimport { CLOSED, CLOSING, OPENED } from '../util/constants';\nimport GetStats from './GetStats';\nimport 'core-js/fn/array/find';\n\nconst DtlsSrtpKeyAgreement = { DtlsSrtpKeyAgreement: true };\nconst sdpConstraints = receive => ({ OfferToReceiveAudio: receive, OfferToReceiveVideo: receive });\n/**\n * ICE connection status : disconnected\n * @constant\n * @type {string}\n */\nconst ICE_CONNECTION_STATE_DISCONNECTED = 'disconnected';\n/**\n * ICE connection status : connected\n * @constant\n * @type {string}\n */\nconst ICE_CONNECTION_STATE_CONNECTED = 'connected';\n/**\n * ICE connection status : completed\n * @constant\n * @type {string}\n */\nconst ICE_CONNECTION_STATE_COMPLETED = 'completed';\n/**\n * ICE connection status : checking\n * @constant\n * @type {string}\n */\nconst ICE_CONNECTION_STATE_CHECKING = 'checking';\n/**\n * ICE connection status : closed\n * @constant\n * @type {string}\n */\nconst ICE_CONNECTION_STATE_CLOSED = 'closed';\n/**\n * ICE connection status : failed\n * @constant\n * @type {string}\n */\nconst ICE_CONNECTION_STATE_FAILED = 'failed';\n/**\n * ICE connection status : another status\n * @constant\n * @type {string}\n */\nconst ICE_CONNECTION_STATE_OTHER = 'other';\n/**\n * @ignore\n */\nconst _toJSON = o => (o.toJSON && typeof o.toJSON === 'function' ? o.toJSON() : o);\n/**\n * The PeerConnection. A PeerConnection will only concern one MediaStream.\n * @class PeerConnection\n */\nexport default class PeerConnection {\n  /**\n   * @access protected\n   * @param {string} stackId The WebRTC stack ID\n   * @param {string} streamId The Stream UID\n   * @param {Remote|{to: string|from: string, device:string}} remote The remote information\n   * @param {boolean} publish Publish or Subscribe ?\n   */\n  constructor(stackId, streamId, remote, publish) {\n    /**\n     * The stack identifier. Used to identify exchanges between 2 devices\n     * @type {string}\n     */\n    this.stackId = stackId;\n    /**\n     * The stream id. (One stream per RTCPeerConnection)\n     * @type {string}\n     */\n    this.streamId = streamId;\n    /**\n     * The remote device\n     * @type {string}\n     */\n    this.remote = remote;\n    /**\n     * publish : a created peer connection or a remote one\n     * @type {boolean}\n     */\n    this.publish = publish;\n    /**\n     * Path for local signalization\n     * @access private\n     * @type {string}\n     */\n    this._localPath = `_/webrtc/${this.stackId}/${this.streamId}/${cache.device}`;\n    /**\n     * Path for local signalization\n     * @access private\n     * @type {string}\n     */\n    this._remotePath = `_/webrtc/${this.stackId}/${this.streamId}/${this.remote.device}`;\n    /**\n     * Indicates if the PeerConnection has been established. (Useful for renegotiation).\n     * @type {boolean}\n     */\n    this.negotiated = false;\n    /**\n     * The DOM element where the remote MediaStream will be displayed\n     * @type {Element}\n     * @protected\n     */\n    this.node = null;\n    /**\n     * The DOM element containg the media element\n     * @type {Element}\n     * @protected\n     */\n    this.container = null;\n    /**\n     * The actual RTCPeerConnection\n     * @type {RTCPeerConnection}\n     */\n    this.pc = new RTCPeerConnection(\n      {\n        iceServers: cache.config.iceServers\n      },\n      {\n        optional: [DtlsSrtpKeyAgreement],\n        mandatory: sdpConstraints(!publish)\n      }\n    );\n    // Handle ICE candidates\n    this.pc.onicecandidate = (e) => {\n      if (!this.negotiated && e.candidate) {\n        Log.d('PeerConnection~onicecandidate', e.candidate);\n        DataSync.push(`${this._localPath}/ice`, _toJSON(e.candidate));\n      }\n    };\n    this.pc.oniceconnectionstatechange = () => {\n      Log.d('PeerConnection~oniceconnectionstatechange', this.pc);\n      const { iceConnectionState } = this.pc;\n      switch (iceConnectionState) {\n        case ICE_CONNECTION_STATE_CHECKING:\n          // Nothing to do yet\n          break;\n        case ICE_CONNECTION_STATE_CONNECTED:\n          this._attachStream();\n          this._remoteICECandidates(false);\n          this._getStats();\n          break;\n        case ICE_CONNECTION_STATE_COMPLETED:\n          this._remoteICECandidates(false);\n          break;\n        case ICE_CONNECTION_STATE_DISCONNECTED:\n        case ICE_CONNECTION_STATE_FAILED:\n          Log.e('PeerConnection~stateDisconnected', 'Disconnect PeerConnection');\n          break;\n        case ICE_CONNECTION_STATE_CLOSED:\n          Log.d('PeerConnection~stateclosed', 'Close PeerConnection');\n          this.close();\n          break;\n        default:\n          break;\n      }\n      this.negotiated = this.negotiated || this.isConnected;\n    };\n\n    this.pc.onicegatheringstatechange = () => {\n      Log.d('PeerConnection~onicegatheringstatechange', this.pc.iceGatheringState);\n    };\n\n    /**\n     * PeerConnection status\n     * @type {string}\n     * @private\n     */\n    this._status = OPENED;\n  }\n\n  _getStats() {\n    Log.d('PeerConnection~getStats',\n      `enable : ${cache.config.stats.server && cache.config.stats.interval\n        ? `to ${cache.config.stats.server}`\n        : 'false'}`);\n    if (cache.config.stats.server && cache.config.stats.interval) {\n      // this._socket = SocketIO(cache.config.stats.server);\n      GetStats(this.pc, (result) => {\n        this.socket.emit('stats', Object.assign({\n          id: this.streamId,\n          publish: this.publish,\n          room: cache.room.name,\n          ts: new Date(),\n          local: cache.device,\n          remote: this.remote.device\n        }, result));\n      }, cache.config.stats.interval);\n    }\n  }\n\n  get socket() {\n    if (!this._socket) {\n      this._socket = SocketIO(cache.config.stats.server);\n    }\n    return this._socket;\n  }\n\n  /**\n   * Toggle ICE Candidates discovery\n   * @access private\n   * @param {boolean} listen Indicates if we should listen to new ICE candidates\n   */\n  _remoteICECandidates(listen) {\n    const\n      path = `${this._remotePath}/ice`;\n\n\n    const event = 'child_added';\n    if (listen) {\n      // don't listen to ice candidates if pc is already up (renegotiation)\n      DataSync.on(path, event, (snap) => {\n        const candidate = snap.val();\n        Log.d('PeerConnection~addIceCandidate', candidate);\n        this.pc.addIceCandidate(new RTCIceCandidate(candidate));\n      });\n    } else {\n      DataSync.off(path, event);\n    }\n  }\n\n  /**\n   * Attach the remote MediaStream to a node\n   * @access private\n   */\n  _attachStream() {\n    if (this.remoteStream && this.isConnected) {\n      this.node = Media.attachStream(this.remoteStream, this.container, this.node);\n      this.node.muted = false;\n    }\n  }\n\n  /**\n   * The remote MediaStream\n   * @access protected\n   * @type {MediaStream}\n   */\n  set remoteStream(stream) {\n    /**\n     * @ignore\n     */\n    this._remoteStream = stream;\n    this._attachStream();\n  }\n\n  /**\n   * The remote MediaStream\n   * @type {MediaStream}\n   */\n  get remoteStream() {\n    return this._remoteStream;\n  }\n\n  /**\n   * Indicates if the PeerConnection is established based on ICE connection state\n   * @returns {boolean}\n   */\n  get isConnected() {\n    return this.pc\n      && !!~[ // eslint-disable-line no-bitwise\n        ICE_CONNECTION_STATE_CONNECTED,\n        ICE_CONNECTION_STATE_COMPLETED,\n        ICE_CONNECTION_STATE_OTHER\n      ].indexOf(this.pc.iceConnectionState);\n  }\n\n  /**\n   * Init RTCPeerConnection for subscribers\n   * @access protected\n   * @param htmlElement\n   * @returns {Promise.<PeerConnection>}\n   */\n  answer(htmlElement) {\n    Log.i('PeerConnection~answer', { htmlElement, peerConnection: this });\n    this.container = htmlElement;\n    if (Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, 'ontrack')) {\n      this.pc.ontrack = (e) => {\n        Log.d('PeerConnection~ontrack', e.streams[0]);\n        this.remoteStream = e.streams[0]; // eslint-disable-line prefer-destructuring\n      };\n    } else {\n      this.pc.onaddstream = (e) => {\n        Log.d('PeerConnection~onaddstream', e.stream);\n        this.remoteStream = e.stream;\n      };\n    }\n\n    // Listen to SDP offer\n    DataSync.on(`${this._remotePath}/sdp`, 'value', (snap) => {\n      const sdpOffer = snap.val();\n      // Log.d('Offer', sdpOffer);\n      if (sdpOffer != null) {\n        Log.d(`PeerConnection~offered ${sdpOffer.sdp}`);\n        this.pc.setRemoteDescription(sdpOffer)\n          .then(() => Log.d('PeerConnection~answer#remoteDescription', this.pc.remoteDescription.sdp))\n          .then(() => {\n            if (/^offer$/.test(this.pc.remoteDescription.type)) {\n              return this.pc.createAnswer();\n            }\n            return Promise.reject(new Error('SDP is not an offer'));\n          })\n          .then(description => this._setPreferredCodecs(description))\n          .then(description => this.pc.setLocalDescription(description))\n          .then(() => {\n            Log.d('PeerConnection~answer#localSDP', this.pc.localDescription.sdp);\n            this._remoteICECandidates(true);\n          })\n          .then(() => this._sendSdpToRemote())\n          // .catch(Log.r('PeerConnection~answser#error'));\n          .catch(() => {\n            // this.close();\n            cache.peerConnections.close(this.streamId, this.remote.device);\n          });\n      }\n    });\n\n    return Promise.resolve(this);\n  }\n\n  /**\n   * Init RTCPeerConnection for publishers\n   * @access protected\n   * @param stream\n   * @returns {Promise.<PeerConnection>}\n   */\n  offer(stream) {\n    Log.i('PeerConnection~offer', { stream, peerConnection: this });\n    let sendTimeout;\n    return new Promise((resolve, reject) => {\n      this.pc.onnegotiationneeded = () => {\n        Log.d('PeerConnection~onnegotiationneeded');\n        // Debounce send (renegotiation triggers multiple negotiationneeded events)\n        if (sendTimeout) {\n          clearTimeout(sendTimeout);\n          sendTimeout = null;\n        }\n        sendTimeout = setTimeout(() => {\n          sendTimeout = null;\n          this._sendOffer()\n            .then(() => {\n              resolve(this);\n            })\n            .catch((e) => {\n              Log.d('PeerConnection~offer', e);\n              reject(e);\n            });\n        }, 20);\n      };\n      DataSync.on(`${this._remotePath}/sdp`, 'value', (snap) => {\n        const sdpAnswer = snap.val();\n        if (sdpAnswer != null) {\n          Log.d(`PeerConnection~offer#answered ${sdpAnswer.sdp}`);\n          this.pc.setRemoteDescription(sdpAnswer)\n            .then(() => {\n              Log.d('PeerConnection~offer#remoteDescription', this.pc.remoteDescription.sdp);\n              this._remoteICECandidates(true);\n            })\n            .catch(Log.e.bind(Log, 'PeerConnection~offer#remoteDescription'));\n        }\n      });\n      this._alterStream(stream, 'add');\n    });\n  }\n\n  /**\n   * Edits the SDP to set the preferred audio/video codec\n   * @access private\n   * @param {string} sdp The sdp to be modified\n   * @returns {string}}\n   */\n\n  /* _addVP8Codec(sdp) {\n        let sdpresult = sdp;\n        // Log.d('PeerConnection~_addVP8Codec');\n        if (sdpresult === null) { return null; }\n        const sdpLines = sdpresult.split(/\\r?\\n/);\n        const medias = {audio: [], video: []};\n        let current = null;\n        let vp8InVideoList = false;\n        let h264InVideoList = false;\n        let lastIndex = 0;\n        let firstIndex = 0;\n        // Parse SDP\n        sdpLines.forEach((sdpLine, i) => {\n            if(/^m=video/.test(sdpLine)) {\n                const d = /^m=(\\w+)\\s[0-9\\/]+\\s[A-Za-z0-9\\/]+\\s([0-9\\s]+)/.exec(sdpLine);\n                current = { fmt: d[2].split(/\\s/), index: i, codecs: [] };\n                medias[d[1]].push(current);\n                lastIndex = current.fmt[current.fmt.length - 1];\n                firstIndex = current.fmt[0];\n            } else if(current && /^a=rtpmap:/.test(sdpLine)) {\n                const c = /^a=rtpmap:(\\d+)\\s([a-zA-Z0-9\\-\\/]+)/.exec(sdpLine);\n                if(c) {\n                    current.codecs.push({ id: c[1], name: c[2], index: i });\n                    if (c[0].toUpperCase().indexOf('VP8') !== -1) { vp8InVideoList=true; }\n                    if (c[0].toUpperCase().indexOf('H264') !== -1) { h264InVideoList=true; }\n                }\n            }\n        });\n        const videoIndex = medias.video[0].index;\n        if (!vp8InVideoList) {\n            // lastIndex++;\n            lastIndex = firstIndex - 1;\n            let essai = sdpLines[videoIndex];\n            for (let media in medias.video[0].fmt) {\n                essai = essai.replace(' '+medias.video[0].fmt[media],'');\n            }\n            essai = essai.concat(' '+lastIndex);\n            for (let media in medias.video[0].fmt) {\n                essai = essai.concat(' '+medias.video[0].fmt[media]);\n            }\n            sdpLines[videoIndex] = essai;\n            sdpresult = sdpLines.join('\\r\\n');\n            sdpresult += `a=rtpmap:${lastIndex} VP8/90000 \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} ccm fir \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} nack \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} nack pli \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} goog-remb \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} transport-cc \\r\\n`;\n        }\n        if (!h264InVideoList) {\n            // lastIndex++;\n            lastIndex = firstIndex - 1;\n            let essai = sdpLines[videoIndex];\n            for (let media in medias.video[0].fmt) {\n                essai = essai.replace(' '+medias.video[0].fmt[media],'');\n            }\n            essai = essai.concat(' '+lastIndex);\n            for (let media in medias.video[0].fmt) {\n                essai = essai.concat(' '+medias.video[0].fmt[media]);\n            }\n            sdpLines[videoIndex] = essai;\n            sdpresult = sdpLines.join('\\r\\n');\n            sdpresult += `a=rtpmap:${lastIndex} H264/90000 \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} ccm fir \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} nack \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} nack pli \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} goog-remb \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} transport-cc \\r\\n`+\n                                            `a=rtcp-fb:${lastIndex} `+\n                                            'level-asymmetry-allowed=1;packetization-mode=1;'+\n                                            'profile-level-id=42e01f \\r\\n';\n        }\n        Log.d('PeerConnection~_addVP8Codec', sdpresult);\n        return sdpresult;\n    } */\n\n  /**\n   * Send SDP offer to the remote via DataSync\n   * @private\n   */\n  _sendSdpToRemote() {\n    // Log.d('PeerConnection~_sendSdpToRemote#localSDP', this.pc.localDescription.sdp);\n    const remoteUserId = this.remote.to ? this.remote.to : this.remote.from;\n    Device.get(remoteUserId, this.remote.device)\n      .then((remoteDevice) => {\n        const sdpOffer = this.pc.localDescription.sdp;\n        let newSdp = sdpOffer;\n        const local = /Chrome\\/([0-9]+)/.exec(navigator.userAgent);\n        const remote = /Chrome\\/([0-9]+)/.exec(remoteDevice.userAgent);\n\n        if (navigator.userAgent.indexOf('Chrome') !== -1\n          && navigator.userAgent.indexOf('Android') !== -1\n          && remoteDevice.userAgent.indexOf('Safari') !== -1\n          && local[1] <= 64) {\n          if (local[1] <= 60) {\n            newSdp = newSdp.replace(/;profile-level-id=([a-z0-9]+)/, '');\n          } else {\n            newSdp = newSdp.replace('42001f', '42e01f');\n          }\n        }\n        if (navigator.userAgent.indexOf('Safari') !== -1\n          && remoteDevice.userAgent.indexOf('Chrome') !== -1\n          && remoteDevice.userAgent.indexOf('Android') !== -1\n          && remote[1] <= 64) {\n          if (remote[1] <= 60) {\n            newSdp = newSdp.replace(/;profile-level-id=([a-z0-9]+)/, '');\n          } else {\n            newSdp = newSdp.replace('42e01f', '42001f');\n          }\n        }\n        Log.d(`PeerConnection~_sendSdpToRemote#SDP sent to remote ${newSdp}`);\n        const descriptionChanged = {\n          sdp: newSdp,\n          type: this.pc.localDescription.type\n        };\n        DataSync.update(`${this._localPath}/sdp`, _toJSON(descriptionChanged));\n      });\n  }\n\n  /**\n   * Create SDP offer and push it\n   * @returns {Promise}\n   * @private\n   */\n  _sendOffer() {\n    Log.d('PeerConnection~_sendOffer');\n    return this.pc.createOffer()\n      .then(description => this._setPreferredCodecs(description))\n      .then(description => this.pc.setLocalDescription(description))\n      .then(() => Log.d('PeerConnection~_sendOffer#localDescription', this.pc.localDescription.sdp))\n      .then(() => this._sendSdpToRemote());\n  }\n\n  /**\n   * Add/Remove tracks to the PeerConnection stream\n   * @param {MediaStream} stream\n   * @param {string} method\n   * @private\n   */\n  _alterStream(stream, method) {\n    if (Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, `${method}Track`)) {\n      if (method === 'add') {\n        stream.getTracks().forEach(track => this.pc[`${method}Track`](track, stream), this);\n      } else {\n        this.pc.getSenders().forEach(sender => this.pc[`${method}Track`](sender), this);\n      }\n    } else {\n      this.pc[`${method}Stream`](stream);\n    }\n  }\n\n  /**\n   * Restart SDP negotiation following a MediaStream change\n   * @access protected\n   * @param {MediaStream} oldStream\n   * @param {MediaStream} newStream\n   */\n  renegotiate(oldStream, newStream) {\n    Log.d('PeerConnection~renegotiate');\n    if ((Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, 'getSenders'))\n      && ('RTCRtpSender' in window)\n      && Object.getOwnPropertyDescriptor(RTCRtpSender.prototype, 'replaceTrack')) {\n      // mozRTCPeerConnection implementation\n      this.pc.getSenders().forEach((sender) => {\n        let newTracks;\n        switch (sender.track.kind) {\n          case 'audio':\n            newTracks = newStream.getAudioTracks();\n            break;\n          case 'video':\n            newTracks = newStream.getVideoTracks();\n            break;\n          default:\n            newTracks = [];\n        }\n        if (newTracks.length) {\n          sender.replaceTrack(newTracks[0]);\n        }\n      });\n      this._sendOffer()\n        .catch((e) => {\n          Log.d('PeerConnection~renegotiate', e);\n        });\n    } else {\n      this._alterStream(oldStream, 'remove');\n      this._alterStream(newStream, 'add');\n    }\n  }\n\n  /**\n   * Close the PeerConnection and stop listening to SDP messages\n   * @access protected\n   */\n  close() {\n    if (this._status === OPENED) {\n      this._status = CLOSING;\n      // Stop display\n      if (this.node) {\n        if (this.node.stop) {\n          this.node.stop();\n        }\n        this.node.srcObject = null;\n        this.container.removeChild(this.node);\n        this.node = null;\n      }\n      // Stop listening to remote ICE candidates\n      this._remoteICECandidates(false);\n      // Stop listening to SDP messages\n      DataSync.off(`${this._remotePath}/sdp`, 'value');\n      // Remove data\n      DataSync.remove(this._localPath);\n      // Close PeerConnection\n      if (this.pc && this.pc.signalingState !== 'closed') {\n        this.pc.onsignalingstatechange = () => {\n          if (this.pc.signalingState !== 'closed') {\n            this._status = CLOSED;\n          }\n        };\n        this.pc.close();\n      } else {\n        this._status = CLOSED;\n      }\n    }\n  }\n\n  /**\n   * Edits the SDP to set the preferred audio/video codec\n   * @access private\n   * @param {RTCSessionDescription} description\n   * The description retrieved by createOffer/createAnswer\n   * @returns {RTCSessionDescription|{sdp: string, type: string}}\n   */\n  _setPreferredCodecs(description) {\n    if (cache.config.preferredVideoCodec || cache.config.preferredAudioCodec) {\n      Log.d('PeerConnection~_setPreferredCodecs', { description, config: cache.config });\n      const sdpLines = description.sdp.split(/\\r?\\n/);\n      const medias = { audio: [], video: [] };\n      let current = null;\n      // Parse SDP\n      sdpLines.forEach((sdpLine, i) => {\n        if (/^m=/.test(sdpLine)) {\n          const d = /^m=(\\w+)\\s[0-9/]+\\s[A-Za-z0-9/]+\\s([0-9\\s]+)/.exec(sdpLine);\n          current = {\n            fmt: d[2].split(/\\s/),\n            index: i,\n            codecs: []\n          };\n          medias[d[1]].push(current);\n        } else if (current && /^a=rtpmap:/.test(sdpLine)) {\n          const c = /^a=rtpmap:(\\d+)\\s([a-zA-Z0-9\\-/]+)/.exec(sdpLine);\n          if (c) {\n            current.codecs.push({\n              id: c[1],\n              name: c[2],\n              index: i\n            });\n          }\n        }\n      });\n      Log.d('PeerConnection~_setPreferredCodecs', medias);\n      let update = false;\n      const prefer = (mediaList, preferedCodec) => {\n        mediaList.forEach((media) => {\n          const selected = media.codecs.find(codec => preferedCodec.test(codec.name));\n          if (selected) {\n            const fmt = [selected.id].concat(media.fmt.filter(ids => ids !== selected.id));\n            sdpLines[media.index] = sdpLines[media.index].replace(media.fmt.join(' '),\n              fmt.join(' '));\n            update = true;\n          }\n        });\n      };\n      if (cache.config.preferredVideoCodec) {\n        prefer(medias.video, cache.config.preferredVideoCodec);\n      }\n      if (cache.config.preferredAudioCodec) {\n        prefer(medias.audio, cache.config.preferredAudioCodec);\n      }\n      if (update) {\n        Log.d('PeerConnection~_setPreferredCodecs', sdpLines.join('\\r\\n'));\n        return {\n          sdp: sdpLines.join('\\r\\n'),\n          type: description.type\n        };\n      }\n    }\n    return description;\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/webrtc/PeerConnection.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 357,
    "kind": "variable",
    "name": "DtlsSrtpKeyAgreement",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~DtlsSrtpKeyAgreement",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "{\"DtlsSrtpKeyAgreement\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 358,
    "kind": "function",
    "name": "sdpConstraints",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~sdpConstraints",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "receive",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 359,
    "kind": "variable",
    "name": "ICE_CONNECTION_STATE_DISCONNECTED",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~ICE_CONNECTION_STATE_DISCONNECTED",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "ICE connection status : disconnected",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 360,
    "kind": "variable",
    "name": "ICE_CONNECTION_STATE_CONNECTED",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~ICE_CONNECTION_STATE_CONNECTED",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "ICE connection status : connected",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 361,
    "kind": "variable",
    "name": "ICE_CONNECTION_STATE_COMPLETED",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~ICE_CONNECTION_STATE_COMPLETED",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "ICE connection status : completed",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 362,
    "kind": "variable",
    "name": "ICE_CONNECTION_STATE_CHECKING",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~ICE_CONNECTION_STATE_CHECKING",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "ICE connection status : checking",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 363,
    "kind": "variable",
    "name": "ICE_CONNECTION_STATE_CLOSED",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~ICE_CONNECTION_STATE_CLOSED",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "ICE connection status : closed",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 364,
    "kind": "variable",
    "name": "ICE_CONNECTION_STATE_FAILED",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~ICE_CONNECTION_STATE_FAILED",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "ICE connection status : failed",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 365,
    "kind": "variable",
    "name": "ICE_CONNECTION_STATE_OTHER",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~ICE_CONNECTION_STATE_OTHER",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "ICE connection status : another status",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@constant",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 366,
    "kind": "function",
    "name": "_toJSON",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~_toJSON",
    "access": "private",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 60,
    "ignore": true,
    "params": [
      {
        "name": "o",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 367,
    "kind": "class",
    "name": "PeerConnection",
    "memberof": "src/core/webrtc/PeerConnection.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/core/webrtc/PeerConnection.js",
    "importStyle": "PeerConnection",
    "description": "The PeerConnection. A PeerConnection will only concern one MediaStream.",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "PeerConnection"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 368,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#constructor",
    "access": "protected",
    "description": "",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "stackId",
        "description": "The WebRTC stack ID"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "streamId",
        "description": "The Stream UID"
      },
      {
        "nullable": null,
        "types": [
          "Remote",
          "{to: string",
          "from: string, device:string}"
        ],
        "spread": false,
        "optional": false,
        "name": "remote",
        "description": "The remote information"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "publish",
        "description": "Publish or Subscribe ?"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 369,
    "kind": "member",
    "name": "stackId",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#stackId",
    "access": "public",
    "description": "The stack identifier. Used to identify exchanges between 2 devices",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 370,
    "kind": "member",
    "name": "streamId",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#streamId",
    "access": "public",
    "description": "The stream id. (One stream per RTCPeerConnection)",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 371,
    "kind": "member",
    "name": "remote",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#remote",
    "access": "public",
    "description": "The remote device",
    "lineNumber": 88,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 372,
    "kind": "member",
    "name": "publish",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#publish",
    "access": "public",
    "description": "publish : a created peer connection or a remote one",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 373,
    "kind": "member",
    "name": "_localPath",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_localPath",
    "access": "private",
    "description": "Path for local signalization",
    "lineNumber": 99,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "_remotePath",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_remotePath",
    "access": "private",
    "description": "Path for local signalization",
    "lineNumber": 105,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 375,
    "kind": "member",
    "name": "negotiated",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#negotiated",
    "access": "public",
    "description": "Indicates if the PeerConnection has been established. (Useful for renegotiation).",
    "lineNumber": 110,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "node",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#node",
    "access": "protected",
    "description": "The DOM element where the remote MediaStream will be displayed",
    "lineNumber": 116,
    "type": {
      "nullable": null,
      "types": [
        "Element"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 377,
    "kind": "member",
    "name": "container",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#container",
    "access": "protected",
    "description": "The DOM element containg the media element",
    "lineNumber": 122,
    "type": {
      "nullable": null,
      "types": [
        "Element"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 378,
    "kind": "member",
    "name": "pc",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#pc",
    "access": "public",
    "description": "The actual RTCPeerConnection",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "RTCPeerConnection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 380,
    "kind": "member",
    "name": "_status",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_status",
    "access": "private",
    "description": "PeerConnection status",
    "lineNumber": 181,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 381,
    "kind": "method",
    "name": "_getStats",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_getStats",
    "access": "private",
    "description": null,
    "lineNumber": 184,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 382,
    "kind": "get",
    "name": "socket",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#socket",
    "access": "public",
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "member",
    "name": "_socket",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_socket",
    "access": "private",
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "_remoteICECandidates",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_remoteICECandidates",
    "access": "private",
    "description": "Toggle ICE Candidates discovery",
    "lineNumber": 216,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "listen",
        "description": "Indicates if we should listen to new ICE candidates"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "_attachStream",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_attachStream",
    "access": "private",
    "description": "Attach the remote MediaStream to a node",
    "lineNumber": 238,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 387,
    "kind": "set",
    "name": "remoteStream",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#remoteStream",
    "access": "protected",
    "description": "The remote MediaStream",
    "lineNumber": 250,
    "type": {
      "nullable": null,
      "types": [
        "MediaStream"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 388,
    "kind": "member",
    "name": "_remoteStream",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_remoteStream",
    "access": "private",
    "description": "",
    "lineNumber": 254,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "get",
    "name": "remoteStream",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#remoteStream",
    "access": "public",
    "description": "The remote MediaStream",
    "lineNumber": 262,
    "type": {
      "nullable": null,
      "types": [
        "MediaStream"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 390,
    "kind": "get",
    "name": "isConnected",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#isConnected",
    "access": "public",
    "description": "Indicates if the PeerConnection is established based on ICE connection state",
    "lineNumber": 270,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "answer",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#answer",
    "access": "protected",
    "description": "Init RTCPeerConnection for subscribers",
    "lineNumber": 285,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PeerConnection>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "htmlElement",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PeerConnection>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 395,
    "kind": "method",
    "name": "offer",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#offer",
    "access": "protected",
    "description": "Init RTCPeerConnection for publishers",
    "lineNumber": 338,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PeerConnection>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "stream",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PeerConnection>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "_sendSdpToRemote",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_sendSdpToRemote",
    "access": "private",
    "description": "Send SDP offer to the remote via DataSync",
    "lineNumber": 464,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "_sendOffer",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_sendOffer",
    "access": "private",
    "description": "Create SDP offer and push it",
    "lineNumber": 508,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "_alterStream",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_alterStream",
    "access": "private",
    "description": "Add/Remove tracks to the PeerConnection stream",
    "lineNumber": 523,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "stream",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 399,
    "kind": "method",
    "name": "renegotiate",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#renegotiate",
    "access": "protected",
    "description": "Restart SDP negotiation following a MediaStream change",
    "lineNumber": 541,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "oldStream",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "newStream",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 400,
    "kind": "method",
    "name": "close",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#close",
    "access": "protected",
    "description": "Close the PeerConnection and stop listening to SDP messages",
    "lineNumber": 577,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 405,
    "kind": "method",
    "name": "_setPreferredCodecs",
    "memberof": "src/core/webrtc/PeerConnection.js~PeerConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnection.js~PeerConnection#_setPreferredCodecs",
    "access": "private",
    "description": "Edits the SDP to set the preferred audio/video codec",
    "lineNumber": 616,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{RTCSessionDescription|{sdp: string, type: string}}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "RTCSessionDescription"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "The description retrieved by createOffer/createAnswer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "RTCSessionDescription",
        "{sdp: string, type: string}"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 406,
    "kind": "file",
    "name": "src/core/webrtc/PeerConnectionManager.js",
    "content": "import PeerConnection from './PeerConnection';\nimport cache from '../util/cache';\nimport * as Log from '../util/Log';\nimport * as DataSync from '../util/DataSync';\n\nconst getShortStackId = (id1, id2) => (\n  id1.localeCompare(id2, 'en-us') > 0 ? `${id1}-${id2}` : `${id2}-${id1}`\n);\n\n/* eslint-disable no-bitwise */\nconst hashCode = str => (\n  str\n    .split('')\n    .reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0)\n);\n/* eslint-enable no-bitwise */\n\nconst getStackId = (deviceId1, deviceId2) => {\n  const shortstackId = getShortStackId(deviceId1, deviceId2);\n\n  const hash = `${hashCode(shortstackId)}`;\n  const length = hash.length; // eslint-disable-line\n  const id1 = hash.substring(length - 3, length);\n  const id2 = hash.substring(length - 6, length - 3);\n\n  return `${id1}/${id2}/${shortstackId}`;\n};\n\n/**\n * @access protected\n */\nexport default class PeerConnectionManager {\n  /**\n   * Constructor\n   * @access protected\n   */\n  constructor() {\n    /**\n     * WebRTC stacks\n     * @type {{*: {*: PeerConnection}}}\n     */\n    this.stacks = {};\n  }\n\n  /**\n   * Get a PeerConnection object for a specific stream\n   * @param {Local|Remote} stream\n   * @param {Remote|{to: string, device:string}} remote\n   * @param {boolean} publish\n   * @return {*}\n   */\n  getPeerConnection(stream, remote, publish) {\n    if (!cache.user) {\n      return Promise.reject(\n        new Error('Only an authenticated user can get a PeerConnection\\'s object.')\n      );\n    }\n    const stackId = getStackId(remote.device, cache.device);\n\n    if (this.stacks[stackId] && this.stacks[stackId][stream.uid]) {\n      return Promise.resolve(this.stacks[stackId][stream.uid]);\n    }\n\n    if (!this.stacks[stackId]) {\n      this.stacks[stackId] = {};\n    }\n\n    const userId = cache.user.uid.split('/');\n    const shortUserId = userId[2];\n    let shortRemoteTo;\n    let shortRemoteFrom;\n    if (remote.to) {\n      const remoteTo = remote.to.split('/');\n      shortRemoteTo = remoteTo[2]; // eslint-disable-line prefer-destructuring\n    } else {\n      const remoteFrom = remote.from.split('/');\n      shortRemoteFrom = remoteFrom[2]; // eslint-disable-line prefer-destructuring\n    }\n\n    const users = {};\n    // users[cache.user.uid] = true;\n    users[shortUserId] = true;\n    // users[remote.from || remote.to] = true;\n    users[shortRemoteFrom || shortRemoteTo] = true;\n\n    return DataSync.update(`_/webrtc/${stackId}`, users)\n      .then(() => new PeerConnection(stackId, stream.uid, remote, publish))\n      .then((pc) => {\n        Log.d('PeerConnectionManager~getPeerConnection', { stackId, streamId: stream.uid, pc });\n        this.stacks[stackId][stream.uid] = pc;\n        return pc;\n      })\n      .catch(Log.r('PeerConnectionManager~getPeerConnection'));\n  }\n\n  /**\n   * Create offer for a stream to a subscriber\n   * @param {Local} localStream\n   * @param {object} subscriber\n   * @return {Promise.<PeerConnection>}\n   */\n  offer(localStream, subscriber) {\n    Log.d('PeerConnectionManager~offer', { localStream, subscriber });\n    return this.getPeerConnection(localStream, subscriber, true)\n      .then(pc => pc.offer(localStream.media));\n  }\n\n  /**\n   * Answer to the offer from the publisher\n   * @param {Remote} remoteStream\n   * @param {Element} htmlElement\n   * @return {*|Promise.<PeerConnection>}\n   */\n  answer(remoteStream, htmlElement) {\n    Log.d('PeerConnectionManager~answer', { remoteStream, htmlElement });\n    return this.getPeerConnection(remoteStream, remoteStream, false)\n      .then(pc => pc.answer(htmlElement));\n  }\n\n  /**\n   * Close a PeerConnection\n   * @param streamId\n   * @param remoteDevice\n   * @return {*}\n   */\n  close(streamId, remoteDevice) {\n    const stackId = getStackId(remoteDevice, cache.device);\n\n\n    const pc = this.stacks[stackId] ? this.stacks[stackId][streamId] : null;\n    if (pc) {\n      pc.close();\n      DataSync.remove(`_/webrtc/${stackId}`);\n      this.stacks[stackId][streamId] = null;\n      delete this.stacks[stackId][streamId];\n      return pc;\n    }\n    return false;\n  }\n}\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/core/webrtc/PeerConnectionManager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 407,
    "kind": "function",
    "name": "getShortStackId",
    "memberof": "src/core/webrtc/PeerConnectionManager.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/webrtc/PeerConnectionManager.js~getShortStackId",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnectionManager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "id1",
        "types": [
          "*"
        ]
      },
      {
        "name": "id2",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 408,
    "kind": "function",
    "name": "hashCode",
    "memberof": "src/core/webrtc/PeerConnectionManager.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/webrtc/PeerConnectionManager.js~hashCode",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnectionManager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 409,
    "kind": "function",
    "name": "getStackId",
    "memberof": "src/core/webrtc/PeerConnectionManager.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/webrtc/PeerConnectionManager.js~getStackId",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/core/webrtc/PeerConnectionManager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "deviceId1",
        "types": [
          "*"
        ]
      },
      {
        "name": "deviceId2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 410,
    "kind": "class",
    "name": "PeerConnectionManager",
    "memberof": "src/core/webrtc/PeerConnectionManager.js",
    "static": true,
    "longname": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager",
    "access": "protected",
    "export": true,
    "importPath": "Reach/src/core/webrtc/PeerConnectionManager.js",
    "importStyle": "PeerConnectionManager",
    "description": "",
    "lineNumber": 32,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 411,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager#constructor",
    "access": "protected",
    "description": "Constructor",
    "lineNumber": 37,
    "ignore": true
  },
  {
    "__docId__": 412,
    "kind": "member",
    "name": "stacks",
    "memberof": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager",
    "static": false,
    "longname": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager#stacks",
    "access": "public",
    "description": "WebRTC stacks",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "{*: {*: PeerConnection}}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 413,
    "kind": "method",
    "name": "getPeerConnection",
    "memberof": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager#getPeerConnection",
    "access": "public",
    "description": "Get a PeerConnection object for a specific stream",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Local",
          "Remote"
        ],
        "spread": false,
        "optional": false,
        "name": "stream",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Remote",
          "{to: string, device:string}"
        ],
        "spread": false,
        "optional": false,
        "name": "remote",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "publish",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "offer",
    "memberof": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager#offer",
    "access": "public",
    "description": "Create offer for a stream to a subscriber",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Local"
        ],
        "spread": false,
        "optional": false,
        "name": "localStream",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "subscriber",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PeerConnection>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "answer",
    "memberof": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager#answer",
    "access": "public",
    "description": "Answer to the offer from the publisher",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "Remote"
        ],
        "spread": false,
        "optional": false,
        "name": "remoteStream",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Element"
        ],
        "spread": false,
        "optional": false,
        "name": "htmlElement",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*",
        "Promise.<PeerConnection>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 416,
    "kind": "method",
    "name": "close",
    "memberof": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/core/webrtc/PeerConnectionManager.js~PeerConnectionManager#close",
    "access": "public",
    "description": "Close a PeerConnection",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "streamId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "remoteDevice",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 417,
    "kind": "file",
    "name": "src/definitions/Browser.js",
    "content": "import adapter from 'webrtc-adapter';\nimport Webcom from 'webcom/webcom';\n\n/**\n * The current browser's infos\n * @typedef {Object} Browser\n * @property {string} name - current browser's name\n * @property {number} [version] - current browser's version\n * @property {number} [minVersion] - current browser's minimum supported version\n * @property {boolean} compatible - is current browser supported ?\n */\nconst browser = Object.assign({\n  compatible: !/\\s/.test(adapter.browserDetails.browser)\n    && (!adapter.browserDetails.minVersion\n      || adapter.browserDetails.version >= adapter.browserDetails.minVersion)\n}, adapter.browserDetails);\n\nconst version = `Reach v${SDK_VERSION} | Schema ${SCHEMA_VERSION} | Webcom v${Webcom.SDK_VERSION}`; // eslint-disable-line no-undef\nlet message = '';\nif (browser.version === null) {\n  message = 'Unsupported browser: browser must support WebRTC Peer-to-peer connections to use Reach';\n} else if (browser.minVersion && browser.minVersion > browser.version) {\n  message = `Unsupported browser: browser is outdated, update to latest version (${browser.minVersion}+)`;\n} else if (!adapter.browserShim) {\n  message = 'No shim for your browser. There might a problem with your package.';\n}\n\n// Log browser status & SDKs versions on load\nlet args = [`${version} ${message}`];\nif (/^(chrome|firefox)$/.test(browser.browser)) {\n  args = [\n    `%c ${version} %c ${message}`,\n    `background: ${browser.compatible ? '#f50' : 'red'}; color: #fff; font-weight: bold`,\n    `color: ${browser.compatible ? 'inherit' : 'red'}`\n  ];\n}\n\nconsole.log(...args); // eslint-disable-line no-console\n\nexport default browser;\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/definitions/Browser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 418,
    "kind": "variable",
    "name": "version",
    "memberof": "src/definitions/Browser.js",
    "static": true,
    "longname": "src/definitions/Browser.js~version",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/definitions/Browser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 419,
    "kind": "variable",
    "name": "message",
    "memberof": "src/definitions/Browser.js",
    "static": true,
    "longname": "src/definitions/Browser.js~message",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/definitions/Browser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 420,
    "kind": "variable",
    "name": "args",
    "memberof": "src/definitions/Browser.js",
    "static": true,
    "longname": "src/definitions/Browser.js~args",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/definitions/Browser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 421,
    "kind": "typedef",
    "name": "Browser",
    "memberof": "src/definitions/Browser.js",
    "static": true,
    "longname": "src/definitions/Browser.js~Browser",
    "access": "public",
    "description": "The current browser's infos",
    "lineNumber": 12,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "current browser's name"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "version",
        "description": "current browser's version"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "minVersion",
        "description": "current browser's minimum supported version"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "compatible",
        "description": "is current browser supported ?"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Browser"
    }
  },
  {
    "__docId__": 422,
    "kind": "file",
    "name": "src/definitions/Codec.js",
    "content": "/**\n * Video codec presets to use for\n * @typedef {Object} Codec/video\n * @property {RegExp} VP8 VP8 is the only video codec officially supported by WebRTC\n * @property {RegExp} VP9 VP8's successor.\n * @property {RegExp} H264 MPEG-4 part 10. Only Firefox.\n * @property {RegExp} VP10 Suited for UHD video. No support yet\n * @property {RegExp} H265 H.264's successor. No support yet\n */\nexport const video = {\n  VP8: /^vp8/i,\n  VP9: /^vp9/i,\n  VP10: /^vp10/i,\n  H264: /^h264/i,\n  H265: /^h265/i\n};\n\n/**\n * Audio codec presets to use for\n * @typedef {Object} Codec/audio\n * @property {RegExp} OPUS Opus audio codec {@link http://opus-codec.org/}.\n * Only choice for high-quality audio.\n * @property {RegExp} G722 G.722 audio codec\n * @property {RegExp} G711 G.711 audio codec\n * @property {RegExp} ISAC iSAC audio codec. Good for voice data,\n * but not suitable for high-quality audio streams.\n * @property {RegExp} ISAC_16 iSAC audio codec (16kHz)\n * @property {RegExp} ISAC_32 iSAC audio codec (32kHz)\n * @property {RegExp} ILBC iLBC audio codec. For bad channels & low bandwidth.\n * @property {RegExp} ILBC iLBC audio codec. For bad channels & low bandwidth.\n */\nexport const audio = {\n  OPUS: /^opus/i,\n  G722: /^g722/i,\n  G711: /^g711/i,\n  ISAC: /^isac/i,\n  ISAC_16: /^isac\\/16000/i,\n  ISAC_32: /^isac\\/32000/i,\n  LSAC: /^lsac/i\n};\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/definitions/Codec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 423,
    "kind": "typedef",
    "name": "Codec/video",
    "memberof": "src/definitions/Codec.js",
    "static": true,
    "longname": "src/definitions/Codec.js~Codec/video",
    "access": "public",
    "description": "Video codec presets to use for",
    "lineNumber": 10,
    "properties": [
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "VP8",
        "description": "VP8 is the only video codec officially supported by WebRTC"
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "VP9",
        "description": "VP8's successor."
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "H264",
        "description": "MPEG-4 part 10. Only Firefox."
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "VP10",
        "description": "Suited for UHD video. No support yet"
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "H265",
        "description": "H.264's successor. No support yet"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Codec/video"
    }
  },
  {
    "__docId__": 424,
    "kind": "typedef",
    "name": "Codec/audio",
    "memberof": "src/definitions/Codec.js",
    "static": true,
    "longname": "src/definitions/Codec.js~Codec/audio",
    "access": "public",
    "description": "Audio codec presets to use for",
    "lineNumber": 32,
    "properties": [
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "OPUS",
        "description": "Opus audio codec {@link http://opus-codec.org/}.\nOnly choice for high-quality audio."
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "G722",
        "description": "G.722 audio codec"
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "G711",
        "description": "G.711 audio codec"
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "ISAC",
        "description": "iSAC audio codec. Good for voice data,\nbut not suitable for high-quality audio streams."
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "ISAC_16",
        "description": "iSAC audio codec (16kHz)"
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "ISAC_32",
        "description": "iSAC audio codec (32kHz)"
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "ILBC",
        "description": "iLBC audio codec. For bad channels & low bandwidth."
      },
      {
        "nullable": null,
        "types": [
          "RegExp"
        ],
        "spread": false,
        "optional": false,
        "name": "ILBC",
        "description": "iLBC audio codec. For bad channels & low bandwidth."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Codec/audio"
    }
  },
  {
    "__docId__": 425,
    "kind": "file",
    "name": "src/definitions/Events.js",
    "content": "import User from '../core/User';\nimport Room from '../core/Room';\nimport Invite from '../core/Invite';\nimport Participant from '../core/Participant';\nimport Message from '../core/Message';\nimport Remote from '../core/stream/Remote';\nimport { ACCEPTED, CANCELED, REJECTED } from '../core/util/constants';\n\n/**\n * The events supported by {@link Reach#on}\n * @typedef {Object} Events/Reach\n * @property {string} USER_ADDED Fired when a new user is registered\n * @property {string} USER_CHANGED Fired when an existing user logs in or out or changes is status\n * @property {string} USER_REMOVED Fired when a user is unregistered\n * @property {string} ROOM_ADDED Fired when a room is created\n * @property {string} ROOM_CHANGED Fired when a room status is changing\n * @property {string} ROOM_REMOVED Fired when a room is closed definitely\n * @property {string} INVITE_ADDED Fired when an invite is received\n * @property {string} INVITE_CHANGED Fired when an invite status is modified\n */\n\n/**\n * The events supported by {@link Room#on}\n * @typedef {Object} Events/Room\n * @property {string} PARTICIPANT_ADDED Fired when a new participant is added to the room.\n * Does not mean he's connected but that he's invited to\n * @property {string} PARTICIPANT_CHANGED Fired when a participant\n * changes is status (enter/leaves the room)\n * @property {string} PARTICIPANT_REMOVED Fired when a user leaves definitely or is banned\n * @property {string} MESSAGE_ADDED Fired when a new instant message is sent to the room\n * @property {string} MESSAGE_CHANGED Fired when an instant message is edited\n * @property {string} MESSAGE_REMOVED Fired when an instant message is removed\n * @property {string} STREAM_PUBLISHED Fired when a participant publishes a stream\n * @property {string} STREAM_UNPUBLISHED Fired when a participant stops the publishing of his stream\n */\n\n/**\n * The events supported by {@link Invite#on}\n * @typedef {Object} Events/Invite\n * @property {string} ACCEPTED Fired when the invite has been accepted\n * @property {string} REJECTED Fired when the invite has been accepted\n * @property {string} CANCELED Fired when the invite has been canceled\n */\n\n/**\n * The events supported by {@link Remote#on}.\n * @typedef {Object} Events/Stream\n * @property {string} MUTE Fired when the mute status of the stream changes\n * @property {string} SIZE Fired when the size of the stream changes\n */\n\n/**\n * Path configuration for each event\n * @ignore\n * @type {{}}\n */\nconst paths = {\n  USER: () => 'users',\n  ROOM: () => 'rooms',\n  INVITE: (user) => {\n    if (!user) {\n      throw new Error('You must be authenticated to list the invites');\n    }\n    return `_/invites/${user.uid}`;\n  },\n  PARTICIPANT: room => `_/rooms/${room.uid}/participants`,\n  MESSAGE: room => `_/rooms/${room.uid}/messages`,\n  STREAM: room => `_/rooms/${room.uid}/streams`\n};\n\n/**\n * Object type configuration for each event\n * @ignore\n * @type {{}}\n */\nconst classes = {\n  USER: User,\n  ROOM: Room,\n  INVITE: Invite,\n  PARTICIPANT: Participant,\n  MESSAGE: Message,\n  STREAM: Remote\n};\n\n/**\n * Private class to add support test methods\n * @class _Events\n * @ignore\n */\nclass _Events {\n  constructor(keys) {\n    keys.forEach((key) => {\n      this[key] = key;\n    });\n  }\n\n  supports(event) {\n    if (!event || typeof event !== 'string' || this[event] !== event.toUpperCase()) {\n      throw (\n        new Error(`Unsupported event. Use one of the following: ${JSON.stringify(Object.keys(this))}`)\n      );\n    }\n    return true;\n  }\n\n  toPath(event) {\n    if (this.supports(event)) {\n      return paths[event.toUpperCase().replace(/_.*$/, '')] || (() => null);\n    }\n    return null;\n  }\n\n  toClass(event) {\n    if (this.supports(event)) {\n      return classes[event.toUpperCase().replace(/_.*$/, '')];\n    }\n    return null;\n  }\n}\n\n/**\n * @ignore\n */\nexport const reach = new _Events([\n  'USER_ADDED', 'USER_CHANGED', 'USER_REMOVED',\n  'ROOM_ADDED', 'ROOM_CHANGED', 'ROOM_REMOVED',\n  'INVITE_ADDED', 'INVITE_CHANGED'\n]);\n\n/**\n * @ignore\n */\nexport const room = new _Events([\n  'MESSAGE_ADDED', 'MESSAGE_CHANGED', 'MESSAGE_REMOVED',\n  'PARTICIPANT_ADDED', 'PARTICIPANT_CHANGED', 'PARTICIPANT_REMOVED',\n  'STREAM_PUBLISHED', 'STREAM_UNPUBLISHED'\n]);\n\n/**\n * @ignore\n */\nexport const stream = new _Events(['MUTE', 'SIZE']);\n\n/**\n * @ignore\n */\nexport const invite = new _Events([ACCEPTED, REJECTED, CANCELED]);\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/definitions/Events.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 426,
    "kind": "typedef",
    "name": "Events/Reach",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~Events/Reach",
    "access": "public",
    "description": "The events supported by {@link Reach#on}",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "USER_ADDED",
        "description": "Fired when a new user is registered"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "USER_CHANGED",
        "description": "Fired when an existing user logs in or out or changes is status"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "USER_REMOVED",
        "description": "Fired when a user is unregistered"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ROOM_ADDED",
        "description": "Fired when a room is created"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ROOM_CHANGED",
        "description": "Fired when a room status is changing"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ROOM_REMOVED",
        "description": "Fired when a room is closed definitely"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "INVITE_ADDED",
        "description": "Fired when an invite is received"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "INVITE_CHANGED",
        "description": "Fired when an invite status is modified"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Events/Reach"
    }
  },
  {
    "__docId__": 427,
    "kind": "typedef",
    "name": "Events/Room",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~Events/Room",
    "access": "public",
    "description": "The events supported by {@link Room#on}",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "PARTICIPANT_ADDED",
        "description": "Fired when a new participant is added to the room.\nDoes not mean he's connected but that he's invited to"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "PARTICIPANT_CHANGED",
        "description": "Fired when a participant\nchanges is status (enter/leaves the room)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "PARTICIPANT_REMOVED",
        "description": "Fired when a user leaves definitely or is banned"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "MESSAGE_ADDED",
        "description": "Fired when a new instant message is sent to the room"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "MESSAGE_CHANGED",
        "description": "Fired when an instant message is edited"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "MESSAGE_REMOVED",
        "description": "Fired when an instant message is removed"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "STREAM_PUBLISHED",
        "description": "Fired when a participant publishes a stream"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "STREAM_UNPUBLISHED",
        "description": "Fired when a participant stops the publishing of his stream"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Events/Room"
    }
  },
  {
    "__docId__": 428,
    "kind": "typedef",
    "name": "Events/Invite",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~Events/Invite",
    "access": "public",
    "description": "The events supported by {@link Invite#on}",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ACCEPTED",
        "description": "Fired when the invite has been accepted"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "REJECTED",
        "description": "Fired when the invite has been accepted"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "CANCELED",
        "description": "Fired when the invite has been canceled"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Events/Invite"
    }
  },
  {
    "__docId__": 429,
    "kind": "typedef",
    "name": "Events/Stream",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~Events/Stream",
    "access": "public",
    "description": "The events supported by {@link Remote#on}.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "MUTE",
        "description": "Fired when the mute status of the stream changes"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "SIZE",
        "description": "Fired when the size of the stream changes"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Events/Stream"
    }
  },
  {
    "__docId__": 430,
    "kind": "variable",
    "name": "paths",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~paths",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/definitions/Events.js",
    "importStyle": null,
    "description": "Path configuration for each event",
    "lineNumber": 57,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "{}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 431,
    "kind": "variable",
    "name": "classes",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~classes",
    "access": "public",
    "export": false,
    "importPath": "Reach/src/definitions/Events.js",
    "importStyle": null,
    "description": "Object type configuration for each event",
    "lineNumber": 76,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "{}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 432,
    "kind": "variable",
    "name": "reach",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~reach",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/Events.js",
    "importStyle": "{reach}",
    "description": "",
    "lineNumber": 124,
    "ignore": true,
    "type": {
      "types": [
        "src/definitions/Events.js~_Events"
      ]
    }
  },
  {
    "__docId__": 433,
    "kind": "variable",
    "name": "room",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~room",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/Events.js",
    "importStyle": "{room}",
    "description": "",
    "lineNumber": 133,
    "ignore": true,
    "type": {
      "types": [
        "src/definitions/Events.js~_Events"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "variable",
    "name": "stream",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~stream",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/Events.js",
    "importStyle": "{stream}",
    "description": "",
    "lineNumber": 142,
    "ignore": true,
    "type": {
      "types": [
        "src/definitions/Events.js~_Events"
      ]
    }
  },
  {
    "__docId__": 435,
    "kind": "variable",
    "name": "invite",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~invite",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/Events.js",
    "importStyle": "{invite}",
    "description": "",
    "lineNumber": 147,
    "ignore": true,
    "type": {
      "types": [
        "src/definitions/Events.js~_Events"
      ]
    }
  },
  {
    "__docId__": 436,
    "kind": "class",
    "name": "_Events",
    "memberof": "src/definitions/Events.js",
    "static": true,
    "longname": "src/definitions/Events.js~_Events",
    "access": "private",
    "export": true,
    "importPath": "Reach/src/definitions/Events.js",
    "importStyle": null,
    "description": "Private class to add support test methods",
    "lineNumber": 90,
    "ignore": true,
    "pseudoExport": true,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "_Events"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 437,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/definitions/Events.js~_Events",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/definitions/Events.js~_Events#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true
  },
  {
    "__docId__": 438,
    "kind": "member",
    "name": "[key]",
    "memberof": "src/definitions/Events.js~_Events",
    "static": false,
    "longname": "src/definitions/Events.js~_Events#[key]",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "supports",
    "memberof": "src/definitions/Events.js~_Events",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/definitions/Events.js~_Events#supports",
    "access": "public",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "params": [
      {
        "name": "event",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "toPath",
    "memberof": "src/definitions/Events.js~_Events",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/definitions/Events.js~_Events#toPath",
    "access": "public",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "params": [
      {
        "name": "event",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 441,
    "kind": "method",
    "name": "toClass",
    "memberof": "src/definitions/Events.js~_Events",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/definitions/Events.js~_Events#toClass",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [
      {
        "name": "event",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "file",
    "name": "src/definitions/ICEServer.js",
    "content": "/**\n * TURN/STUN server configuration\n * @typedef {Object} ICEServer\n * @property {string|string[]} urls - The server url. (*stun:<ip|hostname>:<port>*\n * or *turn:<ip|hostname>:<port?>*)\n * @property {string} [username] - The user name for this server\n * @property {string} [credential] - The password for this server\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/definitions/ICEServer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 443,
    "kind": "typedef",
    "name": "ICEServer",
    "memberof": "src/definitions/ICEServer.js",
    "static": true,
    "longname": "src/definitions/ICEServer.js~ICEServer",
    "access": "public",
    "description": "TURN/STUN server configuration",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string",
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "urls",
        "description": "The server url. (*stun:<ip|hostname>:<port>*\nor *turn:<ip|hostname>:<port?>*)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "username",
        "description": "The user name for this server"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "credential",
        "description": "The password for this server"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ICEServer"
    }
  },
  {
    "__docId__": 444,
    "kind": "file",
    "name": "src/definitions/StreamTypes.js",
    "content": "/**\n * The available stream types\n * @typedef {Object} StreamTypes\n * @property {string} AUDIO='audio' - Audio communication service\n * @property {string} VIDEO='video' - Video communication service\n * @property {string} AUDIO_VIDEO='audio-video' - Audio and video communication service\n * @property {string} SCREEN_SHARING='screen-sharing' - Screen-sharing communication service\n */\n\n/**\n * Audio communication service\n * @ignore\n * @type {string}\n */\nexport const AUDIO = 'audio';\n/**\n * Video communication service\n * @ignore\n * @type {string}\n */\nexport const VIDEO = 'video';\n/**\n * Audio and video communication service\n * @ignore\n * @type {string}\n */\nexport const AUDIO_VIDEO = 'audio-video';\n/**\n * Screen-sharing service\n * @ignore\n * @type {string}\n */\nexport const SCREEN_SHARING = 'screen-sharing';\n\nexport default {\n  AUDIO, VIDEO, AUDIO_VIDEO, SCREEN_SHARING\n};\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/definitions/StreamTypes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 445,
    "kind": "typedef",
    "name": "StreamTypes",
    "memberof": "src/definitions/StreamTypes.js",
    "static": true,
    "longname": "src/definitions/StreamTypes.js~StreamTypes",
    "access": "public",
    "description": "The available stream types",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "defaultValue": "'audio'",
        "defaultRaw": "'audio'",
        "name": "AUDIO",
        "description": "Audio communication service"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "defaultValue": "'video'",
        "defaultRaw": "'video'",
        "name": "VIDEO",
        "description": "Video communication service"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "defaultValue": "'audio-video'",
        "defaultRaw": "'audio-video'",
        "name": "AUDIO_VIDEO",
        "description": "Audio and video communication service"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "defaultValue": "'screen-sharing'",
        "defaultRaw": "'screen-sharing'",
        "name": "SCREEN_SHARING",
        "description": "Screen-sharing communication service"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "StreamTypes"
    }
  },
  {
    "__docId__": 446,
    "kind": "variable",
    "name": "AUDIO",
    "memberof": "src/definitions/StreamTypes.js",
    "static": true,
    "longname": "src/definitions/StreamTypes.js~AUDIO",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/StreamTypes.js",
    "importStyle": "{AUDIO}",
    "description": "Audio communication service",
    "lineNumber": 15,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 447,
    "kind": "variable",
    "name": "VIDEO",
    "memberof": "src/definitions/StreamTypes.js",
    "static": true,
    "longname": "src/definitions/StreamTypes.js~VIDEO",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/StreamTypes.js",
    "importStyle": "{VIDEO}",
    "description": "Video communication service",
    "lineNumber": 21,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 448,
    "kind": "variable",
    "name": "AUDIO_VIDEO",
    "memberof": "src/definitions/StreamTypes.js",
    "static": true,
    "longname": "src/definitions/StreamTypes.js~AUDIO_VIDEO",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/StreamTypes.js",
    "importStyle": "{AUDIO_VIDEO}",
    "description": "Audio and video communication service",
    "lineNumber": 27,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 449,
    "kind": "variable",
    "name": "SCREEN_SHARING",
    "memberof": "src/definitions/StreamTypes.js",
    "static": true,
    "longname": "src/definitions/StreamTypes.js~SCREEN_SHARING",
    "access": "public",
    "export": true,
    "importPath": "Reach/src/definitions/StreamTypes.js",
    "importStyle": "{SCREEN_SHARING}",
    "description": "Screen-sharing service",
    "lineNumber": 33,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 450,
    "kind": "file",
    "name": "src/external/datasync/Webcom.js",
    "content": "/**\n * @external {Webcom} https://datasync.orange.com/doc/Webcom.html\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/datasync/Webcom.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 451,
    "kind": "external",
    "name": "Webcom",
    "externalLink": "https://datasync.orange.com/doc/Webcom.html",
    "memberof": "src/external/datasync/Webcom.js",
    "static": true,
    "longname": "src/external/datasync/Webcom.js~Webcom",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 452,
    "kind": "file",
    "name": "src/external/datasync/api.DataSnapshot.js",
    "content": "/**\n * @external {Webcom/api.DataSnapshot} https://datasync.orange.com/doc/api.DataSnapshot.html\n * @access protected\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/datasync/api.DataSnapshot.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 453,
    "kind": "external",
    "name": "Webcom/api.DataSnapshot",
    "externalLink": "https://datasync.orange.com/doc/api.DataSnapshot.html",
    "memberof": "src/external/datasync/api.DataSnapshot.js",
    "static": true,
    "longname": "src/external/datasync/api.DataSnapshot.js~Webcom/api.DataSnapshot",
    "access": "protected",
    "description": "",
    "ignore": true
  },
  {
    "__docId__": 454,
    "kind": "file",
    "name": "src/external/datasync/api.OnDisconnect.js",
    "content": "/**\n * @external {Webcom/api.OnDisconnect} https://datasync.orange.com/doc/api.OnDisconnect.html\n * @access protected\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/datasync/api.OnDisconnect.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 455,
    "kind": "external",
    "name": "Webcom/api.OnDisconnect",
    "externalLink": "https://datasync.orange.com/doc/api.OnDisconnect.html",
    "memberof": "src/external/datasync/api.OnDisconnect.js",
    "static": true,
    "longname": "src/external/datasync/api.OnDisconnect.js~Webcom/api.OnDisconnect",
    "access": "protected",
    "description": "",
    "ignore": true
  },
  {
    "__docId__": 456,
    "kind": "file",
    "name": "src/external/datasync/api.Query.js",
    "content": "/**\n * @external {Webcom/api.Query~queryCallback} https://datasync.orange.com/doc/api.Query.html#~queryCallback\n * @access protected\n */\n/**\n * @external {Webcom/api.Query~cancelCallback} https://datasync.orange.com/doc/api.Query.html#~cancelCallback\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/datasync/api.Query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 457,
    "kind": "external",
    "name": "Webcom/api.Query~queryCallback",
    "externalLink": "https://datasync.orange.com/doc/api.Query.html#~queryCallback",
    "memberof": "src/external/datasync/api.Query.js",
    "static": true,
    "longname": "src/external/datasync/api.Query.js~Webcom/api.Query~queryCallback",
    "access": "protected",
    "description": "",
    "ignore": true
  },
  {
    "__docId__": 458,
    "kind": "external",
    "name": "Webcom/api.Query~cancelCallback",
    "externalLink": "https://datasync.orange.com/doc/api.Query.html#~cancelCallback",
    "memberof": "src/external/datasync/api.Query.js",
    "static": true,
    "longname": "src/external/datasync/api.Query.js~Webcom/api.Query~cancelCallback",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 459,
    "kind": "file",
    "name": "src/external/dom/Element.js",
    "content": "/**\n * @external {Element} https://developer.mozilla.org/en-US/docs/Web/API/Element\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/dom/Element.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 460,
    "kind": "external",
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "src/external/dom/Element.js",
    "static": true,
    "longname": "src/external/dom/Element.js~Element",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 461,
    "kind": "file",
    "name": "src/external/webrtc/MediaDeviceInfo.js",
    "content": "/**\n * @external {MediaDeviceInfo} http://w3c.github.io/mediacapture-main/#idl-def-MediaDeviceInfo\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/webrtc/MediaDeviceInfo.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 462,
    "kind": "external",
    "name": "MediaDeviceInfo",
    "externalLink": "http://w3c.github.io/mediacapture-main/#idl-def-MediaDeviceInfo",
    "memberof": "src/external/webrtc/MediaDeviceInfo.js",
    "static": true,
    "longname": "src/external/webrtc/MediaDeviceInfo.js~MediaDeviceInfo",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 463,
    "kind": "file",
    "name": "src/external/webrtc/MediaStream.js",
    "content": "/**\n * @external {MediaStream} https://w3c.github.io/mediacapture-main/getusermedia.html#stream-api\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/webrtc/MediaStream.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 464,
    "kind": "external",
    "name": "MediaStream",
    "externalLink": "https://w3c.github.io/mediacapture-main/getusermedia.html#stream-api",
    "memberof": "src/external/webrtc/MediaStream.js",
    "static": true,
    "longname": "src/external/webrtc/MediaStream.js~MediaStream",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 465,
    "kind": "file",
    "name": "src/external/webrtc/MediaStreamConstrains.js",
    "content": "/**\n * @external {MediaStreamConstraints} https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/webrtc/MediaStreamConstrains.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 466,
    "kind": "external",
    "name": "MediaStreamConstraints",
    "externalLink": "https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints",
    "memberof": "src/external/webrtc/MediaStreamConstrains.js",
    "static": true,
    "longname": "src/external/webrtc/MediaStreamConstrains.js~MediaStreamConstraints",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 467,
    "kind": "file",
    "name": "src/external/webrtc/MediaTrackConstraints.js",
    "content": "/**\n * @external {MediaTrackConstraints} https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/webrtc/MediaTrackConstraints.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 468,
    "kind": "external",
    "name": "MediaTrackConstraints",
    "externalLink": "https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints",
    "memberof": "src/external/webrtc/MediaTrackConstraints.js",
    "static": true,
    "longname": "src/external/webrtc/MediaTrackConstraints.js~MediaTrackConstraints",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 469,
    "kind": "file",
    "name": "src/external/webrtc/RTCPeerConnection.js",
    "content": "/**\n * @external {RTCPeerConnection} https://w3c.github.io/webrtc-pc/#interface-definition\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/webrtc/RTCPeerConnection.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 470,
    "kind": "external",
    "name": "RTCPeerConnection",
    "externalLink": "https://w3c.github.io/webrtc-pc/#interface-definition",
    "memberof": "src/external/webrtc/RTCPeerConnection.js",
    "static": true,
    "longname": "src/external/webrtc/RTCPeerConnection.js~RTCPeerConnection",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 471,
    "kind": "file",
    "name": "src/external/webrtc/RTCRtpSender.js",
    "content": "/**\n * @external {RTCRtpSender} https://w3c.github.io/webrtc-pc/#rtcrtpsender-interface\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/webrtc/RTCRtpSender.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 472,
    "kind": "external",
    "name": "RTCRtpSender",
    "externalLink": "https://w3c.github.io/webrtc-pc/#rtcrtpsender-interface",
    "memberof": "src/external/webrtc/RTCRtpSender.js",
    "static": true,
    "longname": "src/external/webrtc/RTCRtpSender.js~RTCRtpSender",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 473,
    "kind": "file",
    "name": "src/external/webrtc/RTCSessionDescription.js",
    "content": "/**\n * @external {RTCSessionDescription} https://w3c.github.io/webrtc-pc/#rtcsessiondescription-class\n */\n",
    "static": true,
    "longname": "/home/florent/Projets/reach/src/external/webrtc/RTCSessionDescription.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 474,
    "kind": "external",
    "name": "RTCSessionDescription",
    "externalLink": "https://w3c.github.io/webrtc-pc/#rtcsessiondescription-class",
    "memberof": "src/external/webrtc/RTCSessionDescription.js",
    "static": true,
    "longname": "src/external/webrtc/RTCSessionDescription.js~RTCSessionDescription",
    "access": "public",
    "description": ""
  },
  {
    "kind": "index",
    "content": "",
    "longname": "/home/florent/Projets/reach/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"Reach\",\n  \"version\": \"3.1.0\",\n  \"description\": \"Webcom-reach\",\n  \"main\": \"dist/reach.js\",\n  \"repository\": \"https://gitlab.com/lu6fer/reach.git\",\n  \"author\": \"Webcom <webcom.ops@orange.com>\",\n  \"license\": \"MIT\",\n  \"schema\": {\n    \"version\": \"draft-00\",\n    \"url\": \"https://webcom-components.github.io/reach-schema/#draft-00\",\n    \"rules\": \"https://webcom-components.github.io/reach-schema/draft-00/security/rules.json\"\n  },\n  \"scripts\": {\n    \"dev\": \"webpack --mode development\",\n    \"build\": \"webpack --mode production\",\n    \"lint\": \"eslint src test\",\n    \"test\": \"karma start karma.conf.js\",\n    \"doc\": \"rimraf esdoc/* && esdoc\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\",\n      \"pre-commit\": \"yarn run lint\"\n    }\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.2.2\",\n    \"@babel/preset-env\": \"^7.2.3\",\n    \"@commitlint/cli\": \"^7.3.2\",\n    \"@commitlint/config-conventional\": \"^7.3.1\",\n    \"babel-eslint\": \"^10.0.1\",\n    \"babel-loader\": \"^8.0.5\",\n    \"codecov\": \"^3.1.0\",\n    \"cross-env\": \"^5.2.0\",\n    \"dotenv\": \"^6.2.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.12.0\",\n    \"eslint-config-airbnb\": \"^17.1.0\",\n    \"eslint-loader\": \"^2.1.1\",\n    \"eslint-plugin-import\": \"^2.14.0\",\n    \"eslint-plugin-jasmine\": \"^2.10.1\",\n    \"eslint-plugin-jsx-a11y\": \"^6.1.2\",\n    \"eslint-plugin-react\": \"^7.12.3\",\n    \"husky\": \"^1.3.1\",\n    \"istanbul-instrumenter-loader\": \"^3.0.1\",\n    \"jasmine-core\": \"^3.3.0\",\n    \"karma\": \"^3.1.4\",\n    \"karma-chrome-launcher\": \"^2.2.0\",\n    \"karma-coverage\": \"^1.1.2\",\n    \"karma-coverage-istanbul-reporter\": \"^2.0.4\",\n    \"karma-env-preprocessor\": \"^0.1.1\",\n    \"karma-firefox-launcher\": \"^1.1.0\",\n    \"karma-html-reporter\": \"^0.2.7\",\n    \"karma-jasmine\": \"^2.0.1\",\n    \"karma-jasmine-html-reporter\": \"^1.4.0\",\n    \"karma-mocha-reporter\": \"^2.2.5\",\n    \"karma-sourcemap-loader\": \"^0.3.7\",\n    \"karma-webpack\": \"^3.0.5\",\n    \"puppeteer\": \"^1.11.0\",\n    \"rimraf\": \"^2.6.3\",\n    \"semantic-release\": \"^15.13.3\",\n    \"webpack\": \"^4.28.3\",\n    \"webpack-bundle-analyzer\": \"^3.0.3\",\n    \"webpack-cli\": \"^3.2.1\"\n  },\n  \"dependencies\": {\n    \"core-js\": \"^2.6.2\",\n    \"socket.io-client\": \"^2.2.0\",\n    \"webcom\": \"^2.6.1\",\n    \"webrtc-adapter\": \"^7.1.1\"\n  }\n}\n",
    "longname": "/home/florent/Projets/reach/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": "Reach is a JavaScript framework relying on [Flexible DataSync](https://datasync.orange.com) to quickly add communication features to your website.\n\nReach acts as a signaling framework for all your WebRTC needs.\n\n[![Build Status](https://travis-ci.org/webcom-components/reach.svg?branch=master)](https://travis-ci.org/webcom-components/reach)\n[![Code Climate](https://codeclimate.com/github/webcom-components/reach/badges/gpa.svg)](https://codeclimate.com/github/webcom-components/reach)\n[![Test Coverage](https://codeclimate.com/github/webcom-components/reach/badges/coverage.svg)](https://codeclimate.com/github/webcom-components/reach/coverage)\n[![ESDoc](./badge.svg)](https://doc.esdoc.org/github.com/webcom-components/reach)\n[![npm version](https://img.shields.io/npm/v/webcom-reach.svg)](https://www.npmjs.com/package/webcom-reach)\n[![bower version](https://img.shields.io/bower/v/webcom-reach.svg)](https://github.com/webcom-components/reach)\n[![Dependency Status](https://david-dm.org/webcom-components/reach.svg)](https://david-dm.org/webcom-components/reach)\n[![devDependency Status](https://david-dm.org/webcom-components/reach/dev-status.svg)](https://david-dm.org/webcom-components/reach#info=devDependencies)\n[![semantic-release](https://img.shields.io/badge/%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![Stories in Ready](https://img.shields.io/waffle/label/webcom-components/reach/ready.svg)](http://waffle.io/webcom-components/reach)\n[![Stories in Progress](https://img.shields.io/waffle/label/webcom-components/reach/in%20progress.svg)](http://waffle.io/webcom-components/reach)\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/webcomOps.svg)](https://saucelabs.com/u/webcomOps)\n\n\n## Discover Flexible DataSync\n\nReach rely heavily on [Flexible DataSync][Quickstart] to exchange data between peers. Take a look at the [Flexible DataSync][Quickstart] documentation and learn how you can exchange data in real-time with a few lines of code.\n\n## Get started\n\n[Get started][ReachSDKDoc] in minutes &amp; add audio and/or video capabilities to your web app.\n\n## Live example\n\n[See how it works][VisioSampleRepo] with an example of a visio web app available [here][VisioSampleApp]. You can check the code for this sample in the dedicated Github [repo][VisioSampleRepo]\n\n[Quickstart]: https://datasync.orange.com/doc/tutorial-quickstart.html\n[ReachSDKDoc]: ./manual/tutorial/#getting-started\n[VisioSampleRepo]: https://github.com/webcom-components/visio-sample\n[VisioSampleApp]: https://webcom-components.github.io/visio-sample\n",
    "longname": "/home/florent/Projets/reach/manual/index.md",
    "name": "./manual/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/design.md",
    "name": "./manual/design.md",
    "content": "# The Data Model\n\nThe data model is described as a JSON schema on github in the [webcom-components/reach-schema](https://github.com/webcom-components/reach-schema) repo.\n \nSee [https://webcom-components.github.io/reach-schema/#draft-00](https://webcom-components.github.io/reach-schema/#draft-00) to visualize the data model used in Reach.\n\nThe corresponding Security Rules can be found [here](https://webcom-components.github.io/reach-schema/draft-00/security/rules.json).\n\nYou will need to import those rules in order to enforce security in your application. Take a look at the test results to understand these rules.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/installation.md",
    "name": "./manual/installation.md",
    "content": "# Installation\n\n## from CDN\n\nThe fastest way to get started is to serve JavaScript from [jsdelivr][JSDELIVR] or [unpkg][UNPKG]:\n\n```html\n<!-- The Flexible DataSync library -->\n<script type='text/javascript' src='https://unpkg.com/webcom/webcom'></script>\n<!-- The Reach Library -->\n<script type='text/javascript' src='https://unpkg.com/webcom-reach'></script>\n<!-- OR -->\n<script type='text/javascript' src='https://cdn.jsdelivr.net/webcom-reach/latest/reach.js'></script>\n```\n\n## Using your favorite package manager\n\n### [npm][NPM]\n\n```bash\nnpm i --save webcom-reach\n```\n\n### [yarn][YARN]\n\n```bash\nyarn add webcom-reach\n```\n\nThen just import Reach within your code :\n\n```javascript\nimport Reach from 'webcom-reach';\n```\n\n[JSDELIVR]: https://www.jsdelivr.com/projects/webcom-reach\n[UNPKG]: https://unpkg.com/webcom-reach/\n[NPM]: https://www.npmjs.com/package/webcom-reach\n[YARN]: https://yarnpkg.com/search/?q=webcom-reach\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/usage.md",
    "name": "./manual/usage.md",
    "content": "# Sharing streams\n\nStream can only be shared within a Room using the [share](../class/src/core/Room.js~Room.html#instance-method-share) method.\n\n## The `share` method\n\nThe [share](../class/src/core/Room.js~Room.html#instance-method-share) method can take up to 3 arguments.\n\n### The stream type\n\nCan be `AUDIO`, `VIDEO`, `AUDIO_VIDEO` or any of the stream type defined [here](../typedef/index.html#static-typedef-StreamTypes)\n\n### The Media constraints\n\nThe media constraints can be defined when calling [share](../class/src/core/Room.js~Room.html#instance-method-share):\n\n```javascript\nroom.share(Reach.types.AUDIO_VIDEO, {audio: true, video: {width: 1080}});\n```\n\nor on init: \n\n```javascript\nconst myReach = new Reach('https://io.datasync.orange.com/base/<your_namespace>', {\n    constraints: {audio: true, video: {width: 1080}}\n});\n```\n\nA media constraints helper is exposed as a static member of Reach. It will return a well formatted constraints object:\n\n```\n// Default constraints\nconsole.log(Reach.media.constraints());\n// Will output {\"video\":{\"width\":{\"min\":720,\"ideal\":1280,\"max\":1920},\"height\":{\"min\":576,\"ideal\":720,\"max\":1080}},\"audio\":true}\n\n// SD preset\nconsole.log(Reach.media.constraints('SD'));\n// Will output {\"video\":{\"width\":{\"min\":640,\"ideal\":720,\"max\":1280},\"height\":{\"min\":480,\"ideal\":576,\"max\":720}},\"audio\":true}\n```\n\n### The container node\n\nYou only need to provide a container node (i.e. a div), Reach will create the appropriate media element (i.e. audio or video) for the given stream.\n\n## Switching the camera\n\nOnce a stream is shared, you can switch between media devices:\n\n```javascript\nmyStream.switchCamera()\n    .then(stream => {\n        // stream is myStream\n    })\n```\n\nThe switchCamera method will loop through available video devices found via mediaDevice.enumerateDevice.\n\nYou can specify which device you want to switch to by passing the device's id to the switchCamera method.\n \nThe same method exists for switching the microphone.\n\n## Prefer Codecs\n\nOn init, you can specify a preferred codec to use when negotiating the PeerConnection.\n\n```javascript\nconst myReach = new Reach('https://io.datasync.orange.com/base/<your_namespace>', {\n    preferredAudioCodec: Reach.codecs.audio.OPUS,\n    preferredVideoCodec: Reach.codecs.video.VP9\n});\n```\n\nThe preferred codec must be specified as a RegExp. You can find predefined ones in Reach.codecs.\n\nOn negotiation, Reach will edit the SDP offer before sending it and reorder the available codecs to suit your configuration\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/tutorial.md",
    "name": "./manual/tutorial.md",
    "content": "# Getting started\n\n### Init your namespace\n\n- Go to [Flexible DataSync](https://io.datasync.orange.com/)\n- Create a new namespace\n- Download the security rules from the [reach-schema](https://webcom-components.github.io/reach-schema/draft-00/security/rules.json) repo and import them in the `security` section\n\n### Get the library\n\nSee [installation](./installation/) on how to retrieve the Reach library and its dependencies.\n\n### The bases\n\n#### The Reach object\n\nThe Reach object is your only entry point.\n\n```javascript\nconst myReach = new Reach('https://io.datasync.orange.com/base/<your_namespace>');\n```\n\nSee [configuration](./configuration/) to learn more on the available configuration possibilities.\n\n#### Register a new User\n\nCreate a basic registration form with email &amp; password and use its data:\n\n```javascript\nmyReach.register(email, password)\n    .then(user => {\n        // user is registered & authenticated\n    });\n```\n\n#### List Users &amp; Rooms\n\nOnce the user is logged in, you can list all registered users and opened rooms:\n\n```javascript\n// List users\nmyReach.users()\n    .then(users => {\n        // users is the list of registered users excluding the current one\n        // let's keep only the connected users\n        window.myUsers = users.filter(user => user.status === 'CONNECTED');\n    });\n// List rooms\nmyReach.rooms()\n    .then(rooms => {\n        // list of opened rooms\n    });\n```\n\n#### Create a Room\n\nAll users can create a room.\n\n```javascript\nmyReach.createRoom('GettingStarted')\n    .then(room => {\n        // room is the newly created room\n        window.myRoom = room;\n        // the current user has automatically joined the room\n    });\n```\n\n#### Invite one or more users\n\nLet's assume, you have selected a list of users:\n\n```javascript\nmyRoom.invite(myUsers)\n    .then((room, invites) => {\n        // An invite has been sent to all users in myUsers\n        // You can listen to invites responses\n        invites.forEach(invite => {\n            invite.on('ACCEPTED', i => {\n                // Invite has been accepted\n            });\n            invite.on('REJECTED', i => {\n                // Invite has been accepted\n            });\n        });\n    });\n```\n\n#### Respond to invitations\n\nFirst we need to listen to incoming invites:\n\n```javascript\nmyReach.on(Reach.events.reach.INVITE_ADDED, invite => {\n    // New invite received, let's accept it\n    invite.accept()\n        .then(d => {\n            // Join the room\n            window.hisRoom = d.room;\n            return d.room.join();\n        });\n});\n```\n\n#### Share the camera\n\nOnce connected to the room, a user can share a media stream with the other participants of the room.\nOnly the room participants will be able to view that stream.\n\n```javascript\nmyRoom.share(Reach.types.AUDIO_VIDEO, localVideoContainerNode, Reach.media.constraint('HD'))\n    .then(localStream => {\n        // The local Stream has been initiated, meaning `getUserMedia` has been called and that the video stream is displayed within\n        // the `localVideoContainerNode`\n    });\n```\n\nSee [stream sharing]() to get more details.\n\n#### Listen to shared streams\n\nListen to published stream right after joining the room so you won't miss any shared stream:\n\n```javascript\nhisRoom.on(Reach.event.room.STREAM_PUBLISHED, remoteStream => {\n    window.hisStream = remoteStream;\n    remoteStream.subscribe(remoteVideoContainerNode)\n        .then(() => {\n            // Remote stream is subscribed and the video should appear in the `remoteVideoContainerNode` when WebRTC peer connection is established\n        });\n});\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/configuration/index.md",
    "name": "./manual/configuration/index.md",
    "content": "# ICE management\n\nReach comes with default TURN &amp; TURNS servers configured:\n\n```json\n{\n    \"username\": \"admin\",\n    \"credential\": \"webcom1234\",\n    \"urls\": [\n        \"turns:turn1.webcom.orange.com:443\",\n        \"turn:turn1.webcom.orange.com:443?transport=tcp\",\n        \"turn:turn1.webcom.orange.com:3478?transport=tcp\"\n    ]\n}\n```\n\nBut if needed, you can over overwrite this settings either when instantiating Reach or directly in your Flexible DataSync namespace.\n\n### Configure ICE servers in app\n\nPass your ICE servers list when instantiating Reach:\n\n```\nconst myReach = new Reach('https://io.datasync.orange.com/base/<your_namespace>', {\n    iceServers: [\n        {\n            username: 'admin',\n            credential: 'webcom1234',\n            urls: [\n                'turns:turn1.webcom.orange.com:443',\n                'turn:turn1.webcom.orange.com:443?transport=tcp',\n                'turn:turn1.webcom.orange.com:3478?transport=tcp'\n            ]\n        }\n    ]\n});\n```\n\n### Configure ICE servers on server\n\nThis method prevents you from having to re-deploy your app everytime you want/need to reconfigure your ICE servers:\n\n* go to [Flexible DataSync](https://io.datasync.orange.com/)'s console\n* select your namespace\n* add your ICE servers using the `data` section on the `_/ice/` path.\n\nAll ICE servers must be of this type:\n\n```json\n{\n    \"username\": <String?>,\n    \"credential\": <String?>,\n    \"urls\": <String|String[]>\n}\n```\n\n### Limitations\n\nTo date, Mozilla Firefox doesn't support TURNS server (but it's ok for TURN et STUN server). If TURNS server are specified, they will be ignored on Firefox\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/example.md",
    "name": "./manual/example.md",
    "content": "# Example \n\n## visio-sample\n\n[visio-sample][VisioSampleRepo] is an example of a visio web app available [here][VisioSampleApp].\n\nYou can check the code for this sample in the dedicated Github [repo][VisioSampleRepo].\n\n## webirtc\n\n> webirtc is still using the legacy version of Reach\n\n[webirtc](https://io.datasync.orange.com/samples/webirtc/) is another example of a multimedia chat based on Reach.\n\n[VisioSampleRepo]: https://github.com/webcom-components/visio-sample\n[VisioSampleApp]: https://webcom-components.github.io/visio-sample\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/faq.md",
    "name": "./manual/faq.md",
    "content": "# FAQ\n\n## Is my browser supported ?\n\nReach works on the following browsers:\n\n* Google Chrome / Chromium 43+\n* Mozilla Firefox 38+\n* Microsoft Edge 13+\n\n<br>\nHowever, video codec support differs from one browser to the other. For example, Edge only supports H264UC and Chrome only VP8 and VP9, thus making them not interoperable with video.\n\nOtherwise, if your browser [supports WebRTC][caniuse], there's a high probability that Reach may work on your browser. \n\nSince Reach uses [WebRTC's adapter][adapterJS] to insulate the SDK from spec changes and prefix differences, you might find more information on supported browsers [there][adapterJS].\n\n[adapterJS]: https://github.com/webrtc/adapter\n[caniuse]: http://caniuse.com/#search=webrtc\n\n## Is version 2+ compatible with previous versions ?\n\nNo. Both model &amp; API have been completely changed.\n\n## What's next ?\n\n- Documentation:\n    - Add tutorial on user presence\n    - Add tutorial on user management\n    - Add tutorial on invite management\n    - Add tutorial on room permissions\n- Tests:\n    - Improve coverage\n    - Add End-2-End WebRTC test\n- Features:\n    - Add buddy list\n    - Add history\n    - ...\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/CONTRIBUTING.md",
    "name": "./CONTRIBUTING.md",
    "content": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/florent/Projets/reach/manual/changelog.md",
    "name": "./manual/changelog.md",
    "content": "# Changelog\n\nThe change log for Reach can be found on the repo's [Release page][RepoRELEASE].\n\n[RepoRELEASE]: https://github.com/webcom-components/reach/releases\n",
    "static": true,
    "access": "public"
  }
]